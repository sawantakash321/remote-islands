{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 4bf9a09b4bc0efc74d24","webpack:///./src/js/modules/audio.js","webpack:///./node_modules/promise/lib/core.js","webpack:///./node_modules/asap/asap.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/js/modules/islands.js","webpack:///./node_modules/knockout/build/output/knockout-latest.debug.js","webpack:///./src/js/modules/calculateInitZoomLevel.js","webpack:///./src/js/modules/calculateResponsiveLatLng.js","webpack:///./src/img/misc/loading.gif","webpack:///./src/img/misc/tinygif.gif","webpack:///./node_modules/process/browser.js","webpack:///./src/js/app.js","webpack:///./src/js/modules/generateMap.js","webpack:///./src/js/modules/ViewModel.js","webpack:///./src/js/modules/IslandConstructor.js","webpack:///./src/img/misc/home-screen-link-active.png","webpack:///./src/img/misc/home-screen-link-inactive.png","webpack:///./node_modules/howler/dist/howler.js","webpack:///./src/sounds/ocean.ogg","webpack:///./src/sounds/ocean.mp3","webpack:///./src/sounds/slide-left.ogg","webpack:///./src/sounds/slide-left.mp3","webpack:///./src/sounds/slide-right.ogg","webpack:///./src/sounds/slide-right.mp3","webpack:///./src/sounds/filter-change.ogg","webpack:///./src/sounds/filter-change.mp3","webpack:///./src/sounds/mouse-enter-island-name-or-home-link.ogg","webpack:///./src/sounds/mouse-enter-island-name-or-home-link.mp3","webpack:///./src/sounds/mouse-enter-arrow-button-or-marker-or-home-link.ogg","webpack:///./src/sounds/mouse-enter-arrow-button-or-marker-or-home-link.mp3","webpack:///./src/sounds/mouse-click.ogg","webpack:///./src/sounds/mouse-click.mp3","webpack:///./src/sounds/ajax-success.ogg","webpack:///./src/sounds/ajax-success.mp3","webpack:///./src/sounds/ajax-error.ogg","webpack:///./src/sounds/ajax-error.mp3","webpack:///./src/sounds/seagull-1.ogg","webpack:///./src/sounds/seagull-1.mp3","webpack:///./src/sounds/seagull-2.ogg","webpack:///./src/sounds/seagull-2.mp3","webpack:///./src/sounds/seagull-3.ogg","webpack:///./src/sounds/seagull-3.mp3","webpack:///./src/sounds/seagull-4.ogg","webpack:///./src/sounds/seagull-4.mp3","webpack:///./src/sounds/seagull-5.ogg","webpack:///./src/sounds/seagull-5.mp3","webpack:///./src/sounds/seagull-6.ogg","webpack:///./src/sounds/seagull-6.mp3","webpack:///./src/sounds/seagull-7.ogg","webpack:///./src/sounds/seagull-7.mp3","webpack:///./src/sounds/seagull-8.ogg","webpack:///./src/sounds/seagull-8.mp3","webpack:///./src/sounds/seagull-9.ogg","webpack:///./src/sounds/seagull-9.mp3","webpack:///./src/sounds/seagull-10.ogg","webpack:///./src/sounds/seagull-10.mp3","webpack:///./src/sounds/seagull-11.ogg","webpack:///./src/sounds/seagull-11.mp3","webpack:///./src/sounds/seagull-12.ogg","webpack:///./src/sounds/seagull-12.mp3","webpack:///./src/sounds/seagull-13.ogg","webpack:///./src/sounds/seagull-13.mp3","webpack:///./src/sounds/seagull-14.ogg","webpack:///./src/sounds/seagull-14.mp3","webpack:///./src/sounds/seagull-15.ogg","webpack:///./src/sounds/seagull-15.mp3","webpack:///./src/js/modules/getNumberToDivideTextboxHeightBy.js","webpack:///./src/js/modules/makeMarker.js","webpack:///./src/js/modules/populateInfoWindow.js","webpack:///./src/img/misc/close-button-transparent-background.gif","webpack:///./src/js/modules/styleInfoWindow.js","webpack:///./src/js/modules/makeCustomMarkerIcon.js","webpack:///./src/img/pins/left-leaning-brown-pin.png","webpack:///./src/img/pins/straight-brown-pin.png","webpack:///./src/img/pins/right-leaning-brown-pin.png","webpack:///./src/img/pins/left-leaning-green-pin.png","webpack:///./src/img/pins/straight-green-pin.png","webpack:///./src/img/pins/right-leaning-green-pin.png","webpack:///./src/js/modules/setMinAndMaxZoomLevels.js","webpack:///./src/js/modules/getOverlayTileURL.js","webpack:///./src/js/modules/mapStyles.js","webpack:///./node_modules/google-maps-api/index.js","webpack:///./node_modules/scriptjs/dist/script.js","webpack:///./node_modules/promise/index.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/promise/lib/done.js","webpack:///./node_modules/promise/lib/es6-extensions.js","webpack:///./node_modules/promise/lib/node-extensions.js","webpack:///./src/js/modules/initLoadingScreen.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","parentJsonpFunction","window","chunkIds","moreModules","executeModules","chunkId","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","shift","2","e","onScriptComplete","script","onerror","onload","clearTimeout","timeout","chunk","Error","undefined","installedChunkData","Promise","resolve","promise","reject","head","document","getElementsByTagName","createElement","type","charset","async","nc","setAttribute","src","p","setTimeout","appendChild","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","n","__esModule","object","property","oe","err","console","error","s","__webpack_exports__","playOrStopSeagullSFX","map","globalView","playRandomlySelectedSeagull","randomlySelectedSeagull","seagulls","randomIndex","_src","lastSelectedSeagull","play","randomTimeoutDuration","Math","floor","random","forEach","seagull","stop","audioCtx","biquadFilter","gainNode","slideLeft","slideRight","filterChange","mouseEnterIslandNameOrHomeLink","mouseEnterArrowButtonOrMarkerOrHomeLink","mouseClick","ajaxSuccess","ajaxError","ocean","__WEBPACK_IMPORTED_MODULE_0_howler__","__WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg__","__WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg___default","__WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3__","__WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3___default","__WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg__","__WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg___default","__WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3__","__WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3___default","__WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg__","__WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg___default","__WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3__","__WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3___default","__WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg__","__WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg___default","__WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3__","__WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3___default","__WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg__","__WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg___default","__WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3__","__WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3___default","__WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg__","__WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg___default","__WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3__","__WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3___default","__WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg__","__WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg___default","__WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3__","__WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3___default","__WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg__","__WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg___default","__WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3__","__WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3___default","__WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg__","__WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg___default","__WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3__","__WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3___default","__WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg__","__WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg___default","__WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3__","__WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3___default","__WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg__","__WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg___default","__WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3__","__WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3___default","__WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg__","__WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg___default","__WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3__","__WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3___default","__WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg__","__WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg___default","__WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3__","__WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3___default","__WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg__","__WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg___default","__WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3__","__WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3___default","__WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg__","__WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg___default","__WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3__","__WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3___default","__WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg__","__WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg___default","__WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3__","__WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3___default","__WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg__","__WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg___default","__WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3__","__WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3___default","__WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg__","__WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg___default","__WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3__","__WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3___default","__WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg__","__WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg___default","__WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3__","__WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3___default","__WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg__","__WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg___default","__WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3__","__WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3___default","__WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg__","__WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg___default","__WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3__","__WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3___default","__WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg__","__WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg___default","__WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3__","__WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3___default","__WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg__","__WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg___default","__WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3__","__WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3___default","__WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg__","__WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg___default","__WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3__","__WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3___default","oceanURL","canPlayType","a","AudioContext","webkitAudioContext","createBufferSource","createBiquadFilter","createGain","request","XMLHttpRequest","open","responseType","decodeAudioData","response","buffer","connect","frequency","value","gain","setValueAtTime","exponentialRampToValueAtTime","currentTime","destination","loop","log","send","Howl","volume","seagull1","seagull2","seagull3","seagull4","seagull5","seagull6","seagull7","seagull8","seagull9","seagull10","seagull11","seagull12","seagull13","seagull14","seagull15","fn","handle","deferred","state","deferreds","asap","cb","onFulfilled","onRejected","ret","newValue","self","TypeError","then","doResolve","bind","finale","len","this","constructor","Handler","done","reason","ex","process","setImmediate","flush","next","task","domain","enter","isNodeJS","exit","flushing","tail","requestFlush","nextTick","MessageChannel","channel","port1","onmessage","port2","postMessage","g","Function","eval","islandModel","latLngBounds","lat","lng","markerPosition","bookExcerpt","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","navigator","jQueryInstance","JSON","factory","apply","koExports","amdRequire","valuesArePrimitiveAndEqual","b","primitiveTypes","throttle","callback","timeoutInstance","ko","utils","debounce","applyExtenders","requestedExtenders","target","objectForEach","key","extenderHandler","extenders","limitNotifySubscribers","event","defaultEvent","_limitBeforeChange","_origNotifySubscribers","_limitChange","computedDisposeDependencyCallback","id","entryToDispose","dispose","computedBeginDependencyDetectionCallback","subscribable","computedObservable","computedState","isDisposed","disposalCount","disposalCandidates","addDependencyTracking","dependencyTracking","isSleeping","_target","subscribeToDependency","_notificationIsPending","_notifyNextChangeIfValueIsDifferent","makeWithIfBinding","bindingKey","isWith","isNot","makeContextCallback","bindingHandlers","init","element","valueAccessor","allBindings","viewModel","bindingContext","didDisplayOnLastUpdate","savedNodes","computed","rawValue","dataValue","unwrapObservable","shouldDisplay","isFirstRender","computedContext","getDependenciesCount","cloneNodes","virtualElements","childNodes","setDomNodeChildren","applyBindingsToDescendants","emptyNode","disposeWhenNodeIsRemoved","controlsDescendantBindings","expressionRewriting","bindingRewriteValidators","allowedBindings","exportSymbol","koPath","tokens","split","exportProperty","owner","publicName","version","options","deferUpdates","useOnlyNativeEvents","obj","action","prop","extend","source","setPrototypeOf","proto","__proto__","isClickOnCheckableElement","eventType","tagNameLower","toLowerCase","inputType","toggleDomNodeCssClass","node","classNames","shouldHaveClass","addOrRemoveFn","classList","arrayForEach","match","cssClassNameRegex","className","toggleObjectClassPropertyString","currentClassNames","addOrRemoveItem","join","canSetPrototype","Array","knownEvents","knownEventTypesByEventName","test","userAgent","knownEventsForType","j","eventsThatMustBeRegisteredUsingAttachEvent","propertychange","ieVersion","div","iElems","innerHTML","isIe6","isIe7","fieldsIncludedWithJsonPost","array","arrayIndexOf","item","indexOf","arrayFirst","predicate","predicateOwner","arrayRemoveItem","itemToRemove","index","splice","arrayGetDistinctValues","result","arrayMap","mapping","arrayFilter","arrayPushAll","valuesToPush","included","existingEntryIndex","peekObservable","setPrototypeOfOrExtend","objectMap","emptyDomNode","domNode","firstChild","removeNode","moveCleanedNodesToContainerElement","nodes","nodesArray","makeArray","templateDocument","ownerDocument","container","cleanNode","shouldCleanNodes","newNodesArray","clonedNode","cloneNode","replaceDomNodes","nodeToReplaceOrNodeArray","nodesToReplaceArray","nodeType","insertionPoint","parent","parentNode","insertBefore","fixUpContinuousNodeArray","continuousNodeArray","current","last","nextSibling","setOptionNodeSelectionState","optionNode","isSelected","selected","stringTrim","string","trim","toString","replace","stringStartsWith","startsWith","substring","domNodeIsContainedBy","containedByNode","contains","compareDocumentPosition","domNodeIsAttachedToDocument","documentElement","anyDomNodeIsAttachedToDocument","tagName","catchFunctionErrors","delegate","arguments","handler","deferError","registerEventHandler","wrappedHandler","mustUseAttachEvent","addEventListener","attachEvent","attachEventHandler","attachEventName","domNodeDisposal","addDisposeCallback","detachEvent","triggerEvent","useClickWorkaround","createEvent","dispatchEvent","eventCategory","initEvent","click","fireEvent","isObservable","peek","setTextContent","textContent","innerTextNode","createTextNode","data","forceRefresh","setElementName","mergeAttributes","elem","style","zoom","ensureSelectElementIsRenderedCorrectly","selectElement","originalWidth","width","range","min","max","arrayLikeObject","createSymbolOrString","identifier","getFormFields","form","fieldName","fields","concat","isMatchingField","field","matches","parseJson","jsonString","parse","stringifyJson","replacer","space","stringify","postJson","urlOrForm","params","includeFields","url","originalForm","display","method","input","body","submit","removeChild","originalFunction","partialArgs","slice","args","domData","getAll","createIfNotFound","dataStoreKey","dataStoreKeyExpandoPropertyName","dataStore","uniqueId","Date","getTime","allDataForNode","set","clear","nextKey","getDisposeCallbacksCollection","allDisposeCallbacks","domDataKey","destroyCallbacksCollection","cleanSingleNode","callbacks","cleanableNodeTypesWithDescendants","cleanImmediateCommentTypeChildren","nodeWithChildren","child","nextChild","cleanableNodeTypes","1","8","9","removeDisposeCallback","callbacksCollection","descendants","cleanExternalData","getWrap","tags","lookup","none","simpleHtmlParse","html","documentContext","windowContext","wrap","depth","markup","mayRequireCreateElementHack","lastChild","jQueryHtmlParse","elems","table","tbody","tr","select","thead","tfoot","td","th","option","optgroup","parseHtmlFragment","setHtml","parsedNodes","memoization","randomMax8HexChars","generateRandomId","findMemoNodes","rootNode","appendToArray","memoId","parseMemoText","nodeValue","memos","memoize","unmemoize","callbackParams","unmemoizeDomNodeAndDescendants","extraCallbackParamsArray","combinedParams","memoText","tasks","processTasks","taskQueueLength","mark","countMarks","nextIndexToProcess","taskQueue","scheduledProcess","scheduleTaskProcessing","scheduler","nextHandle","MutationObserver","observe","attributes","toggle","onreadystatechange","schedule","func","cancel","resetForTesting","runEarly","writeTimeoutInstance","dependentObservable","read","write","rateLimit","limitFunction","_deferUpdates","limit","ignoreUpdates","notify","notifyWhen","boolean","number","subscription","disposeCallback","ko_subscribable_fn","instance","_subscriptions","change","_versionNumber","subscribe","callbackTarget","boundCallback","afterSubscriptionRemove","beforeSubscriptionAdd","notifySubscribers","valueToNotify","updateVersion","hasSubscriptionsForEvent","subs","_changeSubscriptions","dependencyDetection","begin","end","getVersion","hasChanged","versionToCheck","ignoreBeforeChange","notifyNextChange","previousValue","pendingValue","selfIsObservable","finish","_evalIfChanged","shouldNotify","isDifferent","getSubscriptionsCount","total","eventName","subscriptions","oldValue","isSubscribable","getId","lastId","outerFrames","currentFrame","pop","registerDependency","_id","ignore","callbackArgs","isInitial","ignoreDependencies","observableLatestValue","observable","initialValue","valueWillMutate","valueHasMutated","observableFn","equalityComparer","protoProperty","hasPrototype","isWriteableObservable","observableArray","initialValues","trackArrayChanges","remove","valueOrPredicate","underlyingArray","removedValues","removeAll","arrayOfValues","allValues","destroy","destroyAll","oldItem","newItem","methodName","cacheDiffForKnownOperation","methodCallResult","arrayChangeEventName","trackChanges","trackingChanges","underlyingNotifySubscribersFunction","pendingNotifications","previousContents","cachedDiff","arrayChangeSubscription","currentContents","changes","getChanges","compareArrays","compareArrayOptions","underlyingBeforeSubscriptionAddFunction","underlyingAfterSubscriptionRemoveFunction","rawArray","operationName","pushDiff","status","diff","arrayLength","argsLength","offset","startIndex","endDeleteIndex","endAddIndex","endIndex","additions","deletions","argsIndex","findMovesInArrayComparison","evaluatorFunctionOrOptions","evaluatorFunctionTarget","writeFunction","isDirty","haveDependenciesChanged","evaluateImmediate","latestValue","isStale","isBeingEvaluated","suppressDisposalUntilDisposeWhenReturnsFalse","pure","readFunction","disposeWhen","domNodeDisposalCallback","dependenciesCount","evaluationTimeoutInstance","hasWriteFunction","computedFn","pureComputedOverrides","deferEvaluationOverrides","isActive","trackingObj","_order","_version","dependency","_evalDelayed","markDirty","respondToChange","evaluatePossiblyAsync","dirtySub","changeSub","throttleEvaluationTimeout","notifyChange","changed","evaluateImmediate_CallReadWithDependencyDetection","dependencyDetectionContext","evaluateImmediate_CallReadThenEndDependencyDetection","_latestValue","evaluate","isChange","dependeciesOrder","order","protoProp","isComputed","isPureComputed","pureComputed","mapJsObjectGraph","rootObject","mapInputCallback","visitedObjects","objectLookup","RegExp","String","Number","Boolean","outputProperties","save","visitPropertiesOrArrayEntries","indexer","propertyValue","previouslyMappedValue","visitorCallback","propertyName","keys","values","toJS","valueToMap","toJSON","plainJavaScriptObject","existingIndex","selectExtensions","readValue","optionValueDomDataKey","getAttributeNode","specified","text","selectedIndex","writeValue","allowUnset","optionValue","selection","size","getWriteableValue","expression","javaScriptReservedWords","javaScriptAssignmentTarget","parseObjectLiteral","objectLiteralString","str","charCodeAt","toks","bindingToken","tok","unknown","divisionLookBehind","keywordRegexLookBehind","substr","preProcessBindings","bindingsStringOrKeyValueArray","bindingOptions","processKeyValue","val","writableVal","bindingParams","twoWayBindings","propertyAccessorResultStrings","makeValueAccessors","resultStrings","keyValueArray","keyValue","stringDouble","in","return","typeof","keyValueArrayContainsKey","writeValueToProperty","checkIfDifferent","propWriters","isStartComment","startCommentRegex","commentNodesHaveTextProperty","isEndComment","endCommentRegex","getVirtualChildren","startComment","allowUnbalanced","currentNode","children","getMatchingEndComment","allVirtualChildren","getUnbalancedChildTags","childNode","captureRemaining","matchingEndComment","createComment","htmlTagsWithOptionallyClosingChildren","ul","ol","virtualChildren","endCommentNode","prepend","containerNode","nodeToPrepend","insertAfter","nodeToInsert","insertAfterNode","hasBindingValue","virtualNodeBindingValue","regexMatch","normaliseVirtualElementDomStructure","elementVerified","unbalancedTags","nodeToInsertBefore","createBindingsStringEvaluatorViaCache","bindingsString","cache","cacheKey","createBindingsStringEvaluator","rewrittenBindings","functionBody","bindingProvider","bindingCache","nodeHasBindings","getAttribute","components","getBindings","parsedBindings","addBindingsForCustomElement","getBindingAccessors","valueAccessors","getBindingsString","parseBindingsString","message","makeValueAccessor","evaluateValueAccessor","makeAccessorsFromFunction","makeBindingAccessors","bindings","context","getBindingsAndMakeAccessors","validateThatBindingIsAllowedForVirtualElements","bindingName","applyBindingsToDescendantsInternal","elementOrVirtualElement","bindingContextsMayDifferFromDomParentElement","currentChild","nextInQueue","provider","preprocessNode","applyBindingsToNodeAndDescendantsInternal","nodeVerified","bindingContextMayDifferFromDomParentElement","shouldBindDescendants","isElement","applyBindingsToNodeInternal","bindingDoesNotRecurseIntoElementTypes","topologicalSortBindings","bindingsConsidered","cyclicDependencyStack","pushBinding","binding","bindingDependencyKey","sourceBindings","bindingsUpdater","alreadyBound","boundElementDomDataKey","storedBindingContextForNode","_subscribable","bindingHandlerThatControlsDescendantBindings","getValueAccessor","orderedBindings","bindingKeyAndHandler","handlerInitFn","handlerUpdateFn","initResult","getBindingContext","viewModelOrBindingContext","textarea","template","dataItemOrAccessor","parentContext","dataItemAlias","extendCallback","updateContext","dataItemOrObservable","isFunc","dataItem","_addNode","unshift","properties","createStaticChildContext","exportDependencies","storedBindingContextDomDataKey","applyBindingAccessorsToNode","applyBindingsToNode","applyBindings","contextFor","dataFor","getObjectOwnProperty","propName","loadComponentAndNotify","componentName","completedAsync","loadingSubscribablesCache","beginLoadingComponent","definition","config","isSynchronousComponent","loadedDefinitionsCache","getFirstResultFromLoaders","argsExceptCallback","candidateLoaders","currentCandidateLoader","methodInstance","wasAborted","cachedDefinition","clearCachedDefinition","_getFirstResultFromLoaders","resolveConfig","errorCallback","makeCallBackWhenZero","tryIssueCallback","templateConfig","viewModelConfig","possiblyGetConfigFromAmd","loadedConfig","resolvedTemplate","resolvedViewModel","createViewModelKey","resolveTemplate","isDocumentFragment","isDomElement","cloneNodesFromTemplateSourceElement","elemInstance","getElementById","resolveViewModel","fixedInstance","componentInfo","content","HTMLElement","DocumentFragment","makeErrorCallback","defaultConfigRegistry","register","isRegistered","unregister","defaultLoader","getConfig","loadComponent","loadTemplate","loadViewModel","_allRegisteredComponents","getComponentParamsFromCustomElement","paramsAttribute","nativeBindingProviderInstance","rawParamComputedValues","paramValue","paramName","paramValueComputed","$raw","componentBindingValue","createDocumentFragment","newDocFrag","allComponents","cloneTemplateIntoElement","componentDefinition","clonedNodesArray","createViewModel","originalChildNodes","componentParams","componentViewModelFactory","templateNodes","componentLoadingOperationUniqueId","ignored1","ignored2","currentViewModel","currentLoadingOperationId","disposeAssociatedComponentViewModel","currentViewModelDispose","loadingOperationId","componentViewModel","childBindingContext","ctx","attrHtmlToJavascriptMap","class","for","update","attrName","attrValue","toRemove","removeAttribute","after","updateModel","isChecked","checked","elemValue","useCheckedValue","checkedValue","isRadio","modelValue","valueIsArray","writableValue","rawValueIsNonArrayObservable","oldElemValue","updateView","isCheckbox","disabled","eventsToHandle","handlerReturnValue","handlerFunction","argsForHandler","preventDefault","returnValue","cancelBubble","stopPropagation","makeTemplateValueAccessor","unwrappedValue","foreach","as","includeDestroyed","afterAdd","beforeRemove","afterRender","beforeMove","afterMove","templateEngine","nativeTemplateEngine","handleElementFocusChange","isFocused","ownerDoc","active","activeElement","handleElementFocusIn","handleElementFocusOut","focus","blur","captionPlaceholder","selectedOptions","applyToObject","defaultValue","predicateType","optionForArrayItem","arrayEntry","oldOptions","previousSelectedValues","valueAllowUnset","itemUpdate","optionText","setSelectionCallback","newOptions","captionValue","filteredArray","selectWasPreviouslyEmpty","multiple","previousScrollTop","scrollTop","unwrappedArray","arrayToDomNodeChildrenOptions","setDomNodeChildrenFromArrayMapping","selectionChanged","abs","valueToWrite","styleName","styleValue","parseVersion","parseFloat","operaVersion","opera","parseInt","safariVersion","firefoxVersion","selectionChangeRegisteredName","selectionChangeHandlerName","selectionChangeHandler","registerForSelectionChangeEvent","timeoutHandle","elementValueBeforeEvent","previousElementValue","elementValue","deferUpdateModel","ieUpdateModel","onEvent","preprocess","addBinding","currentIndex","eventsToCatch","requestedEventsToCatch","propertyChangedFired","valueUpdateHandler","autocomplete","updateFromModel","applyValueAction","isCurrentlyVisible","newValueAccessor","templateSource","templateSources","domElement","anonymousTemplate","rewriterCallback","rewritten","templateRewriting","validateDataBindValuesForRewriting","allValidators","validator","possibleErrorMessage","constructMemoizedTagReplacement","dataBindAttributeValue","tagToRetain","nodeName","dataBindKeyValueArray","rewrittenDataBindAttributeValue","applyBindingsToNextSiblingScript","memoizeDataBindingAttributeSyntaxRegex","memoizeVirtualContainerBindingSyntaxRegex","ensureTemplateIsRewritten","htmlString","memoizeBindingAttributeSyntax","applyMemoizedBindingsToNextSibling","nodeToBind","getTemplateDomData","templatesDomDataKey","setTemplateDomData","templateType","elemContentsProperty","dataDomDataPrefix","containerData","templateData","textData","invokeForEachNodeInContinuousRange","firstNode","lastNode","firstOutOfRangeNode","activateBindingsOnContinuousNodeArray","nextNodeInRange","nodePreviousSibling","previousSibling","newNodes","getFirstNodeFromPossibleArray","nodeOrNodeArray","executeTemplate","targetNodeOrNodeArray","renderMode","firstTargetNode","templateEngineToUse","_templateEngine","renderedNodesArray","haveAddedNodesToParent","resolveTemplateName","disposeOldComputedAndStoreNewOne","newComputed","oldComputed","templateComputedDomDataKey","setTemplateEngine","renderTemplate","dataOrBindingContext","whenToDispose","activelyDisposeWhenNodeIsRemoved","templateName","renderTemplateForEach","arrayOrObservableArray","targetNode","parentBindingContext","arrayItemContext","executeTemplateForArrayItem","arrayValue","activateBindingsCallback","addedNodesArray","bindingValue","templateComputed","dataArray","innerBindingContext","parsedBindingValue","left","right","limitFailedCompares","failedCompares","r","leftItem","rightItem","oldArray","newArray","dontLimitMoves","compareSmallArrayToBigArray","statusNotInOld","statusNotInNew","smlArray","bigArray","statusNotInSml","statusNotInBig","smlIndex","bigIndex","thisRow","lastRow","bigIndexMaxForRow","bigIndexMinForRow","myMin","myMax","editDistanceMatrix","smlIndexMax","bigIndexMax","compareRange","maxDistance","northDistance","westDistance","meMinusOne","editScript","notInSml","notInBig","reverse","mapNodeAndRefreshWhenChanged","callbackAfterAddingNodes","mappedNodes","newMappedNodes","lastMappingResultDomDataKey","deletedItemDummyValue","itemMovedOrRetained","editScriptIndex","oldPosition","mapData","lastMappingResult","newMappingResultIndex","itemsForMoveCallbacks","indexObservable","newMappingResult","itemsToProcess","callCallback","items","editScriptItem","movedIndex","isFirstExecution","lastArray","x","lastMappingResultIndex","nodesToDelete","itemsForBeforeRemoveCallbacks","itemsForAfterAddCallbacks","nextNode","initialized","useNodesIfAvailable","templateNodesFunc","templateText","jqueryTmplTemplateEngine","ensureHasReferencedJQueryTemplates","jQueryTmplVersion","compiledTemplate","jQueryTemplateOptions","precompiled","koBindingContext","resultNodes","templateMarkup","close","jqueryTmplTemplateEngineInstance","calculateInitZoomLevel","mapHeight","getElementsByClassName","clientHeight","calculateResponsiveLatLng","windowWidth","clientWidth","latLng","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","run","Item","noop","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","cwd","chdir","dir","umask","_toConsumableArray","arr","isArray","arr2","from","__WEBPACK_IMPORTED_MODULE_0__modules_generateMap__","__WEBPACK_IMPORTED_MODULE_1__css_styles_css__","__WEBPACK_IMPORTED_MODULE_2__modules_initLoadingScreen__","__WEBPACK_IMPORTED_MODULE_3__modules_audio__","onanimationstart","add","cloudArray","cloud","start","dropMarkers","global","generateMap","mapObject","_calculateResponsiveL","__WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__","Map","center","disableDefaultUI","styles","__WEBPACK_IMPORTED_MODULE_9__mapStyles__","scrollwheel","innerWidth","background","markers","infoWindow","InfoWindow","__WEBPACK_IMPORTED_MODULE_1__islands__","__WEBPACK_IMPORTED_MODULE_6__makeMarker__","bounceMarker","island","iteration","setAnimation","Animation","BOUNCE","getIslandBounds","_island$latLngBounds","_slicedToArray","southWestCoordinates","northEastCoordinates","LatLngBounds","showOverlayTiles","islandName","islandBounds","currentZoomLevel","minZoomLevel","maxZoomLevel","overlayMinZoom","overlayMaxZoom","tileURL","__WEBPACK_IMPORTED_MODULE_8__getOverlayTileURL__","overlayMapTypes","insertAt","goToSelectedIsland","removeAt","trigger","fitBounds","getZoom","_setMinAndMaxZoomLeve","__WEBPACK_IMPORTED_MODULE_7__setMinAndMaxZoomLevels__","_setMinAndMaxZoomLeve2","setZoom","textboxHeight","numberToDivideTextboxHeightBy","__WEBPACK_IMPORTED_MODULE_5__getNumberToDivideTextboxHeightBy__","textboxCompensation","panBy","__WEBPACK_IMPORTED_MODULE_0_knockout___default","__WEBPACK_IMPORTED_MODULE_2__ViewModel__","zoomLevel","__WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__","textbox","height","catch","warn","alert","__WEBPACK_IMPORTED_MODULE_0_knockout__","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","ViewModel","_this","islandsToList","currentlySelectedIsland","currentlySelectedOcean","filterChanged","__WEBPACK_IMPORTED_MODULE_7__audio__","playMouseClick","menuVisible","numberOfTimesUserHasOpenedMenu","userHasSeenMenuButton","menuHasBeenToggled","toggleMenuVisibility","arrowButtonEventType","trackArrowButtonEventType","timeToGetUsersAttention","flash","numberOfFlashes","flashArrowButton","setInterval","clearInterval","cloudImgSrcPaths","cloudsArray","default","cloudImgSrcPath","showAllIslandsOnLoad","__WEBPACK_IMPORTED_MODULE_2__IslandConstructor__","islandsCached","uniqueOceans","filter","selectOcean","selectedOcean","setMap","filteredIslands","seagullSFXArePlaying","whiteCloudFlashWhenIslandSelected","islandSelectedFromMenu","selectedIsland","activateHomeScreenLinkWhenNotInGlobalView","islandNameHover","currentlyZoomingOrPanning","initialHomeScreenLoad","requestAnimationFrame","setCenter","setOptions","getWindowWidth","passive","viewedOnDesktop","homeLinkEventType","trackHomeLinkEventType","getHomeScreenLink","__WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png___default","__WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png___default","backToHomeScreen","_calculateResponsiveL2","__WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png__","__WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png__","IslandConstructor","HowlerGlobal","Howler","_counter","_codecs","_howls","_muted","_volume","_canPlayEvent","_navigator","masterGain","noAudio","usingWebAudio","autoSuspend","mobileAutoEnable","_setup","vol","setupAudioContext","_webAudio","ids","_getSoundIds","sound","_soundById","_node","mute","muted","unload","codecs","ext","_autoSuspend","Audio","oncanplaythrough","_setupCodecs","audioTest","mpegTest","checkOpera","isOldOpera","mp3","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","_enableMobileAudio","isMobile","isTouch","maxTouchPoints","msMaxTouchPoints","_mobileEnabled","_mobileUnloaded","sampleRate","_scratchBuffer","createBuffer","unlock","_autoResume","noteOn","resume","onended","disconnect","removeEventListener","suspend","_sounds","_paused","_suspendTimer","_resumeAfterSuspend","_emit","_autoplay","autoplay","_format","format","_html5","html5","_loop","_pool","pool","_preload","preload","_rate","rate","_sprite","sprite","_duration","_state","_endTimers","_queue","_onend","onend","_onfade","onfade","_onload","_onloaderror","onloaderror","_onpause","onpause","_onplay","onplay","_onstop","onstop","_onmute","onmute","_onvolume","onvolume","_onrate","onrate","_onseek","onseek","_onresume","load","exec","location","protocol","Sound","loadBuffer","internal","num","_ended","_inactiveSound","soundId","seek","_seek","duration","_start","_stop","playWebAudio","_refreshBuffer","_playStart","bufferSource","noteGrainOn","Infinity","isRunning","_clearTimer","playHtml5","playbackRate","loadedNoReadyState","ejecta","readyState","isCocoonJS","listener","pause","_rateSeek","_stopFade","noteOff","_cleanBuffer","isNaN","fade","to","steps","stepLen","ceil","linearRampToValueAtTime","_interval","round","cancelScheduledValues","loopStart","loopEnd","realTime","playing","rateSeek","sounds","_errorFn","_loadFn","remCache","events","isId","msg","_loadQueue","ended","_drain","reset","cnt","_panner","howl","_parent","create","createGainNode","paused","_errorListener","_loadListener","code","__default","loadSound","atob","dataView","Uint8Array","xhr","safeXhrSend","arraybuffer","iOS","platform","appVersion","safari","standalone","_pos","_orientation","stereo","pan","pos","y","z","setPosition","orientation","xUp","yUp","zUp","or","setOrientation","_super","_stereo","_pannerAttr","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","panningModel","refDistance","rolloffFactor","_onstereo","onstereo","_onpos","onpos","_onorientation","onorientation","pannerType","createStereoPanner","setupPanner","pannerAttr","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_distanceModel","_maxDistance","_panningModel","_refDistance","_rolloffFactor","pa","panner","createPanner","getNumberToDivideTextboxHeightBy","currentIsland","makeMarker","position","markerSrcPathPosition","defaultIcon","__WEBPACK_IMPORTED_MODULE_2__makeCustomMarkerIcon__","highlightedIcon","__WEBPACK_IMPORTED_MODULE_0__islands__","Marker","icon","__WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif___default","optimized","flat","draggable","animation","DROP","setIcon","__WEBPACK_IMPORTED_MODULE_4__audio__","__WEBPACK_IMPORTED_MODULE_1__populateInfoWindow__","__WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif__","populateInfoWindow","showCloseButton","nearestRetrievableClass","closeButton","__WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif___default","addListenerOnce","__WEBPACK_IMPORTED_MODULE_3__audio__","setContent","panTo","__WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif___default","__WEBPACK_IMPORTED_MODULE_2__styleInfoWindow__","timestamp","now","targetUrl","fetch","ok","statusText","json","parsedHeights","heights","highestTide","indexOfHighestTide","dateAndTime","date","parsedDateAndTime","splitString","unabbreviateDate","_ref","_ref2","day","month","time","safestDateAndTimeToDock","__WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif__","__WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif__","styleInfoWindow","infoWindowStylingDiv","previousElementSibling","borderRadius","infoWindowUnderlayerParent","border","infowindowUnderlayer","backgroundColor","infoWindowPoint","_infoWindowPoint$chil","leftSideOfPoint","rightSideOfPoint","makeCustomMarkerIcon","color","customMarkerIcon","brownMarkerSrcPaths","__WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png___default","__WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png___default","__WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png___default","greenMarkerSrcPaths","__WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png___default","__WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png___default","__WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png___default","randomlySelectedBrownPin","MarkerImage","Size","Point","randomlySelectedGreenPin","__WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png__","__WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png__","__WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png__","__WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png__","__WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png__","__WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png__","setMinAndMaxZoomLevels","getOverlayTileURL","ImageMapType","getTileUrl","coord","proj","getProjection","z2","pow","tileXSize","tileYSize","mapTilesBaseURL","PRODUCTION","tileBounds","fromPointToLatLng","intersects","__WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif___default","tileSize","isPng","opacity","__WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif__","mapStyles","featureType","elementType","stylers","lightness","saturation","gamma","visibility","onOk","onErr","onComplete","maps","callBacks","$$mapsCB","google","apikey","libraries","auth","k","encodeURIComponent","every","ar","f","each","el","$script","paths","idOrDone","optDone","loopFn","list","dset","delay","idOrDoneIsDone","loading","path","force","scriptpath","scripts","loaded","doc","urlArgs","ready","deps","req","missing","dep","Timeout","clearFn","_clearFn","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","clearImmediate","tasksByHandle","registerImmediate","runIfPresent","currentlyRunningATask","attachTo","getPrototypeOf","importScripts","postMessageIsAsynchronous","oldOnMessage","messagePrefix","onGlobalMessage","ValuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","res","remaining","race","denodeify","argumentCount","nodeify","initLoadingScreen","loadingSpinner","windowHeight","innerHeight","compensation","bottom","fadeOutLoadingSpinner"],"mappings":"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,EAAA,yBtBs8UM,SAAU5C,EAAQD,EAASH,GuBt8UjCI,EAAAD,QAAAH,EAAAgD,EAAA,yBvB48UM,SAAU5C,EAAQD,EAASH,GwB58UjCI,EAAAD,QAAAH,EAAAgD,EAAA,0BxBk9UM,SAAU5C,EAAQD,EAASH,GyBl9UjCI,EAAAD,QAAAH,EAAAgD,EAAA,0BzBw9UM,SAAU5C,EAAQD,EAASH,G0Bx9UjCI,EAAAD,QAAAH,EAAAgD,EAAA,4B1B89UM,SAAU5C,EAAQD,EAASH,G2B99UjCI,EAAAD,QAAAH,EAAAgD,EAAA,4B3Bo+UM,SAAU5C,EAAQD,EAASH,G4Bp+UjCI,EAAAD,QAAAH,EAAAgD,EAAA,mD5B0+UM,SAAU5C,EAAQD,EAASH,G6B1+UjCI,EAAAD,QAAAH,EAAAgD,EAAA,mD7Bg/UM,SAAU5C,EAAQD,EAASH,G8Bh/UjCI,EAAAD,QAAAH,EAAAgD,EAAA,8D9Bs/UM,SAAU5C,EAAQD,EAASH,G+Bt/UjCI,EAAAD,QAAAH,EAAAgD,EAAA,8D/B4/UM,SAAU5C,EAAQD,EAASH,GgC5/UjCI,EAAAD,QAAAH,EAAAgD,EAAA,0BhCkgVM,SAAU5C,EAAQD,EAASH,GiClgVjCI,EAAAD,QAAAH,EAAAgD,EAAA,0BjCwgVM,SAAU5C,EAAQD,EAASH,GkCxgVjCI,EAAAD,QAAAH,EAAAgD,EAAA,2BlC8gVM,SAAU5C,EAAQD,EAASH,GmC9gVjCI,EAAAD,QAAAH,EAAAgD,EAAA,2BnCohVM,SAAU5C,EAAQD,EAASH,GoCphVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yBpC0hVM,SAAU5C,EAAQD,EAASH,GqC1hVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yBrCgiVM,SAAU5C,EAAQD,EAASH,GsChiVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBtCsiVM,SAAU5C,EAAQD,EAASH,GuCtiVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBvC4iVM,SAAU5C,EAAQD,EAASH,GwC5iVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBxCkjVM,SAAU5C,EAAQD,EAASH,GyCljVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBzCwjVM,SAAU5C,EAAQD,EAASH,G0CxjVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB1C8jVM,SAAU5C,EAAQD,EAASH,G2C9jVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB3CokVM,SAAU5C,EAAQD,EAASH,G4CpkVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB5C0kVM,SAAU5C,EAAQD,EAASH,G6C1kVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB7CglVM,SAAU5C,EAAQD,EAASH,G8ChlVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB9CslVM,SAAU5C,EAAQD,EAASH,G+CtlVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wB/C4lVM,SAAU5C,EAAQD,EAASH,GgD5lVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBhDkmVM,SAAU5C,EAAQD,EAASH,GiDlmVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBjDwmVM,SAAU5C,EAAQD,EAASH,GkDxmVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBlD8mVM,SAAU5C,EAAQD,EAASH,GmD9mVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBnDonVM,SAAU5C,EAAQD,EAASH,GoDpnVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBpD0nVM,SAAU5C,EAAQD,EAASH,GqD1nVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBrDgoVM,SAAU5C,EAAQD,EAASH,GsDhoVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBtDsoVM,SAAU5C,EAAQD,EAASH,GuDtoVjCI,EAAAD,QAAAH,EAAAgD,EAAA,wBvD4oVM,SAAU5C,EAAQD,EAASH,GwD5oVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yBxDkpVM,SAAU5C,EAAQD,EAASH,GyDlpVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yBzDwpVM,SAAU5C,EAAQD,EAASH,G0DxpVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yB1D8pVM,SAAU5C,EAAQD,EAASH,G2D9pVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yB3DoqVM,SAAU5C,EAAQD,EAASH,G4DpqVjCI,EAAAD,QAAAH,EAAAgD,EAAA,yB5D0qVM,SAAU5C,EAAQD,EAASH,G6D1qVjCI,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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId]) {\n/******/ \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n/******/ \t\t\t}\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n/******/ \t\twhile(resolves.length) {\n/******/ \t\t\tresolves.shift()();\n/******/ \t\t}\n/******/\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// objects to store loaded and loading chunks\n/******/ \tvar installedChunks = {\n/******/ \t\t2: 0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId) {\n/******/ \t\tvar installedChunkData = installedChunks[chunkId];\n/******/ \t\tif(installedChunkData === 0) {\n/******/ \t\t\treturn new Promise(function(resolve) { resolve(); });\n/******/ \t\t}\n/******/\n/******/ \t\t// a Promise means \"currently loading\".\n/******/ \t\tif(installedChunkData) {\n/******/ \t\t\treturn installedChunkData[2];\n/******/ \t\t}\n/******/\n/******/ \t\t// setup Promise in chunk cache\n/******/ \t\tvar promise = new Promise(function(resolve, reject) {\n/******/ \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n/******/ \t\t});\n/******/ \t\tinstalledChunkData[2] = promise;\n/******/\n/******/ \t\t// start chunk loading\n/******/ \t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\tvar script = document.createElement('script');\n/******/ \t\tscript.type = 'text/javascript';\n/******/ \t\tscript.charset = 'utf-8';\n/******/ \t\tscript.async = true;\n/******/ \t\tscript.timeout = 120000;\n/******/\n/******/ \t\tif (__webpack_require__.nc) {\n/******/ \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n/******/ \t\t}\n/******/ \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n/******/ \t\tscript.onerror = script.onload = onScriptComplete;\n/******/ \t\tfunction onScriptComplete() {\n/******/ \t\t\t// avoid mem leaks in IE.\n/******/ \t\t\tscript.onerror = script.onload = null;\n/******/ \t\t\tclearTimeout(timeout);\n/******/ \t\t\tvar chunk = installedChunks[chunkId];\n/******/ \t\t\tif(chunk !== 0) {\n/******/ \t\t\t\tif(chunk) {\n/******/ \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n/******/ \t\t\t\t}\n/******/ \t\t\t\tinstalledChunks[chunkId] = undefined;\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t\thead.appendChild(script);\n/******/\n/******/ \t\treturn promise;\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// on error function for async loading\n/******/ \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return audioCtx; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return biquadFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return gainNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return slideLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return slideRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return filterChange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return mouseEnterIslandNameOrHomeLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return mouseEnterArrowButtonOrMarkerOrHomeLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return mouseClick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ajaxSuccess; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ajaxError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return playOrStopSeagullSFX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return ocean; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_howler__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_howler___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_howler__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg__ = __webpack_require__(48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg__ = __webpack_require__(52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg__ = __webpack_require__(56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3__ = __webpack_require__(57);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg__ = __webpack_require__(58);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3__ = __webpack_require__(59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3__ = __webpack_require__(61);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3__ = __webpack_require__(63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg__ = __webpack_require__(64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar oceanURL = void 0;\n\n// This is to test if the browser supports playback of '.ogg' files or not. If not, then we'll\n// load 'oceanMP3' instead of 'oceanOGG'.\nvar el = document.createElement('audio');\nel.canPlayType('audio/ogg') ? oceanURL = __WEBPACK_IMPORTED_MODULE_1__sounds_ocean_ogg___default.a : oceanURL = __WEBPACK_IMPORTED_MODULE_2__sounds_ocean_mp3___default.a;\n\n// We're using the Web Audio API for playback of 'ocean.ogg/mp3' because, unlike Howler.js, it\n// allows us to filter our audio source. Why would we want to filter it? Well, when the user\n// loads the page we'll set the lowpass filter to 2khz, so the ocean sounds far away, then when they\n// zoom down to an island we'll raise the frequency to 22000khz, effectively disabling the filter,\n// so that the ocean will then sound closer to them. We'll also increase the volume. For all other\n// sounds we'll use Howler.js because it's got better cross-browser support and we don't need to\n// use filters for any of the other sounds.\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nvar audioCtx = new AudioContext();\nvar ocean = audioCtx.createBufferSource();\nvar biquadFilter = audioCtx.createBiquadFilter(); // eslint-disable-line import/no-mutable-exports\nvar gainNode = audioCtx.createGain();\nvar request = new XMLHttpRequest();\n\nrequest.open('GET', oceanURL, true);\nrequest.responseType = 'arraybuffer';\nrequest.onload = function () {\n  audioCtx.decodeAudioData(request.response, function (buffer) {\n    // This setTimeout is to delay the playback of the ocean audio until the application starts\n    // fading into view after the initial loading screen.\n    setTimeout(function () {\n      ocean.buffer = buffer;\n      ocean.connect(biquadFilter);\n      biquadFilter.type = 'lowpass';\n      biquadFilter.frequency.value = 2500;\n      biquadFilter.connect(gainNode);\n      gainNode.gain.setValueAtTime(0.01, 0);\n      gainNode.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 2.5);\n      gainNode.connect(audioCtx.destination);\n      ocean.loop = true;\n    }, 1650);\n  }, function (e) {\n    console.log('Error with decoding audio data: ' + e.err);\n  });\n};\nrequest.send();\n\nvar slideRight = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_5__sounds_slide_right_ogg___default.a, __WEBPACK_IMPORTED_MODULE_6__sounds_slide_right_mp3___default.a],\n  volume: 0.55\n});\nvar slideLeft = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_3__sounds_slide_left_ogg___default.a, __WEBPACK_IMPORTED_MODULE_4__sounds_slide_left_mp3___default.a],\n  volume: 0.55\n});\nvar filterChange = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_7__sounds_filter_change_ogg___default.a, __WEBPACK_IMPORTED_MODULE_8__sounds_filter_change_mp3___default.a],\n  volume: 0.3\n});\nvar mouseEnterIslandNameOrHomeLink = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_9__sounds_mouse_enter_island_name_or_home_link_ogg___default.a, __WEBPACK_IMPORTED_MODULE_10__sounds_mouse_enter_island_name_or_home_link_mp3___default.a],\n  volume: 0.3\n});\nvar mouseEnterArrowButtonOrMarkerOrHomeLink = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_11__sounds_mouse_enter_arrow_button_or_marker_or_home_link_ogg___default.a, __WEBPACK_IMPORTED_MODULE_12__sounds_mouse_enter_arrow_button_or_marker_or_home_link_mp3___default.a],\n  volume: 0.35\n});\nvar mouseClick = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_13__sounds_mouse_click_ogg___default.a, __WEBPACK_IMPORTED_MODULE_14__sounds_mouse_click_mp3___default.a],\n  volume: 0.25\n});\nvar ajaxSuccess = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_15__sounds_ajax_success_ogg___default.a, __WEBPACK_IMPORTED_MODULE_16__sounds_ajax_success_mp3___default.a],\n  volume: 0.4\n});\nvar ajaxError = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_17__sounds_ajax_error_ogg___default.a, __WEBPACK_IMPORTED_MODULE_18__sounds_ajax_error_mp3___default.a],\n  volume: 0.4\n});\nvar seagull1 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_19__sounds_seagull_1_ogg___default.a, __WEBPACK_IMPORTED_MODULE_20__sounds_seagull_1_mp3___default.a],\n  volume: 0.5\n});\nvar seagull2 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_21__sounds_seagull_2_ogg___default.a, __WEBPACK_IMPORTED_MODULE_22__sounds_seagull_2_mp3___default.a],\n  volume: 0.6\n});\nvar seagull3 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_23__sounds_seagull_3_ogg___default.a, __WEBPACK_IMPORTED_MODULE_24__sounds_seagull_3_mp3___default.a],\n  volume: 0.5\n});\nvar seagull4 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_25__sounds_seagull_4_ogg___default.a, __WEBPACK_IMPORTED_MODULE_26__sounds_seagull_4_mp3___default.a],\n  volume: 0.6\n});\nvar seagull5 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_27__sounds_seagull_5_ogg___default.a, __WEBPACK_IMPORTED_MODULE_28__sounds_seagull_5_mp3___default.a],\n  volume: 1.0\n});\nvar seagull6 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_29__sounds_seagull_6_ogg___default.a, __WEBPACK_IMPORTED_MODULE_30__sounds_seagull_6_mp3___default.a],\n  volume: 0.5\n});\nvar seagull7 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_31__sounds_seagull_7_ogg___default.a, __WEBPACK_IMPORTED_MODULE_32__sounds_seagull_7_mp3___default.a],\n  volume: 0.4\n});\nvar seagull8 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_33__sounds_seagull_8_ogg___default.a, __WEBPACK_IMPORTED_MODULE_34__sounds_seagull_8_mp3___default.a],\n  volume: 0.1\n});\nvar seagull9 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_35__sounds_seagull_9_ogg___default.a, __WEBPACK_IMPORTED_MODULE_36__sounds_seagull_9_mp3___default.a],\n  volume: 0.075\n});\nvar seagull10 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_37__sounds_seagull_10_ogg___default.a, __WEBPACK_IMPORTED_MODULE_38__sounds_seagull_10_mp3___default.a],\n  volume: 0.05\n});\nvar seagull11 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_39__sounds_seagull_11_ogg___default.a, __WEBPACK_IMPORTED_MODULE_40__sounds_seagull_11_mp3___default.a],\n  volume: 0.05\n});\nvar seagull12 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_41__sounds_seagull_12_ogg___default.a, __WEBPACK_IMPORTED_MODULE_42__sounds_seagull_12_mp3___default.a],\n  volume: 0.1\n});\nvar seagull13 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_43__sounds_seagull_13_ogg___default.a, __WEBPACK_IMPORTED_MODULE_44__sounds_seagull_13_mp3___default.a],\n  volume: 0.15\n});\nvar seagull14 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_45__sounds_seagull_14_ogg___default.a, __WEBPACK_IMPORTED_MODULE_46__sounds_seagull_14_mp3___default.a],\n  volume: 0.7\n});\nvar seagull15 = new Howl({\n  src: [__WEBPACK_IMPORTED_MODULE_47__sounds_seagull_15_ogg___default.a, __WEBPACK_IMPORTED_MODULE_48__sounds_seagull_15_mp3___default.a],\n  volume: 0.35\n});\n\nvar seagulls = [];\n\nseagulls.push(seagull1, seagull2, seagull3, seagull4, seagull5, seagull6, seagull7, seagull8, seagull9, seagull10, seagull11, seagull12, seagull13, seagull14, seagull15);\n\n// Randomises the playback of the seagull sfx, or else stops it altogether when user clicks on link\n// to home screen.\nfunction playOrStopSeagullSFX() {\n  if (map.globalView) {\n\n    /* eslint-disable  no-underscore-dangle, no-inner-declarations */\n    var playRandomlySelectedSeagull = function playRandomlySelectedSeagull() {\n      if (!map.globalView) {\n        var randomlySelectedSeagull = seagulls[randomIndex()];\n        if (randomlySelectedSeagull._src === lastSelectedSeagull) {\n          playRandomlySelectedSeagull();\n        } else {\n          randomlySelectedSeagull.play();\n          lastSelectedSeagull = randomlySelectedSeagull._src;\n          setTimeout(function () {\n            playRandomlySelectedSeagull();\n          }, randomTimeoutDuration());\n        }\n      }\n    };\n    /* eslint-enable  no-underscore-dangle, no-innerdeclarations */\n\n    var randomIndex = function randomIndex() {\n      return Math.floor(Math.random() * 15);\n    };\n    var randomTimeoutDuration = function randomTimeoutDuration() {\n      return Math.floor(Math.random() * 5000 + 1000);\n    };\n\n    var lastSelectedSeagull = null;setTimeout(function () {\n      playRandomlySelectedSeagull();\n    }, 1000);\n  } else if (!map.globalView) {\n    seagulls.forEach(function (seagull) {\n      seagull.stop();\n    });\n  }\n}\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar asap = __webpack_require__(2)\n\nmodule.exports = Promise;\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')\n  if (typeof fn !== 'function') throw new TypeError('not a function')\n  var state = null\n  var value = null\n  var deferreds = []\n  var self = this\n\n  this.then = function(onFulfilled, onRejected) {\n    return new self.constructor(function(resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject))\n    })\n  }\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred)\n      return\n    }\n    asap(function() {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value)\n        return\n      }\n      var ret\n      try {\n        ret = cb(value)\n      }\n      catch (e) {\n        deferred.reject(e)\n        return\n      }\n      deferred.resolve(ret)\n    })\n  }\n\n  function resolve(newValue) {\n    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject)\n          return\n        }\n      }\n      state = true\n      value = newValue\n      finale()\n    } catch (e) { reject(e) }\n  }\n\n  function reject(newValue) {\n    state = false\n    value = newValue\n    finale()\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++)\n      handle(deferreds[i])\n    deferreds = null\n  }\n\n  doResolve(fn, resolve, reject)\n}\n\n\nfunction Handler(onFulfilled, onRejected, resolve, reject){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null\n  this.resolve = resolve\n  this.reject = reject\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, setImmediate) {\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n// linked list of tasks (single, with head node)\nvar head = {task: void 0, next: null};\nvar tail = head;\nvar flushing = false;\nvar requestFlush = void 0;\nvar isNodeJS = false;\n\nfunction flush() {\n    /* jshint loopfunc: true */\n\n    while (head.next) {\n        head = head.next;\n        var task = head.task;\n        head.task = void 0;\n        var domain = head.domain;\n\n        if (domain) {\n            head.domain = void 0;\n            domain.enter();\n        }\n\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function() {\n                   throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    flushing = false;\n}\n\nif (typeof process !== \"undefined\" && process.nextTick) {\n    // Node.js before 0.9. Note that some fake-Node environments, like the\n    // Mocha test runner, introduce a `process` global without a `nextTick`.\n    isNodeJS = true;\n\n    requestFlush = function () {\n        process.nextTick(flush);\n    };\n\n} else if (typeof setImmediate === \"function\") {\n    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        requestFlush = setImmediate.bind(window, flush);\n    } else {\n        requestFlush = function () {\n            setImmediate(flush);\n        };\n    }\n\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    requestFlush = function () {\n        channel.port2.postMessage(0);\n    };\n\n} else {\n    // old browsers\n    requestFlush = function () {\n        setTimeout(flush, 0);\n    };\n}\n\nfunction asap(task) {\n    tail = tail.next = {\n        task: task,\n        domain: isNodeJS && process.domain,\n        next: null\n    };\n\n    if (!flushing) {\n        flushing = true;\n        requestFlush();\n    }\n};\n\nmodule.exports = asap;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), __webpack_require__(84).setImmediate))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar islandModel = [{\n  name: 'Banaba Island',\n  ocean: 'Pacific Ocean',\n  latLngBounds: [{\n    lat: -0.8702863779015437,\n    lng: 169.51314448237304\n  }, {\n    lat: -0.8458702856051626,\n    lng: 169.55708979487304\n  }],\n  markerPosition: {\n    lat: -0.864,\n    lng: 169.5352888\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The Banabans do not bury their\\n    dead. They let the bodies hang from their huts until the flesh has decomposed, then wash the\\n    skeleton in the sea. The head is separated from the body; the bones are stored under the houses\\n    and the skull is kept under the stone of the terraces, on which the young men play with the\\n    frigate birds. They dance around the tame birds and throw objects at them until they cannot\\n    move any longer and their wings are flattened to the ground.\"</p>'\n}, {\n  name: 'Christmas Island',\n  ocean: 'Indian Ocean',\n  latLngBounds: [{\n    lat: -10.57091787279843,\n    lng: 105.48796844482422\n  }, {\n    lat: -10.408877222163513,\n    lng: 105.7454605102539\n  }],\n  markerPosition: {\n    lat: -10.5075,\n    lng: 105.627\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The rainy season lures them\\n    out of their holes. Every November, 120 million crabs reach sexual maturity and make their way\\n    to the sea. A red carpet spreads over the island as they crawl over tarmac and thresholds and\\n    climb over walls and rock faces, thrusting their shells sideways on their two strong pincers\\n    and eight thin legs, heading for the ocean to cast their black spawn into the waves just before\\n    the new moon.\"</p>'\n}, {\n  name: 'St Kilda',\n  ocean: 'Atlantic Ocean',\n  latLngBounds: [{\n    lat: 57.79148847846857,\n    lng: -8.657574316390992\n  }, {\n    lat: 57.83537977470486,\n    lng: -8.528828283676148\n  }],\n  markerPosition: {\n    lat: 57.808,\n    lng: -8.593201300033561\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The island\\'s future is written\\n    in its graveyard. Its children are all born in good health, but most stop feeding during their\\n    fourth, fifth or sixth night. On the seventh day, their palates tighten and their throats\\n    constrict, so it becomes impossible to get them to swallow anything. Their muscles twitch and\\n    their jaws hang loose. Their eyes grow staring and they yawn a great deal; their open mouths\\n    stretch in mocking grimaces. Some die sooner, some later: one dies on the fourth day, another\\n    not till the twenty-first. The islanders whisper that it is the will of the Almighty. But\\n    these are the words of pious men. The women who endure so many pregnancies and bear so few\\n    children remain silent.\"</p>'\n}, {\n  name: 'Brava',\n  ocean: 'Atlantic Ocean',\n  latLngBounds: [{\n    lat: 14.806617348077948,\n    lng: -24.763381958007812\n  }, {\n    lat: 14.89455888825592,\n    lng: -24.653518676757812\n  }],\n  markerPosition: {\n    lat: 14.814,\n    lng: -24.703\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"This clenched heart lies\\n    untameable, protected from the wind by the great volcano of the neighbouring island. Everyone\\n    who lives here is descended from the planters who stayed behind and from their slaves; from\\n    those who chose to move here and those who were forced to. A people with blue eyes and black\\n    skin.\"</p>'\n}, {\n  name: 'Antipodes Island',\n  ocean: 'Pacific Ocean',\n  latLngBounds: [{\n    lat: -49.712995217581586,\n    lng: 178.71195663452147\n  }, {\n    lat: -49.65813069173961,\n    lng: 178.82181991577147\n  }],\n  markerPosition: {\n    lat: -49.708,\n    lng: 178.765\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"This place here is\\n    mountainous, bare of trees and the climate is rough: cold and stormy. The mild air of the Gulf\\n    Stream is missing. Cattle that are brought here die quickly and quietly in the dun-coloured\\n    steppes of grass. And the thunderous echo of waves breaking against the hollows of the jagged\\n    coastline never ceases.\"</p>'\n}, {\n  name: 'Pingelap',\n  ocean: 'Pacific Ocean',\n  latLngBounds: [{\n    lat: 6.201868580927629,\n    lng: 160.68466412000726\n  }, {\n    lat: 6.227551790678075,\n    lng: 160.72019802503655\n  }],\n  markerPosition: {\n    lat: 6.21,\n    lng: 160.7035\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"Even the pigs on this island\\n    are black and white. It is as if they have been made specifically for the seventy-five people\\n    of Pingelap who see no colour: not the fiery crimson of the sunset, not the azure of the ocean,\\n    not the garish yellow of the ripe papaya, nor the ever-present deep green of the dense jungle\\n    of breadfruit palms, coconut palms and mangroves.\"</p>'\n}, {\n  name: 'Deception Island',\n  ocean: 'Antarctic Ocean',\n  latLngBounds: [{\n    lat: -63.01100977025461,\n    lng: -60.80487060546875\n  }, {\n    lat: -62.90314869230779,\n    lng: -60.45330810546875\n  }],\n  markerPosition: {\n    lat: -62.975,\n    lng: -60.55\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The inhabitants call this\\n    place New Sandefjord. It is the the southernmost whale oil processing plant in the world, with\\n    its own fleet: two triple-masted ships, eight small whaling steamers and two large ones. Apart\\n    from a handful of Chilean stokers, two hundred Norwegians live here, along with one woman:\\n    Marie Betsy Rasmussen, the first female ever to be in Antarctica.\"</p>'\n}, {\n  name: 'Easter Island',\n  ocean: 'Pacific Ocean',\n  latLngBounds: [{\n    lat: -27.15752454916794,\n    lng: -109.42561912536621\n  }, {\n    lat: -27.08311708769941,\n    lng: -109.26082420349121\n  }],\n  markerPosition: {\n    lat: -27.13,\n    lng: -109.343\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky:</span>\"Monsters dot the coastline.\\n    Hollow-eyed beings with elongated ears, weather beaten skin and pouting lips like sullen\\n    children. No ones knows now how high the giant palms that once covered the island grew. The sap\\n    that flowed from their trunks was fermented into wine sweet as honey; the wood was made into\\n    rafts and ropes to transport the statues.\"</p>'\n}, {\n  name: 'Amsterdam Island',\n  ocean: 'Indian Ocean',\n  latLngBounds: [{\n    lat: -37.86677966037226,\n    lng: 77.48879623413086\n  }, {\n    lat: -37.80170309418536,\n    lng: 77.6175422668457\n  }],\n  markerPosition: {\n    lat: -37.865,\n    lng: 77.571\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"No\\n    one is allowed to settle here, so the personnel at the research station changes constantly.\\n    Some of the men stay for only a few months, but most for a year and a half, on the island that\\n    they call simply \\'Ams\\' or \\'La Base\\'. None speak English and all greet each other every day with\\n    a handshake. There is no boat. Where would they take it? This place is a stray piece of France,\\n    a cross on a blue nowhere on the various maps of the world that are pinned to the walls,\\n    alongside a couple of pictures of albatrosses and countless pornographic posters.\"</p>'\n}, {\n  name: 'Tristan da Cunha',\n  ocean: 'Atlantic Ocean',\n  latLngBounds: [{\n    lat: -37.148305718626126,\n    lng: -12.376785278320312\n  }, {\n    lat: -37.07876566400408,\n    lng: -12.201004028320312\n  }],\n  markerPosition: {\n    lat: -37.161,\n    lng: -12.285\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The law of this snow dome land\\n    is simple and bold. Everyone is equal, everything is shared, and a marvelous patriarch oversees\\n    everything. Their happiness is manifested in monogamous marriage. Nine families exchange food;\\n    fruit and vines grow in the wild. Whoever runs aground here and wishes to stay must tell the\\n    story of his life as if it were the story of a stranger. Those who have failed in the\\n    larger-world are always best suited to life in utopia. A new beginning, a fundamentally better\\n    life, another \\'I\\' is possible.\"</p>'\n}, {\n  name: 'Pukapuka',\n  ocean: 'Pacific Ocean',\n  latLngBounds: [{\n    lat: -10.902952188780274,\n    lng: -165.8814097156494\n  }, {\n    lat: -10.862494390076495,\n    lng: -165.81703669929198\n  }],\n  markerPosition: {\n    lat: -10.8575,\n    lng: -165.8435\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"On Pukapuka, no one cares if a\\n    bride is a virgin. A word for \\'virgin\\' does not even exist in their language. A woman who has a\\n    child out of wedlock earns respect and increases her chances of marriage because she has proved\\n    her fertility. The young people of the three villages meet at the far edge of the beach once\\n    darkness falls. There they fight, dance, sing and sleep with each other. It is common for more\\n    than two people to get together. Sex is a game, and jealousy has no place.\"</p>'\n}, {\n  name: 'Ascension Island',\n  ocean: 'Atlantic Ocean',\n  latLngBounds: [{\n    lat: -7.989998597281406,\n    lng: -14.453201293945312\n  }, {\n    lat: -7.893260056660305,\n    lng: -14.277420043945312\n  }],\n  markerPosition: {\n    lat: -7.975,\n    lng: -14.3620632\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"It is a working island for\\n    telecommunications operators and spies, and a landing site for the cables that run along the\\n    floor of the Atlantic Ocean to connect the continents. NASA stretches out its feelers here,\\n    building a tracking facility for intercontinental missiles and scattering glistening white\\n    parabolic antennae all over the land. They are eavesdropping on the continents, listening to\\n    the world, to the universe, to the infinity of outer space.\"</p>'\n}, {\n  name: 'Peter I Island',\n  ocean: 'Antarctic Ocean',\n  latLngBounds: [{\n    lat: -68.89314425766871,\n    lng: -90.86018371582031\n  }, {\n    lat: -68.7196278699082,\n    lng: -90.33283996582031\n  }],\n  markerPosition: {\n    lat: -68.825,\n    lng: -90.54\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The island does not have a\\n    single sheltering bay, let alone a harbour; only a couple of narrow beaches of black rock and\\n    glaciers that stretch their tongues into the ocean. It is impossible to reach. There is nothing\\n    more to say about a land that no one has set foot on.\"</p>'\n}, {\n  name: 'Rudolph Island',\n  ocean: 'Arctic Ocean',\n  latLngBounds: [{\n    lat: 81.66662935417675,\n    lng: 58.090328216552734\n  }, {\n    lat: 81.86798544884091,\n    lng: 59.120296478271484\n  }],\n  markerPosition: {\n    lat: 81.76791878109108,\n    lng: 58.60531234741211\n  },\n  bookExcerpt: '<p class=\"textbox__text--book-excerpt\">\\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The landscape is barren, bare\\n    and white. Like the map.\"</p>'\n}]; // End of islandModel.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (islandModel);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Knockout JavaScript library v3.4.2\n * (c) The Knockout.js team - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function(){\nvar DEBUG=true;\n(function(undefined){\n    // (0, eval)('this') is a robust way of getting a reference to the global object\n    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023\n    var window = this || (0, eval)('this'),\n        document = window['document'],\n        navigator = window['navigator'],\n        jQueryInstance = window[\"jQuery\"],\n        JSON = window[\"JSON\"];\n(function(factory) {\n    // Support three module loading scenarios\n    if (true) {\n        // [1] AMD anonymous module\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object' && typeof module === 'object') {\n        // [2] CommonJS/Node.js\n        factory(module['exports'] || exports);  // module.exports is for Node.js\n    } else {\n        // [3] No module loader (plain <script> tag) - put directly in global namespace\n        factory(window['ko'] = {});\n    }\n}(function(koExports, amdRequire){\n// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).\n// In the future, the following \"ko\" variable may be made distinct from \"koExports\" so that private objects are not externally reachable.\nvar ko = typeof koExports !== 'undefined' ? koExports : {};\n// Google Closure Compiler helpers (used only to make the minified file smaller)\nko.exportSymbol = function(koPath, object) {\n    var tokens = koPath.split(\".\");\n\n    // In the future, \"ko\" may become distinct from \"koExports\" (so that non-exported objects are not reachable)\n    // At that point, \"target\" would be set to: (typeof koExports !== \"undefined\" ? koExports : ko)\n    var target = ko;\n\n    for (var i = 0; i < tokens.length - 1; i++)\n        target = target[tokens[i]];\n    target[tokens[tokens.length - 1]] = object;\n};\nko.exportProperty = function(owner, publicName, object) {\n    owner[publicName] = object;\n};\nko.version = \"3.4.2\";\n\nko.exportSymbol('version', ko.version);\n// For any options that may affect various areas of Knockout and aren't directly associated with data binding.\nko.options = {\n    'deferUpdates': false,\n    'useOnlyNativeEvents': false\n};\n\n//ko.exportSymbol('options', ko.options);   // 'options' isn't minified\nko.utils = (function () {\n    function objectForEach(obj, action) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                action(prop, obj[prop]);\n            }\n        }\n    }\n\n    function extend(target, source) {\n        if (source) {\n            for(var prop in source) {\n                if(source.hasOwnProperty(prop)) {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n        return target;\n    }\n\n    function setPrototypeOf(obj, proto) {\n        obj.__proto__ = proto;\n        return obj;\n    }\n\n    var canSetPrototype = ({ __proto__: [] } instanceof Array);\n    var canUseSymbols = !DEBUG && typeof Symbol === 'function';\n\n    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)\n    var knownEvents = {}, knownEventTypesByEventName = {};\n    var keyEventTypeName = (navigator && /Firefox\\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';\n    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];\n    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];\n    objectForEach(knownEvents, function(eventType, knownEventsForType) {\n        if (knownEventsForType.length) {\n            for (var i = 0, j = knownEventsForType.length; i < j; i++)\n                knownEventTypesByEventName[knownEventsForType[i]] = eventType;\n        }\n    });\n    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406\n\n    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)\n    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.\n    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.\n    // If there is a future need to detect specific versions of IE10+, we will amend this.\n    var ieVersion = document && (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n            iElems[0]\n        ) {}\n        return version > 4 ? version : undefined;\n    }());\n    var isIe6 = ieVersion === 6,\n        isIe7 = ieVersion === 7;\n\n    function isClickOnCheckableElement(element, eventType) {\n        if ((ko.utils.tagNameLower(element) !== \"input\") || !element.type) return false;\n        if (eventType.toLowerCase() != \"click\") return false;\n        var inputType = element.type;\n        return (inputType == \"checkbox\") || (inputType == \"radio\");\n    }\n\n    // For details on the pattern for changing node classes\n    // see: https://github.com/knockout/knockout/issues/1597\n    var cssClassNameRegex = /\\S+/g;\n\n    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {\n        var addOrRemoveFn;\n        if (classNames) {\n            if (typeof node.classList === 'object') {\n                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];\n                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n                    addOrRemoveFn.call(node.classList, className);\n                });\n            } else if (typeof node.className['baseVal'] === 'string') {\n                // SVG tag .classNames is an SVGAnimatedString instance\n                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);\n            } else {\n                // node.className ought to be a string.\n                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);\n            }\n        }\n    }\n\n    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {\n        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.\n        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];\n        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);\n        });\n        obj[prop] = currentClassNames.join(\" \");\n    }\n\n    return {\n        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],\n\n        arrayForEach: function (array, action) {\n            for (var i = 0, j = array.length; i < j; i++)\n                action(array[i], i);\n        },\n\n        arrayIndexOf: function (array, item) {\n            if (typeof Array.prototype.indexOf == \"function\")\n                return Array.prototype.indexOf.call(array, item);\n            for (var i = 0, j = array.length; i < j; i++)\n                if (array[i] === item)\n                    return i;\n            return -1;\n        },\n\n        arrayFirst: function (array, predicate, predicateOwner) {\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate.call(predicateOwner, array[i], i))\n                    return array[i];\n            return null;\n        },\n\n        arrayRemoveItem: function (array, itemToRemove) {\n            var index = ko.utils.arrayIndexOf(array, itemToRemove);\n            if (index > 0) {\n                array.splice(index, 1);\n            }\n            else if (index === 0) {\n                array.shift();\n            }\n        },\n\n        arrayGetDistinctValues: function (array) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++) {\n                if (ko.utils.arrayIndexOf(result, array[i]) < 0)\n                    result.push(array[i]);\n            }\n            return result;\n        },\n\n        arrayMap: function (array, mapping) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                result.push(mapping(array[i], i));\n            return result;\n        },\n\n        arrayFilter: function (array, predicate) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate(array[i], i))\n                    result.push(array[i]);\n            return result;\n        },\n\n        arrayPushAll: function (array, valuesToPush) {\n            if (valuesToPush instanceof Array)\n                array.push.apply(array, valuesToPush);\n            else\n                for (var i = 0, j = valuesToPush.length; i < j; i++)\n                    array.push(valuesToPush[i]);\n            return array;\n        },\n\n        addOrRemoveItem: function(array, value, included) {\n            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);\n            if (existingEntryIndex < 0) {\n                if (included)\n                    array.push(value);\n            } else {\n                if (!included)\n                    array.splice(existingEntryIndex, 1);\n            }\n        },\n\n        canSetPrototype: canSetPrototype,\n\n        extend: extend,\n\n        setPrototypeOf: setPrototypeOf,\n\n        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,\n\n        objectForEach: objectForEach,\n\n        objectMap: function(source, mapping) {\n            if (!source)\n                return source;\n            var target = {};\n            for (var prop in source) {\n                if (source.hasOwnProperty(prop)) {\n                    target[prop] = mapping(source[prop], prop, source);\n                }\n            }\n            return target;\n        },\n\n        emptyDomNode: function (domNode) {\n            while (domNode.firstChild) {\n                ko.removeNode(domNode.firstChild);\n            }\n        },\n\n        moveCleanedNodesToContainerElement: function(nodes) {\n            // Ensure it's a real array, as we're about to reparent the nodes and\n            // we don't want the underlying collection to change while we're doing that.\n            var nodesArray = ko.utils.makeArray(nodes);\n            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;\n\n            var container = templateDocument.createElement('div');\n            for (var i = 0, j = nodesArray.length; i < j; i++) {\n                container.appendChild(ko.cleanNode(nodesArray[i]));\n            }\n            return container;\n        },\n\n        cloneNodes: function (nodesArray, shouldCleanNodes) {\n            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {\n                var clonedNode = nodesArray[i].cloneNode(true);\n                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);\n            }\n            return newNodesArray;\n        },\n\n        setDomNodeChildren: function (domNode, childNodes) {\n            ko.utils.emptyDomNode(domNode);\n            if (childNodes) {\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    domNode.appendChild(childNodes[i]);\n            }\n        },\n\n        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {\n            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;\n            if (nodesToReplaceArray.length > 0) {\n                var insertionPoint = nodesToReplaceArray[0];\n                var parent = insertionPoint.parentNode;\n                for (var i = 0, j = newNodesArray.length; i < j; i++)\n                    parent.insertBefore(newNodesArray[i], insertionPoint);\n                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {\n                    ko.removeNode(nodesToReplaceArray[i]);\n                }\n            }\n        },\n\n        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {\n            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile\n            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that\n            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been\n            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.\n            // So, this function translates the old \"map\" output array into its best guess of the set of current DOM nodes.\n            //\n            // Rules:\n            //   [A] Any leading nodes that have been removed should be ignored\n            //       These most likely correspond to memoization nodes that were already removed during binding\n            //       See https://github.com/knockout/knockout/pull/440\n            //   [B] Any trailing nodes that have been remove should be ignored\n            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]\n            //       See https://github.com/knockout/knockout/pull/1903\n            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,\n            //       and include any nodes that have been inserted among the previous collection\n\n            if (continuousNodeArray.length) {\n                // The parent node can be a virtual element; so get the real parent node\n                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;\n\n                // Rule [A]\n                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)\n                    continuousNodeArray.splice(0, 1);\n\n                // Rule [B]\n                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)\n                    continuousNodeArray.length--;\n\n                // Rule [C]\n                if (continuousNodeArray.length > 1) {\n                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];\n                    // Replace with the actual new continuous node set\n                    continuousNodeArray.length = 0;\n                    while (current !== last) {\n                        continuousNodeArray.push(current);\n                        current = current.nextSibling;\n                    }\n                    continuousNodeArray.push(last);\n                }\n            }\n            return continuousNodeArray;\n        },\n\n        setOptionNodeSelectionState: function (optionNode, isSelected) {\n            // IE6 sometimes throws \"unknown error\" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.\n            if (ieVersion < 7)\n                optionNode.setAttribute(\"selected\", isSelected);\n            else\n                optionNode.selected = isSelected;\n        },\n\n        stringTrim: function (string) {\n            return string === null || string === undefined ? '' :\n                string.trim ?\n                    string.trim() :\n                    string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n        },\n\n        stringStartsWith: function (string, startsWith) {\n            string = string || \"\";\n            if (startsWith.length > string.length)\n                return false;\n            return string.substring(0, startsWith.length) === startsWith;\n        },\n\n        domNodeIsContainedBy: function (node, containedByNode) {\n            if (node === containedByNode)\n                return true;\n            if (node.nodeType === 11)\n                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8\n            if (containedByNode.contains)\n                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);\n            if (containedByNode.compareDocumentPosition)\n                return (containedByNode.compareDocumentPosition(node) & 16) == 16;\n            while (node && node != containedByNode) {\n                node = node.parentNode;\n            }\n            return !!node;\n        },\n\n        domNodeIsAttachedToDocument: function (node) {\n            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);\n        },\n\n        anyDomNodeIsAttachedToDocument: function(nodes) {\n            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);\n        },\n\n        tagNameLower: function(element) {\n            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.\n            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),\n            // we don't need to do the .toLowerCase() as it will always be lower case anyway.\n            return element && element.tagName && element.tagName.toLowerCase();\n        },\n\n        catchFunctionErrors: function (delegate) {\n            return ko['onError'] ? function () {\n                try {\n                    return delegate.apply(this, arguments);\n                } catch (e) {\n                    ko['onError'] && ko['onError'](e);\n                    throw e;\n                }\n            } : delegate;\n        },\n\n        setTimeout: function (handler, timeout) {\n            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);\n        },\n\n        deferError: function (error) {\n            setTimeout(function () {\n                ko['onError'] && ko['onError'](error);\n                throw error;\n            }, 0);\n        },\n\n        registerEventHandler: function (element, eventType, handler) {\n            var wrappedHandler = ko.utils.catchFunctionErrors(handler);\n\n            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];\n            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {\n                jQueryInstance(element)['bind'](eventType, wrappedHandler);\n            } else if (!mustUseAttachEvent && typeof element.addEventListener == \"function\")\n                element.addEventListener(eventType, wrappedHandler, false);\n            else if (typeof element.attachEvent != \"undefined\") {\n                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },\n                    attachEventName = \"on\" + eventType;\n                element.attachEvent(attachEventName, attachEventHandler);\n\n                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)\n                // so to avoid leaks, we have to remove them manually. See bug #856\n                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n                    element.detachEvent(attachEventName, attachEventHandler);\n                });\n            } else\n                throw new Error(\"Browser doesn't support addEventListener or attachEvent\");\n        },\n\n        triggerEvent: function (element, eventType) {\n            if (!(element && element.nodeType))\n                throw new Error(\"element must be a DOM node when calling triggerEvent\");\n\n            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the\n            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)\n            // IE doesn't change the checked state when you trigger the click event using \"fireEvent\".\n            // In both cases, we'll use the click method instead.\n            var useClickWorkaround = isClickOnCheckableElement(element, eventType);\n\n            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {\n                jQueryInstance(element)['trigger'](eventType);\n            } else if (typeof document.createEvent == \"function\") {\n                if (typeof element.dispatchEvent == \"function\") {\n                    var eventCategory = knownEventTypesByEventName[eventType] || \"HTMLEvents\";\n                    var event = document.createEvent(eventCategory);\n                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);\n                    element.dispatchEvent(event);\n                }\n                else\n                    throw new Error(\"The supplied element doesn't support dispatchEvent\");\n            } else if (useClickWorkaround && element.click) {\n                element.click();\n            } else if (typeof element.fireEvent != \"undefined\") {\n                element.fireEvent(\"on\" + eventType);\n            } else {\n                throw new Error(\"Browser doesn't support triggering events\");\n            }\n        },\n\n        unwrapObservable: function (value) {\n            return ko.isObservable(value) ? value() : value;\n        },\n\n        peekObservable: function (value) {\n            return ko.isObservable(value) ? value.peek() : value;\n        },\n\n        toggleDomNodeCssClass: toggleDomNodeCssClass,\n\n        setTextContent: function(element, textContent) {\n            var value = ko.utils.unwrapObservable(textContent);\n            if ((value === null) || (value === undefined))\n                value = \"\";\n\n            // We need there to be exactly one child: a text node.\n            // If there are no children, more than one, or if it's not a text node,\n            // we'll clear everything and create a single text node.\n            var innerTextNode = ko.virtualElements.firstChild(element);\n            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {\n                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);\n            } else {\n                innerTextNode.data = value;\n            }\n\n            ko.utils.forceRefresh(element);\n        },\n\n        setElementName: function(element, name) {\n            element.name = name;\n\n            // Workaround IE 6/7 issue\n            // - https://github.com/SteveSanderson/knockout/issues/197\n            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/\n            if (ieVersion <= 7) {\n                try {\n                    element.mergeAttributes(document.createElement(\"<input name='\" + element.name + \"'/>\"), false);\n                }\n                catch(e) {} // For IE9 with doc mode \"IE9 Standards\" and browser mode \"IE9 Compatibility View\"\n            }\n        },\n\n        forceRefresh: function(node) {\n            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209\n            if (ieVersion >= 9) {\n                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container\n                var elem = node.nodeType == 1 ? node : node.parentNode;\n                if (elem.style)\n                    elem.style.zoom = elem.style.zoom;\n            }\n        },\n\n        ensureSelectElementIsRenderedCorrectly: function(selectElement) {\n            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.\n            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)\n            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)\n            if (ieVersion) {\n                var originalWidth = selectElement.style.width;\n                selectElement.style.width = 0;\n                selectElement.style.width = originalWidth;\n            }\n        },\n\n        range: function (min, max) {\n            min = ko.utils.unwrapObservable(min);\n            max = ko.utils.unwrapObservable(max);\n            var result = [];\n            for (var i = min; i <= max; i++)\n                result.push(i);\n            return result;\n        },\n\n        makeArray: function(arrayLikeObject) {\n            var result = [];\n            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n                result.push(arrayLikeObject[i]);\n            };\n            return result;\n        },\n\n        createSymbolOrString: function(identifier) {\n            return canUseSymbols ? Symbol(identifier) : identifier;\n        },\n\n        isIe6 : isIe6,\n        isIe7 : isIe7,\n        ieVersion : ieVersion,\n\n        getFormFields: function(form, fieldName) {\n            var fields = ko.utils.makeArray(form.getElementsByTagName(\"input\")).concat(ko.utils.makeArray(form.getElementsByTagName(\"textarea\")));\n            var isMatchingField = (typeof fieldName == 'string')\n                ? function(field) { return field.name === fieldName }\n                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate\n            var matches = [];\n            for (var i = fields.length - 1; i >= 0; i--) {\n                if (isMatchingField(fields[i]))\n                    matches.push(fields[i]);\n            };\n            return matches;\n        },\n\n        parseJson: function (jsonString) {\n            if (typeof jsonString == \"string\") {\n                jsonString = ko.utils.stringTrim(jsonString);\n                if (jsonString) {\n                    if (JSON && JSON.parse) // Use native parsing where available\n                        return JSON.parse(jsonString);\n                    return (new Function(\"return \" + jsonString))(); // Fallback on less safe parsing for older browsers\n                }\n            }\n            return null;\n        },\n\n        stringifyJson: function (data, replacer, space) {   // replacer and space are optional\n            if (!JSON || !JSON.stringify)\n                throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);\n        },\n\n        postJson: function (urlOrForm, data, options) {\n            options = options || {};\n            var params = options['params'] || {};\n            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;\n            var url = urlOrForm;\n\n            // If we were given a form, use its 'action' URL and pick out any requested field values\n            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === \"form\")) {\n                var originalForm = urlOrForm;\n                url = originalForm.action;\n                for (var i = includeFields.length - 1; i >= 0; i--) {\n                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);\n                    for (var j = fields.length - 1; j >= 0; j--)\n                        params[fields[j].name] = fields[j].value;\n                }\n            }\n\n            data = ko.utils.unwrapObservable(data);\n            var form = document.createElement(\"form\");\n            form.style.display = \"none\";\n            form.action = url;\n            form.method = \"post\";\n            for (var key in data) {\n                // Since 'data' this is a model object, we include all properties including those inherited from its prototype\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));\n                form.appendChild(input);\n            }\n            objectForEach(params, function(key, value) {\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = value;\n                form.appendChild(input);\n            });\n            document.body.appendChild(form);\n            options['submitter'] ? options['submitter'](form) : form.submit();\n            setTimeout(function () { form.parentNode.removeChild(form); }, 0);\n        }\n    }\n}());\n\nko.exportSymbol('utils', ko.utils);\nko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);\nko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);\nko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);\nko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);\nko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);\nko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);\nko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);\nko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);\nko.exportSymbol('utils.extend', ko.utils.extend);\nko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);\nko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);\nko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);\nko.exportSymbol('utils.postJson', ko.utils.postJson);\nko.exportSymbol('utils.parseJson', ko.utils.parseJson);\nko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);\nko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);\nko.exportSymbol('utils.range', ko.utils.range);\nko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);\nko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);\nko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);\nko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);\nko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);\nko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);\nko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly\n\nif (!Function.prototype['bind']) {\n    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js\n    Function.prototype['bind'] = function (object) {\n        var originalFunction = this;\n        if (arguments.length === 1) {\n            return function () {\n                return originalFunction.apply(object, arguments);\n            };\n        } else {\n            var partialArgs = Array.prototype.slice.call(arguments, 1);\n            return function () {\n                var args = partialArgs.slice(0);\n                args.push.apply(args, arguments);\n                return originalFunction.apply(object, args);\n            };\n        }\n    };\n}\n\nko.utils.domData = new (function () {\n    var uniqueId = 0;\n    var dataStoreKeyExpandoPropertyName = \"__ko__\" + (new Date).getTime();\n    var dataStore = {};\n\n    function getAll(node, createIfNotFound) {\n        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== \"null\") && dataStore[dataStoreKey];\n        if (!hasExistingDataStore) {\n            if (!createIfNotFound)\n                return undefined;\n            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = \"ko\" + uniqueId++;\n            dataStore[dataStoreKey] = {};\n        }\n        return dataStore[dataStoreKey];\n    }\n\n    return {\n        get: function (node, key) {\n            var allDataForNode = getAll(node, false);\n            return allDataForNode === undefined ? undefined : allDataForNode[key];\n        },\n        set: function (node, key, value) {\n            if (value === undefined) {\n                // Make sure we don't actually create a new domData key if we are actually deleting a value\n                if (getAll(node, false) === undefined)\n                    return;\n            }\n            var allDataForNode = getAll(node, true);\n            allDataForNode[key] = value;\n        },\n        clear: function (node) {\n            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n            if (dataStoreKey) {\n                delete dataStore[dataStoreKey];\n                node[dataStoreKeyExpandoPropertyName] = null;\n                return true; // Exposing \"did clean\" flag purely so specs can infer whether things have been cleaned up as intended\n            }\n            return false;\n        },\n\n        nextKey: function () {\n            return (uniqueId++) + dataStoreKeyExpandoPropertyName;\n        }\n    };\n})();\n\nko.exportSymbol('utils.domData', ko.utils.domData);\nko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully\n\nko.utils.domNodeDisposal = new (function () {\n    var domDataKey = ko.utils.domData.nextKey();\n    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document\n    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document\n\n    function getDisposeCallbacksCollection(node, createIfNotFound) {\n        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);\n        if ((allDisposeCallbacks === undefined) && createIfNotFound) {\n            allDisposeCallbacks = [];\n            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);\n        }\n        return allDisposeCallbacks;\n    }\n    function destroyCallbacksCollection(node) {\n        ko.utils.domData.set(node, domDataKey, undefined);\n    }\n\n    function cleanSingleNode(node) {\n        // Run all the dispose callbacks\n        var callbacks = getDisposeCallbacksCollection(node, false);\n        if (callbacks) {\n            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)\n            for (var i = 0; i < callbacks.length; i++)\n                callbacks[i](node);\n        }\n\n        // Erase the DOM data\n        ko.utils.domData.clear(node);\n\n        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)\n        ko.utils.domNodeDisposal[\"cleanExternalData\"](node);\n\n        // Clear any immediate-child comment nodes, as these wouldn't have been found by\n        // node.getElementsByTagName(\"*\") in cleanNode() (comment nodes aren't elements)\n        if (cleanableNodeTypesWithDescendants[node.nodeType])\n            cleanImmediateCommentTypeChildren(node);\n    }\n\n    function cleanImmediateCommentTypeChildren(nodeWithChildren) {\n        var child, nextChild = nodeWithChildren.firstChild;\n        while (child = nextChild) {\n            nextChild = child.nextSibling;\n            if (child.nodeType === 8)\n                cleanSingleNode(child);\n        }\n    }\n\n    return {\n        addDisposeCallback : function(node, callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"Callback must be a function\");\n            getDisposeCallbacksCollection(node, true).push(callback);\n        },\n\n        removeDisposeCallback : function(node, callback) {\n            var callbacksCollection = getDisposeCallbacksCollection(node, false);\n            if (callbacksCollection) {\n                ko.utils.arrayRemoveItem(callbacksCollection, callback);\n                if (callbacksCollection.length == 0)\n                    destroyCallbacksCollection(node);\n            }\n        },\n\n        cleanNode : function(node) {\n            // First clean this node, where applicable\n            if (cleanableNodeTypes[node.nodeType]) {\n                cleanSingleNode(node);\n\n                // ... then its descendants, where applicable\n                if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n                    // Clone the descendants list in case it changes during iteration\n                    var descendants = [];\n                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName(\"*\"));\n                    for (var i = 0, j = descendants.length; i < j; i++)\n                        cleanSingleNode(descendants[i]);\n                }\n            }\n            return node;\n        },\n\n        removeNode : function(node) {\n            ko.cleanNode(node);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        },\n\n        \"cleanExternalData\" : function (node) {\n            // Special support for jQuery here because it's so commonly used.\n            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData\n            // so notify it to tear down any resources associated with the node & descendants here.\n            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == \"function\"))\n                jQueryInstance['cleanData']([node]);\n        }\n    };\n})();\nko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience\nko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience\nko.exportSymbol('cleanNode', ko.cleanNode);\nko.exportSymbol('removeNode', ko.removeNode);\nko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);\nko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);\nko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);\n(function () {\n    var none = [0, \"\", \"\"],\n        table = [1, \"<table>\", \"</table>\"],\n        tbody = [2, \"<table><tbody>\", \"</tbody></table>\"],\n        tr = [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        select = [1, \"<select multiple='multiple'>\", \"</select>\"],\n        lookup = {\n            'thead': table,\n            'tbody': table,\n            'tfoot': table,\n            'tr': tbody,\n            'td': tr,\n            'th': tr,\n            'option': select,\n            'optgroup': select\n        },\n\n        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.\n        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;\n\n    function getWrap(tags) {\n        var m = tags.match(/^<([a-z]+)[ >]/);\n        return (m && lookup[m[1]]) || none;\n    }\n\n    function simpleHtmlParse(html, documentContext) {\n        documentContext || (documentContext = document);\n        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;\n\n        // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n        // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n        // Trim whitespace, otherwise indexOf won't work as expected\n        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement(\"div\"),\n            wrap = getWrap(tags),\n            depth = wrap[0];\n\n        // Go to html and back, then peel off extra wrappers\n        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n        var markup = \"ignored<div>\" + wrap[1] + html + wrap[2] + \"</div>\";\n        if (typeof windowContext['innerShiv'] == \"function\") {\n            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding\n            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv\n            // somehow shims the native APIs so it just works anyway)\n            div.appendChild(windowContext['innerShiv'](markup));\n        } else {\n            if (mayRequireCreateElementHack) {\n                // The document.createElement('my-element') trick to enable custom elements in IE6-8\n                // only works if we assign innerHTML on an element associated with that document.\n                documentContext.appendChild(div);\n            }\n\n            div.innerHTML = markup;\n\n            if (mayRequireCreateElementHack) {\n                div.parentNode.removeChild(div);\n            }\n        }\n\n        // Move to the right depth\n        while (depth--)\n            div = div.lastChild;\n\n        return ko.utils.makeArray(div.lastChild.childNodes);\n    }\n\n    function jQueryHtmlParse(html, documentContext) {\n        // jQuery's \"parseHTML\" function was introduced in jQuery 1.8.0 and is a documented public API.\n        if (jQueryInstance['parseHTML']) {\n            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null\n        } else {\n            // For jQuery < 1.8.0, we fall back on the undocumented internal \"clean\" function.\n            var elems = jQueryInstance['clean']([html], documentContext);\n\n            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n            if (elems && elems[0]) {\n                // Find the top-most parent element that's a direct child of a document fragment\n                var elem = elems[0];\n                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)\n                    elem = elem.parentNode;\n                // ... then detach it\n                if (elem.parentNode)\n                    elem.parentNode.removeChild(elem);\n            }\n\n            return elems;\n        }\n    }\n\n    ko.utils.parseHtmlFragment = function(html, documentContext) {\n        return jQueryInstance ?\n            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible\n            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.\n    };\n\n    ko.utils.setHtml = function(node, html) {\n        ko.utils.emptyDomNode(node);\n\n        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it\n        html = ko.utils.unwrapObservable(html);\n\n        if ((html !== null) && (html !== undefined)) {\n            if (typeof html != 'string')\n                html = html.toString();\n\n            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n            // for example <tr> elements which are not normally allowed to exist on their own.\n            // If you've referenced jQuery we'll use that rather than duplicating its code.\n            if (jQueryInstance) {\n                jQueryInstance(node)['html'](html);\n            } else {\n                // ... otherwise, use KO's own parsing logic.\n                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);\n                for (var i = 0; i < parsedNodes.length; i++)\n                    node.appendChild(parsedNodes[i]);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);\nko.exportSymbol('utils.setHtml', ko.utils.setHtml);\n\nko.memoization = (function () {\n    var memos = {};\n\n    function randomMax8HexChars() {\n        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);\n    }\n    function generateRandomId() {\n        return randomMax8HexChars() + randomMax8HexChars();\n    }\n    function findMemoNodes(rootNode, appendToArray) {\n        if (!rootNode)\n            return;\n        if (rootNode.nodeType == 8) {\n            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);\n            if (memoId != null)\n                appendToArray.push({ domNode: rootNode, memoId: memoId });\n        } else if (rootNode.nodeType == 1) {\n            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)\n                findMemoNodes(childNodes[i], appendToArray);\n        }\n    }\n\n    return {\n        memoize: function (callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"You can only pass a function to ko.memoization.memoize()\");\n            var memoId = generateRandomId();\n            memos[memoId] = callback;\n            return \"<!--[ko_memo:\" + memoId + \"]-->\";\n        },\n\n        unmemoize: function (memoId, callbackParams) {\n            var callback = memos[memoId];\n            if (callback === undefined)\n                throw new Error(\"Couldn't find any memo with ID \" + memoId + \". Perhaps it's already been unmemoized.\");\n            try {\n                callback.apply(null, callbackParams || []);\n                return true;\n            }\n            finally { delete memos[memoId]; }\n        },\n\n        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {\n            var memos = [];\n            findMemoNodes(domNode, memos);\n            for (var i = 0, j = memos.length; i < j; i++) {\n                var node = memos[i].domNode;\n                var combinedParams = [node];\n                if (extraCallbackParamsArray)\n                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);\n                ko.memoization.unmemoize(memos[i].memoId, combinedParams);\n                node.nodeValue = \"\"; // Neuter this node so we don't try to unmemoize it again\n                if (node.parentNode)\n                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)\n            }\n        },\n\n        parseMemoText: function (memoText) {\n            var match = memoText.match(/^\\[ko_memo\\:(.*?)\\]$/);\n            return match ? match[1] : null;\n        }\n    };\n})();\n\nko.exportSymbol('memoization', ko.memoization);\nko.exportSymbol('memoization.memoize', ko.memoization.memoize);\nko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);\nko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);\nko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);\nko.tasks = (function () {\n    var scheduler,\n        taskQueue = [],\n        taskQueueLength = 0,\n        nextHandle = 1,\n        nextIndexToProcess = 0;\n\n    if (window['MutationObserver']) {\n        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+\n        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n        scheduler = (function (callback) {\n            var div = document.createElement(\"div\");\n            new MutationObserver(callback).observe(div, {attributes: true});\n            return function () { div.classList.toggle(\"foo\"); };\n        })(scheduledProcess);\n    } else if (document && \"onreadystatechange\" in document.createElement(\"script\")) {\n        // IE 6-10\n        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n        scheduler = function (callback) {\n            var script = document.createElement(\"script\");\n            script.onreadystatechange = function () {\n                script.onreadystatechange = null;\n                document.documentElement.removeChild(script);\n                script = null;\n                callback();\n            };\n            document.documentElement.appendChild(script);\n        };\n    } else {\n        scheduler = function (callback) {\n            setTimeout(callback, 0);\n        };\n    }\n\n    function processTasks() {\n        if (taskQueueLength) {\n            // Each mark represents the end of a logical group of tasks and the number of these groups is\n            // limited to prevent unchecked recursion.\n            var mark = taskQueueLength, countMarks = 0;\n\n            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n            for (var task; nextIndexToProcess < taskQueueLength; ) {\n                if (task = taskQueue[nextIndexToProcess++]) {\n                    if (nextIndexToProcess > mark) {\n                        if (++countMarks >= 5000) {\n                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion\n                            ko.utils.deferError(Error(\"'Too much recursion' after processing \" + countMarks + \" task groups.\"));\n                            break;\n                        }\n                        mark = taskQueueLength;\n                    }\n                    try {\n                        task();\n                    } catch (ex) {\n                        ko.utils.deferError(ex);\n                    }\n                }\n            }\n        }\n    }\n\n    function scheduledProcess() {\n        processTasks();\n\n        // Reset the queue\n        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    }\n\n    function scheduleTaskProcessing() {\n        ko.tasks['scheduler'](scheduledProcess);\n    }\n\n    var tasks = {\n        'scheduler': scheduler,     // Allow overriding the scheduler\n\n        schedule: function (func) {\n            if (!taskQueueLength) {\n                scheduleTaskProcessing();\n            }\n\n            taskQueue[taskQueueLength++] = func;\n            return nextHandle++;\n        },\n\n        cancel: function (handle) {\n            var index = handle - (nextHandle - taskQueueLength);\n            if (index >= nextIndexToProcess && index < taskQueueLength) {\n                taskQueue[index] = null;\n            }\n        },\n\n        // For testing only: reset the queue and return the previous queue length\n        'resetForTesting': function () {\n            var length = taskQueueLength - nextIndexToProcess;\n            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n            return length;\n        },\n\n        runEarly: processTasks\n    };\n\n    return tasks;\n})();\n\nko.exportSymbol('tasks', ko.tasks);\nko.exportSymbol('tasks.schedule', ko.tasks.schedule);\n//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  \"cancel\" isn't minified\nko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);\nko.extenders = {\n    'throttle': function(target, timeout) {\n        // Throttling means two things:\n\n        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n        target['throttleEvaluation'] = timeout;\n\n        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n        //     so the target cannot change value synchronously or faster than a certain rate\n        var writeTimeoutInstance = null;\n        return ko.dependentObservable({\n            'read': target,\n            'write': function(value) {\n                clearTimeout(writeTimeoutInstance);\n                writeTimeoutInstance = ko.utils.setTimeout(function() {\n                    target(value);\n                }, timeout);\n            }\n        });\n    },\n\n    'rateLimit': function(target, options) {\n        var timeout, method, limitFunction;\n\n        if (typeof options == 'number') {\n            timeout = options;\n        } else {\n            timeout = options['timeout'];\n            method = options['method'];\n        }\n\n        // rateLimit supersedes deferred updates\n        target._deferUpdates = false;\n\n        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;\n        target.limit(function(callback) {\n            return limitFunction(callback, timeout);\n        });\n    },\n\n    'deferred': function(target, options) {\n        if (options !== true) {\n            throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.')\n        }\n\n        if (!target._deferUpdates) {\n            target._deferUpdates = true;\n            target.limit(function (callback) {\n                var handle,\n                    ignoreUpdates = false;\n                return function () {\n                    if (!ignoreUpdates) {\n                        ko.tasks.cancel(handle);\n                        handle = ko.tasks.schedule(callback);\n\n                        try {\n                            ignoreUpdates = true;\n                            target['notifySubscribers'](undefined, 'dirty');\n                        } finally {\n                            ignoreUpdates = false;\n                        }\n                    }\n                };\n            });\n        }\n    },\n\n    'notify': function(target, notifyWhen) {\n        target[\"equalityComparer\"] = notifyWhen == \"always\" ?\n            null :  // null equalityComparer means to always notify\n            valuesArePrimitiveAndEqual;\n    }\n};\n\nvar primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };\nfunction valuesArePrimitiveAndEqual(a, b) {\n    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);\n    return oldValueIsPrimitive ? (a === b) : false;\n}\n\nfunction throttle(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            timeoutInstance = ko.utils.setTimeout(function () {\n                timeoutInstance = undefined;\n                callback();\n            }, timeout);\n        }\n    };\n}\n\nfunction debounce(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        clearTimeout(timeoutInstance);\n        timeoutInstance = ko.utils.setTimeout(callback, timeout);\n    };\n}\n\nfunction applyExtenders(requestedExtenders) {\n    var target = this;\n    if (requestedExtenders) {\n        ko.utils.objectForEach(requestedExtenders, function(key, value) {\n            var extenderHandler = ko.extenders[key];\n            if (typeof extenderHandler == 'function') {\n                target = extenderHandler(target, value) || target;\n            }\n        });\n    }\n    return target;\n}\n\nko.exportSymbol('extenders', ko.extenders);\n\nko.subscription = function (target, callback, disposeCallback) {\n    this._target = target;\n    this.callback = callback;\n    this.disposeCallback = disposeCallback;\n    this.isDisposed = false;\n    ko.exportProperty(this, 'dispose', this.dispose);\n};\nko.subscription.prototype.dispose = function () {\n    this.isDisposed = true;\n    this.disposeCallback();\n};\n\nko.subscribable = function () {\n    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);\n    ko_subscribable_fn.init(this);\n}\n\nvar defaultEvent = \"change\";\n\n// Moved out of \"limit\" to avoid the extra closure\nfunction limitNotifySubscribers(value, event) {\n    if (!event || event === defaultEvent) {\n        this._limitChange(value);\n    } else if (event === 'beforeChange') {\n        this._limitBeforeChange(value);\n    } else {\n        this._origNotifySubscribers(value, event);\n    }\n}\n\nvar ko_subscribable_fn = {\n    init: function(instance) {\n        instance._subscriptions = { \"change\": [] };\n        instance._versionNumber = 1;\n    },\n\n    subscribe: function (callback, callbackTarget, event) {\n        var self = this;\n\n        event = event || defaultEvent;\n        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n        var subscription = new ko.subscription(self, boundCallback, function () {\n            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);\n            if (self.afterSubscriptionRemove)\n                self.afterSubscriptionRemove(event);\n        });\n\n        if (self.beforeSubscriptionAdd)\n            self.beforeSubscriptionAdd(event);\n\n        if (!self._subscriptions[event])\n            self._subscriptions[event] = [];\n        self._subscriptions[event].push(subscription);\n\n        return subscription;\n    },\n\n    \"notifySubscribers\": function (valueToNotify, event) {\n        event = event || defaultEvent;\n        if (event === defaultEvent) {\n            this.updateVersion();\n        }\n        if (this.hasSubscriptionsForEvent(event)) {\n            var subs = event === defaultEvent && this._changeSubscriptions || this._subscriptions[event].slice(0);\n            try {\n                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n                for (var i = 0, subscription; subscription = subs[i]; ++i) {\n                    // In case a subscription was disposed during the arrayForEach cycle, check\n                    // for isDisposed on each subscription before invoking its callback\n                    if (!subscription.isDisposed)\n                        subscription.callback(valueToNotify);\n                }\n            } finally {\n                ko.dependencyDetection.end(); // End suppressing dependency detection\n            }\n        }\n    },\n\n    getVersion: function () {\n        return this._versionNumber;\n    },\n\n    hasChanged: function (versionToCheck) {\n        return this.getVersion() !== versionToCheck;\n    },\n\n    updateVersion: function () {\n        ++this._versionNumber;\n    },\n\n    limit: function(limitFunction) {\n        var self = this, selfIsObservable = ko.isObservable(self),\n            ignoreBeforeChange, notifyNextChange, previousValue, pendingValue, beforeChange = 'beforeChange';\n\n        if (!self._origNotifySubscribers) {\n            self._origNotifySubscribers = self[\"notifySubscribers\"];\n            self[\"notifySubscribers\"] = limitNotifySubscribers;\n        }\n\n        var finish = limitFunction(function() {\n            self._notificationIsPending = false;\n\n            // If an observable provided a reference to itself, access it to get the latest value.\n            // This allows computed observables to delay calculating their value until needed.\n            if (selfIsObservable && pendingValue === self) {\n                pendingValue = self._evalIfChanged ? self._evalIfChanged() : self();\n            }\n            var shouldNotify = notifyNextChange || self.isDifferent(previousValue, pendingValue);\n\n            notifyNextChange = ignoreBeforeChange = false;\n\n            if (shouldNotify) {\n                self._origNotifySubscribers(previousValue = pendingValue);\n            }\n        });\n\n        self._limitChange = function(value) {\n            self._changeSubscriptions = self._subscriptions[defaultEvent].slice(0);\n            self._notificationIsPending = ignoreBeforeChange = true;\n            pendingValue = value;\n            finish();\n        };\n        self._limitBeforeChange = function(value) {\n            if (!ignoreBeforeChange) {\n                previousValue = value;\n                self._origNotifySubscribers(value, beforeChange);\n            }\n        };\n        self._notifyNextChangeIfValueIsDifferent = function() {\n            if (self.isDifferent(previousValue, self.peek(true /*evaluate*/))) {\n                notifyNextChange = true;\n            }\n        };\n    },\n\n    hasSubscriptionsForEvent: function(event) {\n        return this._subscriptions[event] && this._subscriptions[event].length;\n    },\n\n    getSubscriptionsCount: function (event) {\n        if (event) {\n            return this._subscriptions[event] && this._subscriptions[event].length || 0;\n        } else {\n            var total = 0;\n            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {\n                if (eventName !== 'dirty')\n                    total += subscriptions.length;\n            });\n            return total;\n        }\n    },\n\n    isDifferent: function(oldValue, newValue) {\n        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);\n    },\n\n    extend: applyExtenders\n};\n\nko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);\nko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);\nko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);\n\n// For browsers that support proto assignment, we overwrite the prototype of each\n// observable instance. Since observables are functions, we need Function.prototype\n// to still be in the prototype chain.\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);\n}\n\nko.subscribable['fn'] = ko_subscribable_fn;\n\n\nko.isSubscribable = function (instance) {\n    return instance != null && typeof instance.subscribe == \"function\" && typeof instance[\"notifySubscribers\"] == \"function\";\n};\n\nko.exportSymbol('subscribable', ko.subscribable);\nko.exportSymbol('isSubscribable', ko.isSubscribable);\n\nko.computedContext = ko.dependencyDetection = (function () {\n    var outerFrames = [],\n        currentFrame,\n        lastId = 0;\n\n    // Return a unique ID that can be assigned to an observable for dependency tracking.\n    // Theoretically, you could eventually overflow the number storage size, resulting\n    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n    // take over 285 years to reach that number.\n    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\n    function getId() {\n        return ++lastId;\n    }\n\n    function begin(options) {\n        outerFrames.push(currentFrame);\n        currentFrame = options;\n    }\n\n    function end() {\n        currentFrame = outerFrames.pop();\n    }\n\n    return {\n        begin: begin,\n\n        end: end,\n\n        registerDependency: function (subscribable) {\n            if (currentFrame) {\n                if (!ko.isSubscribable(subscribable))\n                    throw new Error(\"Only subscribable things can act as dependencies\");\n                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));\n            }\n        },\n\n        ignore: function (callback, callbackTarget, callbackArgs) {\n            try {\n                begin();\n                return callback.apply(callbackTarget, callbackArgs || []);\n            } finally {\n                end();\n            }\n        },\n\n        getDependenciesCount: function () {\n            if (currentFrame)\n                return currentFrame.computed.getDependenciesCount();\n        },\n\n        isInitial: function() {\n            if (currentFrame)\n                return currentFrame.isInitial;\n        }\n    };\n})();\n\nko.exportSymbol('computedContext', ko.computedContext);\nko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);\nko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);\n\nko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);\nvar observableLatestValue = ko.utils.createSymbolOrString('_latestValue');\n\nko.observable = function (initialValue) {\n    function observable() {\n        if (arguments.length > 0) {\n            // Write\n\n            // Ignore writes if the value hasn't changed\n            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {\n                observable.valueWillMutate();\n                observable[observableLatestValue] = arguments[0];\n                observable.valueHasMutated();\n            }\n            return this; // Permits chained assignments\n        }\n        else {\n            // Read\n            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n            return observable[observableLatestValue];\n        }\n    }\n\n    observable[observableLatestValue] = initialValue;\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(observable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(observable);\n\n    // Inherit from 'observable'\n    ko.utils.setPrototypeOfOrExtend(observable, observableFn);\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](observable, true);\n    }\n\n    return observable;\n}\n\n// Define prototype for observables\nvar observableFn = {\n    'equalityComparer': valuesArePrimitiveAndEqual,\n    peek: function() { return this[observableLatestValue]; },\n    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },\n    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observable constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);\n}\n\nvar protoProperty = ko.observable.protoProperty = '__ko_proto__';\nobservableFn[protoProperty] = ko.observable;\n\nko.hasPrototype = function(instance, prototype) {\n    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n};\n\nko.isObservable = function (instance) {\n    return ko.hasPrototype(instance, ko.observable);\n}\nko.isWriteableObservable = function (instance) {\n    // Observable\n    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)\n        return true;\n    // Writeable dependent observable\n    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))\n        return true;\n    // Anything else\n    return false;\n}\n\nko.exportSymbol('observable', ko.observable);\nko.exportSymbol('isObservable', ko.isObservable);\nko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);\nko.exportSymbol('isWritableObservable', ko.isWriteableObservable);\nko.exportSymbol('observable.fn', observableFn);\nko.exportProperty(observableFn, 'peek', observableFn.peek);\nko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);\nko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);\nko.observableArray = function (initialValues) {\n    initialValues = initialValues || [];\n\n    if (typeof initialValues != 'object' || !('length' in initialValues))\n        throw new Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");\n\n    var result = ko.observable(initialValues);\n    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);\n    return result.extend({'trackArrayChanges':true});\n};\n\nko.observableArray['fn'] = {\n    'remove': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var removedValues = [];\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        for (var i = 0; i < underlyingArray.length; i++) {\n            var value = underlyingArray[i];\n            if (predicate(value)) {\n                if (removedValues.length === 0) {\n                    this.valueWillMutate();\n                }\n                removedValues.push(value);\n                underlyingArray.splice(i, 1);\n                i--;\n            }\n        }\n        if (removedValues.length) {\n            this.valueHasMutated();\n        }\n        return removedValues;\n    },\n\n    'removeAll': function (arrayOfValues) {\n        // If you passed zero args, we remove everything\n        if (arrayOfValues === undefined) {\n            var underlyingArray = this.peek();\n            var allValues = underlyingArray.slice(0);\n            this.valueWillMutate();\n            underlyingArray.splice(0, underlyingArray.length);\n            this.valueHasMutated();\n            return allValues;\n        }\n        // If you passed an arg, we interpret it as an array of entries to remove\n        if (!arrayOfValues)\n            return [];\n        return this['remove'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'destroy': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        this.valueWillMutate();\n        for (var i = underlyingArray.length - 1; i >= 0; i--) {\n            var value = underlyingArray[i];\n            if (predicate(value))\n                underlyingArray[i][\"_destroy\"] = true;\n        }\n        this.valueHasMutated();\n    },\n\n    'destroyAll': function (arrayOfValues) {\n        // If you passed zero args, we destroy everything\n        if (arrayOfValues === undefined)\n            return this['destroy'](function() { return true });\n\n        // If you passed an arg, we interpret it as an array of entries to destroy\n        if (!arrayOfValues)\n            return [];\n        return this['destroy'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'indexOf': function (item) {\n        var underlyingArray = this();\n        return ko.utils.arrayIndexOf(underlyingArray, item);\n    },\n\n    'replace': function(oldItem, newItem) {\n        var index = this['indexOf'](oldItem);\n        if (index >= 0) {\n            this.valueWillMutate();\n            this.peek()[index] = newItem;\n            this.valueHasMutated();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observableArray constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\n// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\nko.utils.arrayForEach([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n        // (for consistency with mutating regular observables)\n        var underlyingArray = this.peek();\n        this.valueWillMutate();\n        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n        this.valueHasMutated();\n        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n        return methodCallResult === underlyingArray ? this : methodCallResult;\n    };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\nko.utils.arrayForEach([\"slice\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        var underlyingArray = this();\n        return underlyingArray[methodName].apply(underlyingArray, arguments);\n    };\n});\n\nko.exportSymbol('observableArray', ko.observableArray);\nvar arrayChangeEventName = 'arrayChange';\nko.extenders['trackArrayChanges'] = function(target, options) {\n    // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n    target.compareArrayOptions = {};\n    if (options && typeof options == \"object\") {\n        ko.utils.extend(target.compareArrayOptions, options);\n    }\n    target.compareArrayOptions['sparse'] = true;\n\n    // Only modify the target observable once\n    if (target.cacheDiffForKnownOperation) {\n        return;\n    }\n    var trackingChanges = false,\n        cachedDiff = null,\n        arrayChangeSubscription,\n        pendingNotifications = 0,\n        underlyingNotifySubscribersFunction,\n        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n    // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n    target.beforeSubscriptionAdd = function (event) {\n        if (underlyingBeforeSubscriptionAddFunction)\n            underlyingBeforeSubscriptionAddFunction.call(target, event);\n        if (event === arrayChangeEventName) {\n            trackChanges();\n        }\n    };\n    // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n    target.afterSubscriptionRemove = function (event) {\n        if (underlyingAfterSubscriptionRemoveFunction)\n            underlyingAfterSubscriptionRemoveFunction.call(target, event);\n        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n            if (underlyingNotifySubscribersFunction) {\n                target['notifySubscribers'] = underlyingNotifySubscribersFunction;\n                underlyingNotifySubscribersFunction = undefined;\n            }\n            arrayChangeSubscription.dispose();\n            trackingChanges = false;\n        }\n    };\n\n    function trackChanges() {\n        // Calling 'trackChanges' multiple times is the same as calling it once\n        if (trackingChanges) {\n            return;\n        }\n\n        trackingChanges = true;\n\n        // Intercept \"notifySubscribers\" to track how many times it was called.\n        underlyingNotifySubscribersFunction = target['notifySubscribers'];\n        target['notifySubscribers'] = function(valueToNotify, event) {\n            if (!event || event === defaultEvent) {\n                ++pendingNotifications;\n            }\n            return underlyingNotifySubscribersFunction.apply(this, arguments);\n        };\n\n        // Each time the array changes value, capture a clone so that on the next\n        // change it's possible to produce a diff\n        var previousContents = [].concat(target.peek() || []);\n        cachedDiff = null;\n        arrayChangeSubscription = target.subscribe(function(currentContents) {\n            // Make a copy of the current contents and ensure it's an array\n            currentContents = [].concat(currentContents || []);\n\n            // Compute the diff and issue notifications, but only if someone is listening\n            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n                var changes = getChanges(previousContents, currentContents);\n            }\n\n            // Eliminate references to the old, removed items, so they can be GCed\n            previousContents = currentContents;\n            cachedDiff = null;\n            pendingNotifications = 0;\n\n            if (changes && changes.length) {\n                target['notifySubscribers'](changes, arrayChangeEventName);\n            }\n        });\n    }\n\n    function getChanges(previousContents, currentContents) {\n        // We try to re-use cached diffs.\n        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n        // notifications are issued immediately so we wouldn't be queueing up more than one.\n        if (!cachedDiff || pendingNotifications > 1) {\n            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n        }\n\n        return cachedDiff;\n    }\n\n    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {\n        // Only run if we're currently tracking changes for this observable array\n        // and there aren't any pending deferred notifications.\n        if (!trackingChanges || pendingNotifications) {\n            return;\n        }\n        var diff = [],\n            arrayLength = rawArray.length,\n            argsLength = args.length,\n            offset = 0;\n\n        function pushDiff(status, value, index) {\n            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n        }\n        switch (operationName) {\n            case 'push':\n                offset = arrayLength;\n            case 'unshift':\n                for (var index = 0; index < argsLength; index++) {\n                    pushDiff('added', args[index], offset + index);\n                }\n                break;\n\n            case 'pop':\n                offset = arrayLength - 1;\n            case 'shift':\n                if (arrayLength) {\n                    pushDiff('deleted', rawArray[offset], offset);\n                }\n                break;\n\n            case 'splice':\n                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n                    endAddIndex = startIndex + argsLength - 2,\n                    endIndex = Math.max(endDeleteIndex, endAddIndex),\n                    additions = [], deletions = [];\n                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n                    if (index < endDeleteIndex)\n                        deletions.push(pushDiff('deleted', rawArray[index], index));\n                    if (index < endAddIndex)\n                        additions.push(pushDiff('added', args[argsIndex], index));\n                }\n                ko.utils.findMovesInArrayComparison(deletions, additions);\n                break;\n\n            default:\n                return;\n        }\n        cachedDiff = diff;\n    };\n};\nvar computedState = ko.utils.createSymbolOrString('_state');\n\nko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {\n    if (typeof evaluatorFunctionOrOptions === \"object\") {\n        // Single-parameter syntax - everything is on this \"options\" param\n        options = evaluatorFunctionOrOptions;\n    } else {\n        // Multi-parameter syntax - construct the options according to the params passed\n        options = options || {};\n        if (evaluatorFunctionOrOptions) {\n            options[\"read\"] = evaluatorFunctionOrOptions;\n        }\n    }\n    if (typeof options[\"read\"] != \"function\")\n        throw Error(\"Pass a function that returns the value of the ko.computed\");\n\n    var writeFunction = options[\"write\"];\n    var state = {\n        latestValue: undefined,\n        isStale: true,\n        isDirty: true,\n        isBeingEvaluated: false,\n        suppressDisposalUntilDisposeWhenReturnsFalse: false,\n        isDisposed: false,\n        pure: false,\n        isSleeping: false,\n        readFunction: options[\"read\"],\n        evaluatorFunctionTarget: evaluatorFunctionTarget || options[\"owner\"],\n        disposeWhenNodeIsRemoved: options[\"disposeWhenNodeIsRemoved\"] || options.disposeWhenNodeIsRemoved || null,\n        disposeWhen: options[\"disposeWhen\"] || options.disposeWhen,\n        domNodeDisposalCallback: null,\n        dependencyTracking: {},\n        dependenciesCount: 0,\n        evaluationTimeoutInstance: null\n    };\n\n    function computedObservable() {\n        if (arguments.length > 0) {\n            if (typeof writeFunction === \"function\") {\n                // Writing a value\n                writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n            } else {\n                throw new Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n            }\n            return this; // Permits chained assignments\n        } else {\n            // Reading the value\n            ko.dependencyDetection.registerDependency(computedObservable);\n            if (state.isDirty || (state.isSleeping && computedObservable.haveDependenciesChanged())) {\n                computedObservable.evaluateImmediate();\n            }\n            return state.latestValue;\n        }\n    }\n\n    computedObservable[computedState] = state;\n    computedObservable.hasWriteFunction = typeof writeFunction === \"function\";\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(computedObservable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(computedObservable);\n\n    // Inherit from 'computed'\n    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);\n\n    if (options['pure']) {\n        state.pure = true;\n        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription\n        ko.utils.extend(computedObservable, pureComputedOverrides);\n    } else if (options['deferEvaluation']) {\n        ko.utils.extend(computedObservable, deferEvaluationOverrides);\n    }\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](computedObservable, true);\n    }\n\n    if (DEBUG) {\n        // #1731 - Aid debugging by exposing the computed's options\n        computedObservable[\"_options\"] = options;\n    }\n\n    if (state.disposeWhenNodeIsRemoved) {\n        // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n        // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n        // we'll prevent disposal until \"disposeWhen\" first returns false.\n        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n        // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try\n        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n        // be documented or used by application code, as it's likely to change in a future version of KO.\n        if (!state.disposeWhenNodeIsRemoved.nodeType) {\n            state.disposeWhenNodeIsRemoved = null;\n        }\n    }\n\n    // Evaluate, unless sleeping or deferEvaluation is true\n    if (!state.isSleeping && !options['deferEvaluation']) {\n        computedObservable.evaluateImmediate();\n    }\n\n    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is\n    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).\n    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {\n        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {\n            computedObservable.dispose();\n        });\n    }\n\n    return computedObservable;\n};\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n    if (entryToDispose !== null && entryToDispose.dispose) {\n        entryToDispose.dispose();\n    }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable, id) {\n    var computedObservable = this.computedObservable,\n        state = computedObservable[computedState];\n    if (!state.isDisposed) {\n        if (this.disposalCount && this.disposalCandidates[id]) {\n            // Don't want to dispose this subscription, as it's still being used\n            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);\n            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n            --this.disposalCount;\n        } else if (!state.dependencyTracking[id]) {\n            // Brand new subscription - add it\n            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));\n        }\n        // If the observable we've accessed has a pending notification, ensure we get notified of the actual final value (bypass equality checks)\n        if (subscribable._notificationIsPending) {\n            subscribable._notifyNextChangeIfValueIsDifferent();\n        }\n    }\n}\n\nvar computedFn = {\n    \"equalityComparer\": valuesArePrimitiveAndEqual,\n    getDependenciesCount: function () {\n        return this[computedState].dependenciesCount;\n    },\n    addDependencyTracking: function (id, target, trackingObj) {\n        if (this[computedState].pure && target === this) {\n            throw Error(\"A 'pure' computed must not be called recursively\");\n        }\n\n        this[computedState].dependencyTracking[id] = trackingObj;\n        trackingObj._order = this[computedState].dependenciesCount++;\n        trackingObj._version = target.getVersion();\n    },\n    haveDependenciesChanged: function () {\n        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;\n        for (id in dependencyTracking) {\n            if (dependencyTracking.hasOwnProperty(id)) {\n                dependency = dependencyTracking[id];\n                if ((this._evalDelayed && dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version)) {\n                    return true;\n                }\n            }\n        }\n    },\n    markDirty: function () {\n        // Process \"dirty\" events if we can handle delayed notifications\n        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n            this._evalDelayed(false /*isChange*/);\n        }\n    },\n    isActive: function () {\n        var state = this[computedState];\n        return state.isDirty || state.dependenciesCount > 0;\n    },\n    respondToChange: function () {\n        // Ignore \"change\" events if we've already scheduled a delayed notification\n        if (!this._notificationIsPending) {\n            this.evaluatePossiblyAsync();\n        } else if (this[computedState].isDirty) {\n            this[computedState].isStale = true;\n        }\n    },\n    subscribeToDependency: function (target) {\n        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {\n            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n                changeSub = target.subscribe(this.respondToChange, this);\n            return {\n                _target: target,\n                dispose: function () {\n                    dirtySub.dispose();\n                    changeSub.dispose();\n                }\n            };\n        } else {\n            return target.subscribe(this.evaluatePossiblyAsync, this);\n        }\n    },\n    evaluatePossiblyAsync: function () {\n        var computedObservable = this,\n            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];\n        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n            clearTimeout(this[computedState].evaluationTimeoutInstance);\n            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {\n                computedObservable.evaluateImmediate(true /*notifyChange*/);\n            }, throttleEvaluationTimeout);\n        } else if (computedObservable._evalDelayed) {\n            computedObservable._evalDelayed(true /*isChange*/);\n        } else {\n            computedObservable.evaluateImmediate(true /*notifyChange*/);\n        }\n    },\n    evaluateImmediate: function (notifyChange) {\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            disposeWhen = state.disposeWhen,\n            changed = false;\n\n        if (state.isBeingEvaluated) {\n            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n            return;\n        }\n\n        // Do not evaluate (and possibly capture new dependencies) if disposed\n        if (state.isDisposed) {\n            return;\n        }\n\n        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {\n            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse\n            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {\n                computedObservable.dispose();\n                return;\n            }\n        } else {\n            // It just did return false, so we can stop suppressing now\n            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n        }\n\n        state.isBeingEvaluated = true;\n        try {\n            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n        } finally {\n            state.isBeingEvaluated = false;\n        }\n\n        if (!state.dependenciesCount) {\n            computedObservable.dispose();\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {\n        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            changed = false;\n\n        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n        // Then, during evaluation, we cross off any that are in fact still being used.\n        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time\n            dependencyDetectionContext = {\n                computedObservable: computedObservable,\n                disposalCandidates: state.dependencyTracking,\n                disposalCount: state.dependenciesCount\n            };\n\n        ko.dependencyDetection.begin({\n            callbackTarget: dependencyDetectionContext,\n            callback: computedBeginDependencyDetectionCallback,\n            computed: computedObservable,\n            isInitial: isInitial\n        });\n\n        state.dependencyTracking = {};\n        state.dependenciesCount = 0;\n\n        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n        if (computedObservable.isDifferent(state.latestValue, newValue)) {\n            if (!state.isSleeping) {\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"beforeChange\");\n            }\n\n            state.latestValue = newValue;\n            if (DEBUG) computedObservable._latestValue = newValue;\n\n            if (state.isSleeping) {\n                computedObservable.updateVersion();\n            } else if (notifyChange) {\n                computedObservable[\"notifySubscribers\"](state.latestValue);\n            }\n\n            changed = true;\n        }\n\n        if (isInitial) {\n            computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {\n        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n        // overhead of computed evaluation (on V8 at least).\n\n        try {\n            var readFunction = state.readFunction;\n            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n        } finally {\n            ko.dependencyDetection.end();\n\n            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n            }\n\n            state.isStale = state.isDirty = false;\n        }\n    },\n    peek: function (evaluate) {\n        // By default, peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n        // Pass in true to evaluate if needed.\n        var state = this[computedState];\n        if ((state.isDirty && (evaluate || !state.dependenciesCount)) || (state.isSleeping && this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return state.latestValue;\n    },\n    limit: function (limitFunction) {\n        // Override the limit function with one that delays evaluation as well\n        ko.subscribable['fn'].limit.call(this, limitFunction);\n        this._evalIfChanged = function () {\n            if (this[computedState].isStale) {\n                this.evaluateImmediate();\n            } else {\n                this[computedState].isDirty = false;\n            }\n            return this[computedState].latestValue;\n        };\n        this._evalDelayed = function (isChange) {\n            this._limitBeforeChange(this[computedState].latestValue);\n\n            // Mark as dirty\n            this[computedState].isDirty = true;\n            if (isChange) {\n                this[computedState].isStale = true;\n            }\n\n            // Pass the observable to the \"limit\" code, which will evaluate it when\n            // it's time to do the notification.\n            this._limitChange(this);\n        };\n    },\n    dispose: function () {\n        var state = this[computedState];\n        if (!state.isSleeping && state.dependencyTracking) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose)\n                    dependency.dispose();\n            });\n        }\n        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {\n            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);\n        }\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isDisposed = true;\n        state.isStale = false;\n        state.isDirty = false;\n        state.isSleeping = false;\n        state.disposeWhenNodeIsRemoved = null;\n    }\n};\n\nvar pureComputedOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // If asleep, wake up the computed by subscribing to any dependencies.\n        var computedObservable = this,\n            state = computedObservable[computedState];\n        if (!state.isDisposed && state.isSleeping && event == 'change') {\n            state.isSleeping = false;\n            if (state.isStale || computedObservable.haveDependenciesChanged()) {\n                state.dependencyTracking = null;\n                state.dependenciesCount = 0;\n                if (computedObservable.evaluateImmediate()) {\n                    computedObservable.updateVersion();\n                }\n            } else {\n                // First put the dependencies in order\n                var dependeciesOrder = [];\n                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                    dependeciesOrder[dependency._order] = id;\n                });\n                // Next, subscribe to each one\n                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {\n                    var dependency = state.dependencyTracking[id],\n                        subscription = computedObservable.subscribeToDependency(dependency._target);\n                    subscription._order = order;\n                    subscription._version = dependency._version;\n                    state.dependencyTracking[id] = subscription;\n                });\n            }\n            if (!state.isDisposed) {     // test since evaluating could trigger disposal\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n            }\n        }\n    },\n    afterSubscriptionRemove: function (event) {\n        var state = this[computedState];\n        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose) {\n                    state.dependencyTracking[id] = {\n                        _target: dependency._target,\n                        _order: dependency._order,\n                        _version: dependency._version\n                    };\n                    dependency.dispose();\n                }\n            });\n            state.isSleeping = true;\n            this[\"notifySubscribers\"](undefined, \"asleep\");\n        }\n    },\n    getVersion: function () {\n        // Because a pure computed is not automatically updated while it is sleeping, we can't\n        // simply return the version number. Instead, we check if any of the dependencies have\n        // changed and conditionally re-evaluate the computed observable.\n        var state = this[computedState];\n        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return ko.subscribable['fn'].getVersion.call(this);\n    }\n};\n\nvar deferEvaluationOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n        if (event == 'change' || event == 'beforeChange') {\n            this.peek();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = ko.observable.protoProperty; // == \"__ko_proto__\"\nko.computed[protoProp] = ko.observable;\ncomputedFn[protoProp] = ko.computed;\n\nko.isComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed);\n};\n\nko.isPureComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed)\n        && instance[computedState] && instance[computedState].pure;\n};\n\nko.exportSymbol('computed', ko.computed);\nko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)\nko.exportSymbol('isComputed', ko.isComputed);\nko.exportSymbol('isPureComputed', ko.isPureComputed);\nko.exportSymbol('computed.fn', computedFn);\nko.exportProperty(computedFn, 'peek', computedFn.peek);\nko.exportProperty(computedFn, 'dispose', computedFn.dispose);\nko.exportProperty(computedFn, 'isActive', computedFn.isActive);\nko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);\n\nko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n    if (typeof evaluatorFunctionOrOptions === 'function') {\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});\n    } else {\n        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object\n        evaluatorFunctionOrOptions['pure'] = true;\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n    }\n}\nko.exportSymbol('pureComputed', ko.pureComputed);\n\n(function() {\n    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\n    ko.toJS = function(rootObject) {\n        if (arguments.length == 0)\n            throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n        // We just unwrap everything at every level in the object graph\n        return mapJsObjectGraph(rootObject, function(valueToMap) {\n            // Loop because an observable's value might in turn be another observable wrapper\n            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)\n                valueToMap = valueToMap();\n            return valueToMap;\n        });\n    };\n\n    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional\n        var plainJavaScriptObject = ko.toJS(rootObject);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n        visitedObjects = visitedObjects || new objectLookup();\n\n        rootObject = mapInputCallback(rootObject);\n        var canHaveProperties = (typeof rootObject == \"object\") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));\n        if (!canHaveProperties)\n            return rootObject;\n\n        var outputProperties = rootObject instanceof Array ? [] : {};\n        visitedObjects.save(rootObject, outputProperties);\n\n        visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n            var propertyValue = mapInputCallback(rootObject[indexer]);\n\n            switch (typeof propertyValue) {\n                case \"boolean\":\n                case \"number\":\n                case \"string\":\n                case \"function\":\n                    outputProperties[indexer] = propertyValue;\n                    break;\n                case \"object\":\n                case \"undefined\":\n                    var previouslyMappedValue = visitedObjects.get(propertyValue);\n                    outputProperties[indexer] = (previouslyMappedValue !== undefined)\n                        ? previouslyMappedValue\n                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n                    break;\n            }\n        });\n\n        return outputProperties;\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (rootObject instanceof Array) {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n\n            // For arrays, also respect toJSON property for custom mappings (fixes #278)\n            if (typeof rootObject['toJSON'] == 'function')\n                visitorCallback('toJSON');\n        } else {\n            for (var propertyName in rootObject) {\n                visitorCallback(propertyName);\n            }\n        }\n    };\n\n    function objectLookup() {\n        this.keys = [];\n        this.values = [];\n    };\n\n    objectLookup.prototype = {\n        constructor: objectLookup,\n        save: function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            if (existingIndex >= 0)\n                this.values[existingIndex] = value;\n            else {\n                this.keys.push(key);\n                this.values.push(value);\n            }\n        },\n        get: function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;\n        }\n    };\n})();\n\nko.exportSymbol('toJS', ko.toJS);\nko.exportSymbol('toJSON', ko.toJSON);\n(function () {\n    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';\n\n    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values\n    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values\n    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.\n    ko.selectExtensions = {\n        readValue : function(element) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    if (element[hasDomDataExpandoProperty] === true)\n                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);\n                    return ko.utils.ieVersion <= 7\n                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)\n                        : element.value;\n                case 'select':\n                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;\n                default:\n                    return element.value;\n            }\n        },\n\n        writeValue: function(element, value, allowUnset) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    switch(typeof value) {\n                        case \"string\":\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);\n                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node\n                                delete element[hasDomDataExpandoProperty];\n                            }\n                            element.value = value;\n                            break;\n                        default:\n                            // Store arbitrary object using DomData\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);\n                            element[hasDomDataExpandoProperty] = true;\n\n                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.\n                            element.value = typeof value === \"number\" ? value : \"\";\n                            break;\n                    }\n                    break;\n                case 'select':\n                    if (value === \"\" || value === null)       // A blank string or null value will select the caption\n                        value = undefined;\n                    var selection = -1;\n                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {\n                        optionValue = ko.selectExtensions.readValue(element.options[i]);\n                        // Include special check to handle selecting a caption with a blank string value\n                        if (optionValue == value || (optionValue == \"\" && value === undefined)) {\n                            selection = i;\n                            break;\n                        }\n                    }\n                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {\n                        element.selectedIndex = selection;\n                    }\n                    break;\n                default:\n                    if ((value === null) || (value === undefined))\n                        value = \"\";\n                    element.value = value;\n                    break;\n            }\n        }\n    };\n})();\n\nko.exportSymbol('selectExtensions', ko.selectExtensions);\nko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);\nko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);\nko.expressionRewriting = (function () {\n    var javaScriptReservedWords = [\"true\", \"false\", \"null\", \"undefined\"];\n\n    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor\n    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).\n    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).\n    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i;\n\n    function getWriteableValue(expression) {\n        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)\n            return false;\n        var match = expression.match(javaScriptAssignmentTarget);\n        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;\n    }\n\n    // The following regular expressions will be used to split an object-literal string into tokens\n\n        // These two match strings, either with double quotes or single quotes\n    var stringDouble = '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"',\n        stringSingle = \"'(?:[^'\\\\\\\\]|\\\\\\\\.)*'\",\n        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions\n        // as a regular expression (this is handled by the parsing loop below).\n        stringRegexp = '/(?:[^/\\\\\\\\]|\\\\\\\\.)*/\\w*',\n        // These characters have special meaning to the parser and must not appear in the middle of a\n        // token, except as part of a string.\n        specials = ',\"\\'{}()/:[\\\\]',\n        // Match text (at least two characters) that does not contain any of the above special characters,\n        // although some of the special characters are allowed to start it (all but the colon and comma).\n        // The text can contain spaces, but leading or trailing spaces are skipped.\n        everyThingElse = '[^\\\\s:,/][^' + specials + ']*[^\\\\s' + specials + ']',\n        // Match any non-space character not matched already. This will match colons and commas, since they're\n        // not matched by \"everyThingElse\", but will also match any other single character that wasn't already\n        // matched (for example: in \"a: 1, b: 2\", each of the non-space characters will be matched by oneNotSpace).\n        oneNotSpace = '[^\\\\s]',\n\n        // Create the actual regular expression by or-ing the above strings. The order is important.\n        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),\n\n        // Match end of previous token to determine whether a slash is a division or regex.\n        divisionLookBehind = /[\\])\"'A-Za-z0-9_$]+$/,\n        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};\n\n    function parseObjectLiteral(objectLiteralString) {\n        // Trim leading and trailing spaces from the string\n        var str = ko.utils.stringTrim(objectLiteralString);\n\n        // Trim braces '{' surrounding the whole object literal\n        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);\n\n        // Split into tokens\n        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;\n\n        if (toks) {\n            // Append a comma so that we don't need a separate code block to deal with the last item\n            toks.push(',');\n\n            for (var i = 0, tok; tok = toks[i]; ++i) {\n                var c = tok.charCodeAt(0);\n                // A comma signals the end of a key/value pair if depth is zero\n                if (c === 44) { // \",\"\n                    if (depth <= 0) {\n                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});\n                        key = depth = 0;\n                        values = [];\n                        continue;\n                    }\n                // Simply skip the colon that separates the name and value\n                } else if (c === 58) { // \":\"\n                    if (!depth && !key && values.length === 1) {\n                        key = values.pop();\n                        continue;\n                    }\n                // A set of slashes is initially matched as a regular expression, but could be division\n                } else if (c === 47 && i && tok.length > 1) {  // \"/\"\n                    // Look at the end of the previous token to determine if the slash is actually division\n                    var match = toks[i-1].match(divisionLookBehind);\n                    if (match && !keywordRegexLookBehind[match[0]]) {\n                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)\n                        str = str.substr(str.indexOf(tok) + 1);\n                        toks = str.match(bindingToken);\n                        toks.push(',');\n                        i = -1;\n                        // Continue with just the slash\n                        tok = '/';\n                    }\n                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored\n                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['\n                    ++depth;\n                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'\n                    --depth;\n                // The key will be the first token; if it's a string, trim the quotes\n                } else if (!key && !values.length && (c === 34 || c === 39)) { // '\"', \"'\"\n                    tok = tok.slice(1, -1);\n                }\n                values.push(tok);\n            }\n        }\n        return result;\n    }\n\n    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.\n    var twoWayBindings = {};\n\n    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {\n        bindingOptions = bindingOptions || {};\n\n        function processKeyValue(key, val) {\n            var writableVal;\n            function callPreprocessHook(obj) {\n                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;\n            }\n            if (!bindingParams) {\n                if (!callPreprocessHook(ko['getBindingHandler'](key)))\n                    return;\n\n                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {\n                    // For two-way bindings, provide a write method in case the value\n                    // isn't a writable observable.\n                    propertyAccessorResultStrings.push(\"'\" + key + \"':function(_z){\" + writableVal + \"=_z}\");\n                }\n            }\n            // Values are wrapped in a function so that each value can be accessed independently\n            if (makeValueAccessors) {\n                val = 'function(){return ' + val + ' }';\n            }\n            resultStrings.push(\"'\" + key + \"':\" + val);\n        }\n\n        var resultStrings = [],\n            propertyAccessorResultStrings = [],\n            makeValueAccessors = bindingOptions['valueAccessors'],\n            bindingParams = bindingOptions['bindingParams'],\n            keyValueArray = typeof bindingsStringOrKeyValueArray === \"string\" ?\n                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;\n\n        ko.utils.arrayForEach(keyValueArray, function(keyValue) {\n            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);\n        });\n\n        if (propertyAccessorResultStrings.length)\n            processKeyValue('_ko_property_writers', \"{\" + propertyAccessorResultStrings.join(\",\") + \" }\");\n\n        return resultStrings.join(\",\");\n    }\n\n    return {\n        bindingRewriteValidators: [],\n\n        twoWayBindings: twoWayBindings,\n\n        parseObjectLiteral: parseObjectLiteral,\n\n        preProcessBindings: preProcessBindings,\n\n        keyValueArrayContainsKey: function(keyValueArray, key) {\n            for (var i = 0; i < keyValueArray.length; i++)\n                if (keyValueArray[i]['key'] == key)\n                    return true;\n            return false;\n        },\n\n        // Internal, private KO utility for updating model properties from within bindings\n        // property:            If the property being updated is (or might be) an observable, pass it here\n        //                      If it turns out to be a writable observable, it will be written to directly\n        // allBindings:         An object with a get method to retrieve bindings in the current execution context.\n        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable\n        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'\n        // value:               The value to be written\n        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if\n        //                      it is !== existing value on that writable observable\n        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {\n            if (!property || !ko.isObservable(property)) {\n                var propWriters = allBindings.get('_ko_property_writers');\n                if (propWriters && propWriters[key])\n                    propWriters[key](value);\n            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {\n                property(value);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('expressionRewriting', ko.expressionRewriting);\nko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);\nko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);\nko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);\n\n// Making bindings explicitly declare themselves as \"two way\" isn't ideal in the long term (it would be better if\n// all bindings could use an official 'property writer' API without needing to declare that they might). However,\n// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable\n// as an internal implementation detail in the short term.\n// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an\n// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official\n// public API, and we reserve the right to remove it at any time if we create a real public property writers API.\nko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);\n\n// For backward compatibility, define the following aliases. (Previously, these function names were misleading because\n// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)\nko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);\nko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);\n(function() {\n    // \"Virtual elements\" is an abstraction on top of the usual DOM API which understands the notion that comment nodes\n    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).\n    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state\n    // of that virtual hierarchy\n    //\n    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)\n    // without having to scatter special cases all over the binding and templating code.\n\n    // IE 9 cannot reliably read the \"nodeValue\" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)\n    // but it does give them a nonstandard alternative property called \"text\" that it can read reliably. Other browsers don't have that property.\n    // So, use node.text where available, and node.nodeValue elsewhere\n    var commentNodesHaveTextProperty = document && document.createComment(\"test\").text === \"<!--test-->\";\n\n    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*-->$/ : /^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/;\n    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\\s*\\/ko\\s*-->$/ : /^\\s*\\/ko\\s*$/;\n    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };\n\n    function isStartComment(node) {\n        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function isEndComment(node) {\n        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function getVirtualChildren(startComment, allowUnbalanced) {\n        var currentNode = startComment;\n        var depth = 1;\n        var children = [];\n        while (currentNode = currentNode.nextSibling) {\n            if (isEndComment(currentNode)) {\n                depth--;\n                if (depth === 0)\n                    return children;\n            }\n\n            children.push(currentNode);\n\n            if (isStartComment(currentNode))\n                depth++;\n        }\n        if (!allowUnbalanced)\n            throw new Error(\"Cannot find closing comment tag to match: \" + startComment.nodeValue);\n        return null;\n    }\n\n    function getMatchingEndComment(startComment, allowUnbalanced) {\n        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);\n        if (allVirtualChildren) {\n            if (allVirtualChildren.length > 0)\n                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;\n            return startComment.nextSibling;\n        } else\n            return null; // Must have no matching end comment, and allowUnbalanced is true\n    }\n\n    function getUnbalancedChildTags(node) {\n        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>\n        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->\n        var childNode = node.firstChild, captureRemaining = null;\n        if (childNode) {\n            do {\n                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes\n                    captureRemaining.push(childNode);\n                else if (isStartComment(childNode)) {\n                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);\n                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set\n                        childNode = matchingEndComment;\n                    else\n                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point\n                } else if (isEndComment(childNode)) {\n                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing\n                }\n            } while (childNode = childNode.nextSibling);\n        }\n        return captureRemaining;\n    }\n\n    ko.virtualElements = {\n        allowedBindings: {},\n\n        childNodes: function(node) {\n            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;\n        },\n\n        emptyNode: function(node) {\n            if (!isStartComment(node))\n                ko.utils.emptyDomNode(node);\n            else {\n                var virtualChildren = ko.virtualElements.childNodes(node);\n                for (var i = 0, j = virtualChildren.length; i < j; i++)\n                    ko.removeNode(virtualChildren[i]);\n            }\n        },\n\n        setDomNodeChildren: function(node, childNodes) {\n            if (!isStartComment(node))\n                ko.utils.setDomNodeChildren(node, childNodes);\n            else {\n                ko.virtualElements.emptyNode(node);\n                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);\n            }\n        },\n\n        prepend: function(containerNode, nodeToPrepend) {\n            if (!isStartComment(containerNode)) {\n                if (containerNode.firstChild)\n                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);\n                else\n                    containerNode.appendChild(nodeToPrepend);\n            } else {\n                // Start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);\n            }\n        },\n\n        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {\n            if (!insertAfterNode) {\n                ko.virtualElements.prepend(containerNode, nodeToInsert);\n            } else if (!isStartComment(containerNode)) {\n                // Insert after insertion point\n                if (insertAfterNode.nextSibling)\n                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n                else\n                    containerNode.appendChild(nodeToInsert);\n            } else {\n                // Children of start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n            }\n        },\n\n        firstChild: function(node) {\n            if (!isStartComment(node))\n                return node.firstChild;\n            if (!node.nextSibling || isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        nextSibling: function(node) {\n            if (isStartComment(node))\n                node = getMatchingEndComment(node);\n            if (node.nextSibling && isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        hasBindingValue: isStartComment,\n\n        virtualNodeBindingValue: function(node) {\n            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);\n            return regexMatch ? regexMatch[1] : null;\n        },\n\n        normaliseVirtualElementDomStructure: function(elementVerified) {\n            // Workaround for https://github.com/SteveSanderson/knockout/issues/155\n            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes\n            // that are direct descendants of <ul> into the preceding <li>)\n            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])\n                return;\n\n            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags\n            // must be intended to appear *after* that child, so move them there.\n            var childNode = elementVerified.firstChild;\n            if (childNode) {\n                do {\n                    if (childNode.nodeType === 1) {\n                        var unbalancedTags = getUnbalancedChildTags(childNode);\n                        if (unbalancedTags) {\n                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child\n                            var nodeToInsertBefore = childNode.nextSibling;\n                            for (var i = 0; i < unbalancedTags.length; i++) {\n                                if (nodeToInsertBefore)\n                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);\n                                else\n                                    elementVerified.appendChild(unbalancedTags[i]);\n                            }\n                        }\n                    }\n                } while (childNode = childNode.nextSibling);\n            }\n        }\n    };\n})();\nko.exportSymbol('virtualElements', ko.virtualElements);\nko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);\nko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);\n//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified\nko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);\n//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified\nko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);\nko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);\n(function() {\n    var defaultBindingAttributeName = \"data-bind\";\n\n    ko.bindingProvider = function() {\n        this.bindingCache = {};\n    };\n\n    ko.utils.extend(ko.bindingProvider.prototype, {\n        'nodeHasBindings': function(node) {\n            switch (node.nodeType) {\n                case 1: // Element\n                    return node.getAttribute(defaultBindingAttributeName) != null\n                        || ko.components['getComponentNameForNode'](node);\n                case 8: // Comment node\n                    return ko.virtualElements.hasBindingValue(node);\n                default: return false;\n            }\n        },\n\n        'getBindings': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);\n        },\n\n        'getBindingAccessors': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'getBindingsString': function(node, bindingContext) {\n            switch (node.nodeType) {\n                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element\n                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node\n                default: return null;\n            }\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'parseBindingsString': function(bindingsString, bindingContext, node, options) {\n            try {\n                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);\n                return bindingFunction(bindingContext, node);\n            } catch (ex) {\n                ex.message = \"Unable to parse bindings.\\nBindings value: \" + bindingsString + \"\\nMessage: \" + ex.message;\n                throw ex;\n            }\n        }\n    });\n\n    ko.bindingProvider['instance'] = new ko.bindingProvider();\n\n    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {\n        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');\n        return cache[cacheKey]\n            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));\n    }\n\n    function createBindingsStringEvaluator(bindingsString, options) {\n        // Build the source for a function that evaluates \"expression\"\n        // For each scope variable, add an extra level of \"with\" nesting\n        // Example result: with(sc1) { with(sc0) { return (expression) } }\n        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),\n            functionBody = \"with($context){with($data||{}){return{\" + rewrittenBindings + \"}}}\";\n        return new Function(\"$context\", \"$element\", functionBody);\n    }\n})();\n\nko.exportSymbol('bindingProvider', ko.bindingProvider);\n(function () {\n    ko.bindingHandlers = {};\n\n    // The following element types will not be recursed into during binding.\n    var bindingDoesNotRecurseIntoElementTypes = {\n        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,\n        // because it's unexpected and a potential XSS issue.\n        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer\n        // and because such elements' contents are always intended to be bound in a different context\n        // from where they appear in the document.\n        'script': true,\n        'textarea': true,\n        'template': true\n    };\n\n    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers\n    ko['getBindingHandler'] = function(bindingKey) {\n        return ko.bindingHandlers[bindingKey];\n    };\n\n    // The ko.bindingContext constructor is only called directly to create the root context. For child\n    // contexts, use bindingContext.createChildContext or bindingContext.extend.\n    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {\n\n        // The binding context object includes static properties for the current, parent, and root view models.\n        // If a view model is actually stored in an observable, the corresponding binding context object, and\n        // any child contexts, must be updated when the view model is changed.\n        function updateContext() {\n            // Most of the time, the context will directly get a view model object, but if a function is given,\n            // we call the function to retrieve the view model. If the function accesses any observables or returns\n            // an observable, the dependency is tracked, and those observables can later cause the binding\n            // context to be updated.\n            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,\n                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);\n\n            if (parentContext) {\n                // When a \"parent\" context is given, register a dependency on the parent context. Thus whenever the\n                // parent context is updated, this context will also be updated.\n                if (parentContext._subscribable)\n                    parentContext._subscribable();\n\n                // Copy $root and any custom properties from the parent context\n                ko.utils.extend(self, parentContext);\n\n                // Because the above copy overwrites our own properties, we need to reset them.\n                self._subscribable = subscribable;\n            } else {\n                self['$parents'] = [];\n                self['$root'] = dataItem;\n\n                // Export 'ko' in the binding context so it will be available in bindings and templates\n                // even if 'ko' isn't exported as a global, such as when using an AMD loader.\n                // See https://github.com/SteveSanderson/knockout/issues/490\n                self['ko'] = ko;\n            }\n            self['$rawData'] = dataItemOrObservable;\n            self['$data'] = dataItem;\n            if (dataItemAlias)\n                self[dataItemAlias] = dataItem;\n\n            // The extendCallback function is provided when creating a child context or extending a context.\n            // It handles the specific actions needed to finish setting up the binding context. Actions in this\n            // function could also add dependencies to this binding context.\n            if (extendCallback)\n                extendCallback(self, parentContext, dataItem);\n\n            return self['$data'];\n        }\n        function disposeWhen() {\n            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);\n        }\n\n        var self = this,\n            isFunc = typeof(dataItemOrAccessor) == \"function\" && !ko.isObservable(dataItemOrAccessor),\n            nodes,\n            subscribable;\n\n        if (options && options['exportDependencies']) {\n            // The \"exportDependencies\" option means that the calling code will track any dependencies and re-create\n            // the binding context when they change.\n            updateContext();\n        } else {\n            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });\n\n            // At this point, the binding context has been initialized, and the \"subscribable\" computed observable is\n            // subscribed to any observables that were accessed in the process. If there is nothing to track, the\n            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in\n            // the context object.\n            if (subscribable.isActive()) {\n                self._subscribable = subscribable;\n\n                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed\n                subscribable['equalityComparer'] = null;\n\n                // We need to be able to dispose of this computed observable when it's no longer needed. This would be\n                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and\n                // we cannot assume that those nodes have any relation to each other. So instead we track any node that\n                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.\n\n                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates\n                nodes = [];\n                subscribable._addNode = function(node) {\n                    nodes.push(node);\n                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {\n                        ko.utils.arrayRemoveItem(nodes, node);\n                        if (!nodes.length) {\n                            subscribable.dispose();\n                            self._subscribable = subscribable = undefined;\n                        }\n                    });\n                };\n            }\n        }\n    }\n\n    // Extend the binding context hierarchy with a new view model object. If the parent context is watching\n    // any observables, the new child context will automatically get a dependency on the parent context.\n    // But this does not mean that the $data value of the child context will also get updated. If the child\n    // view model also depends on the parent view model, you must provide a function that returns the correct\n    // view model on each update.\n    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {\n        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {\n            // Extend the context hierarchy by setting the appropriate pointers\n            self['$parentContext'] = parentContext;\n            self['$parent'] = parentContext['$data'];\n            self['$parents'] = (parentContext['$parents'] || []).slice(0);\n            self['$parents'].unshift(self['$parent']);\n            if (extendCallback)\n                extendCallback(self);\n        }, options);\n    };\n\n    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.\n    // Similarly to \"child\" contexts, provide a function here to make sure that the correct values are set\n    // when an observable view model is updated.\n    ko.bindingContext.prototype['extend'] = function(properties) {\n        // If the parent context references an observable view model, \"_subscribable\" will always be the\n        // latest view model object. If not, \"_subscribable\" isn't set, and we can use the static \"$data\" value.\n        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {\n            // This \"child\" context doesn't directly track a parent observable view model,\n            // so we need to manually set the $rawData value to match the parent.\n            self['$rawData'] = parentContext['$rawData'];\n            ko.utils.extend(self, typeof(properties) == \"function\" ? properties() : properties);\n        });\n    };\n\n    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {\n        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { \"exportDependencies\": true });\n    };\n\n    // Returns the valueAccesor function for a binding value\n    function makeValueAccessor(value) {\n        return function() {\n            return value;\n        };\n    }\n\n    // Returns the value of a valueAccessor function\n    function evaluateValueAccessor(valueAccessor) {\n        return valueAccessor();\n    }\n\n    // Given a function that returns bindings, create and return a new object that contains\n    // binding value-accessors functions. Each accessor function calls the original function\n    // so that it always gets the latest value and all dependencies are captured. This is used\n    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.\n    function makeAccessorsFromFunction(callback) {\n        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {\n            return function() {\n                return callback()[key];\n            };\n        });\n    }\n\n    // Given a bindings function or object, create and return a new object that contains\n    // binding value-accessors functions. This is used by ko.applyBindingsToNode.\n    function makeBindingAccessors(bindings, context, node) {\n        if (typeof bindings === 'function') {\n            return makeAccessorsFromFunction(bindings.bind(null, context, node));\n        } else {\n            return ko.utils.objectMap(bindings, makeValueAccessor);\n        }\n    }\n\n    // This function is used if the binding provider doesn't include a getBindingAccessors function.\n    // It must be called with 'this' set to the provider instance.\n    function getBindingsAndMakeAccessors(node, context) {\n        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));\n    }\n\n    function validateThatBindingIsAllowedForVirtualElements(bindingName) {\n        var validator = ko.virtualElements.allowedBindings[bindingName];\n        if (!validator)\n            throw new Error(\"The binding '\" + bindingName + \"' cannot be used with virtual elements\")\n    }\n\n    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {\n        var currentChild,\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),\n            provider = ko.bindingProvider['instance'],\n            preprocessNode = provider['preprocessNode'];\n\n        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's\n        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to\n        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that\n        // trigger insertion of <template> contents at that point in the document.\n        if (preprocessNode) {\n            while (currentChild = nextInQueue) {\n                nextInQueue = ko.virtualElements.nextSibling(currentChild);\n                preprocessNode.call(provider, currentChild);\n            }\n            // Reset nextInQueue for the next loop\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);\n        }\n\n        while (currentChild = nextInQueue) {\n            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n            nextInQueue = ko.virtualElements.nextSibling(currentChild);\n            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);\n        }\n    }\n\n    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {\n        var shouldBindDescendants = true;\n\n        // Perf optimisation: Apply bindings only if...\n        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)\n        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those\n        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n        var isElement = (nodeVerified.nodeType === 1);\n        if (isElement) // Workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);\n\n        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)\n                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)\n        if (shouldApplyBindings)\n            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];\n\n        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {\n            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n            //    hence bindingContextsMayDifferFromDomParentElement is false\n            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n            //    hence bindingContextsMayDifferFromDomParentElement is true\n            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);\n        }\n    }\n\n    var boundElementDomDataKey = ko.utils.domData.nextKey();\n\n\n    function topologicalSortBindings(bindings) {\n        // Depth-first sort\n        var result = [],                // The list of key/handler pairs that we will return\n            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'\n            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {\n            if (!bindingsConsidered[bindingKey]) {\n                var binding = ko['getBindingHandler'](bindingKey);\n                if (binding) {\n                    // First add dependencies (if any) of the current binding\n                    if (binding['after']) {\n                        cyclicDependencyStack.push(bindingKey);\n                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {\n                            if (bindings[bindingDependencyKey]) {\n                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n                                    throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \" + cyclicDependencyStack.join(\", \"));\n                                } else {\n                                    pushBinding(bindingDependencyKey);\n                                }\n                            }\n                        });\n                        cyclicDependencyStack.length--;\n                    }\n                    // Next add the current binding\n                    result.push({ key: bindingKey, handler: binding });\n                }\n                bindingsConsidered[bindingKey] = true;\n            }\n        });\n\n        return result;\n    }\n\n    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {\n        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified\n        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);\n        if (!sourceBindings) {\n            if (alreadyBound) {\n                throw Error(\"You cannot apply bindings multiple times to the same element.\");\n            }\n            ko.utils.domData.set(node, boundElementDomDataKey, true);\n        }\n\n        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because\n        // we can easily recover it just by scanning up the node's ancestors in the DOM\n        // (note: here, parent node means \"real DOM parent\" not \"virtual parent\", as there's no O(1) way to find the virtual parent)\n        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)\n            ko.storedBindingContextForNode(node, bindingContext);\n\n        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n        var bindings;\n        if (sourceBindings && typeof sourceBindings !== 'function') {\n            bindings = sourceBindings;\n        } else {\n            var provider = ko.bindingProvider['instance'],\n                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;\n\n            // Get the binding from the provider within a computed observable so that we can update the bindings whenever\n            // the binding context is updated or if the binding provider accesses observables.\n            var bindingsUpdater = ko.dependentObservable(\n                function() {\n                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);\n                    // Register a dependency on the binding context to support observable view models.\n                    if (bindings && bindingContext._subscribable)\n                        bindingContext._subscribable();\n                    return bindings;\n                },\n                null, { disposeWhenNodeIsRemoved: node }\n            );\n\n            if (!bindings || !bindingsUpdater.isActive())\n                bindingsUpdater = null;\n        }\n\n        var bindingHandlerThatControlsDescendantBindings;\n        if (bindings) {\n            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding\n            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets\n            // the latest binding value and registers a dependency on the binding updater.\n            var getValueAccessor = bindingsUpdater\n                ? function(bindingKey) {\n                    return function() {\n                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);\n                    };\n                } : function(bindingKey) {\n                    return bindings[bindingKey];\n                };\n\n            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated\n            function allBindings() {\n                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);\n            }\n            // The following is the 3.x allBindings API\n            allBindings['get'] = function(key) {\n                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));\n            };\n            allBindings['has'] = function(key) {\n                return key in bindings;\n            };\n\n            // First put the bindings into the right order\n            var orderedBindings = topologicalSortBindings(bindings);\n\n            // Go through the sorted bindings, calling init and update for each\n            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {\n                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,\n                // so bindingKeyAndHandler.handler will always be nonnull.\n                var handlerInitFn = bindingKeyAndHandler.handler[\"init\"],\n                    handlerUpdateFn = bindingKeyAndHandler.handler[\"update\"],\n                    bindingKey = bindingKeyAndHandler.key;\n\n                if (node.nodeType === 8) {\n                    validateThatBindingIsAllowedForVirtualElements(bindingKey);\n                }\n\n                try {\n                    // Run init, ignoring any dependencies\n                    if (typeof handlerInitFn == \"function\") {\n                        ko.dependencyDetection.ignore(function() {\n                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n\n                            // If this binding handler claims to control descendant bindings, make a note of this\n                            if (initResult && initResult['controlsDescendantBindings']) {\n                                if (bindingHandlerThatControlsDescendantBindings !== undefined)\n                                    throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n                                bindingHandlerThatControlsDescendantBindings = bindingKey;\n                            }\n                        });\n                    }\n\n                    // Run update in its own computed wrapper\n                    if (typeof handlerUpdateFn == \"function\") {\n                        ko.dependentObservable(\n                            function() {\n                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n                            },\n                            null,\n                            { disposeWhenNodeIsRemoved: node }\n                        );\n                    }\n                } catch (ex) {\n                    ex.message = \"Unable to process binding \\\"\" + bindingKey + \": \" + bindings[bindingKey] + \"\\\"\\nMessage: \" + ex.message;\n                    throw ex;\n                }\n            });\n        }\n\n        return {\n            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined\n        };\n    };\n\n    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();\n    ko.storedBindingContextForNode = function (node, bindingContext) {\n        if (arguments.length == 2) {\n            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);\n            if (bindingContext._subscribable)\n                bindingContext._subscribable._addNode(node);\n        } else {\n            return ko.utils.domData.get(node, storedBindingContextDomDataKey);\n        }\n    }\n\n    function getBindingContext(viewModelOrBindingContext) {\n        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)\n            ? viewModelOrBindingContext\n            : new ko.bindingContext(viewModelOrBindingContext);\n    }\n\n    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {\n        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(node);\n        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);\n    };\n\n    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {\n        var context = getBindingContext(viewModelOrBindingContext);\n        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);\n    };\n\n    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {\n        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)\n            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {\n        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.\n        if (!jQueryInstance && window['jQuery']) {\n            jQueryInstance = window['jQuery'];\n        }\n\n        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))\n            throw new Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");\n        rootNode = rootNode || window.document.body; // Make \"rootNode\" parameter optional\n\n        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    // Retrieving binding context from arbitrary nodes\n    ko.contextFor = function(node) {\n        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n        switch (node.nodeType) {\n            case 1:\n            case 8:\n                var context = ko.storedBindingContextForNode(node);\n                if (context) return context;\n                if (node.parentNode) return ko.contextFor(node.parentNode);\n                break;\n        }\n        return undefined;\n    };\n    ko.dataFor = function(node) {\n        var context = ko.contextFor(node);\n        return context ? context['$data'] : undefined;\n    };\n\n    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);\n    ko.exportSymbol('applyBindings', ko.applyBindings);\n    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);\n    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);\n    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);\n    ko.exportSymbol('contextFor', ko.contextFor);\n    ko.exportSymbol('dataFor', ko.dataFor);\n})();\n(function(undefined) {\n    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight\n        loadedDefinitionsCache = {};    // Tracks component loads that have already completed\n\n    ko.components = {\n        get: function(componentName, callback) {\n            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);\n            if (cachedDefinition) {\n                // It's already loaded and cached. Reuse the same definition object.\n                // Note that for API consistency, even cache hits complete asynchronously by default.\n                // You can bypass this by putting synchronous:true on your component config.\n                if (cachedDefinition.isSynchronousComponent) {\n                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning\n                        callback(cachedDefinition.definition);\n                    });\n                } else {\n                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });\n                }\n            } else {\n                // Join the loading process that is already underway, or start a new one.\n                loadComponentAndNotify(componentName, callback);\n            }\n        },\n\n        clearCachedDefinition: function(componentName) {\n            delete loadedDefinitionsCache[componentName];\n        },\n\n        _getFirstResultFromLoaders: getFirstResultFromLoaders\n    };\n\n    function getObjectOwnProperty(obj, propName) {\n        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n    }\n\n    function loadComponentAndNotify(componentName, callback) {\n        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),\n            completedAsync;\n        if (!subscribable) {\n            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.\n            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();\n            subscribable.subscribe(callback);\n\n            beginLoadingComponent(componentName, function(definition, config) {\n                var isSynchronousComponent = !!(config && config['synchronous']);\n                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };\n                delete loadingSubscribablesCache[componentName];\n\n                // For API consistency, all loads complete asynchronously. However we want to avoid\n                // adding an extra task schedule if it's unnecessary (i.e., the completion is already\n                // async).\n                //\n                // You can bypass the 'always asynchronous' feature by putting the synchronous:true\n                // flag on your component configuration when you register it.\n                if (completedAsync || isSynchronousComponent) {\n                    // Note that notifySubscribers ignores any dependencies read within the callback.\n                    // See comment in loaderRegistryBehaviors.js for reasoning\n                    subscribable['notifySubscribers'](definition);\n                } else {\n                    ko.tasks.schedule(function() {\n                        subscribable['notifySubscribers'](definition);\n                    });\n                }\n            });\n            completedAsync = true;\n        } else {\n            subscribable.subscribe(callback);\n        }\n    }\n\n    function beginLoadingComponent(componentName, callback) {\n        getFirstResultFromLoaders('getConfig', [componentName], function(config) {\n            if (config) {\n                // We have a config, so now load its definition\n                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {\n                    callback(definition, config);\n                });\n            } else {\n                // The component has no config - it's unknown to all the loaders.\n                // Note that this is not an error (e.g., a module loading error) - that would abort the\n                // process and this callback would not run. For this callback to run, all loaders must\n                // have confirmed they don't know about this component.\n                callback(null, null);\n            }\n        });\n    }\n\n    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {\n        // On the first call in the stack, start with the full set of loaders\n        if (!candidateLoaders) {\n            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array\n        }\n\n        // Try the next candidate\n        var currentCandidateLoader = candidateLoaders.shift();\n        if (currentCandidateLoader) {\n            var methodInstance = currentCandidateLoader[methodName];\n            if (methodInstance) {\n                var wasAborted = false,\n                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {\n                        if (wasAborted) {\n                            callback(null);\n                        } else if (result !== null) {\n                            // This candidate returned a value. Use it.\n                            callback(result);\n                        } else {\n                            // Try the next candidate\n                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n                        }\n                    }));\n\n                // Currently, loaders may not return anything synchronously. This leaves open the possibility\n                // that we'll extend the API to support synchronous return values in the future. It won't be\n                // a breaking change, because currently no loader is allowed to return anything except undefined.\n                if (synchronousReturnValue !== undefined) {\n                    wasAborted = true;\n\n                    // Method to suppress exceptions will remain undocumented. This is only to keep\n                    // KO's specs running tidily, since we can observe the loading got aborted without\n                    // having exceptions cluttering up the console too.\n                    if (!currentCandidateLoader['suppressLoaderExceptions']) {\n                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');\n                    }\n                }\n            } else {\n                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.\n                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n            }\n        } else {\n            // No candidates returned a value\n            callback(null);\n        }\n    }\n\n    // Reference the loaders via string name so it's possible for developers\n    // to replace the whole array by assigning to ko.components.loaders\n    ko.components['loaders'] = [];\n\n    ko.exportSymbol('components', ko.components);\n    ko.exportSymbol('components.get', ko.components.get);\n    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);\n})();\n(function(undefined) {\n\n    // The default loader is responsible for two things:\n    // 1. Maintaining the default in-memory registry of component configuration objects\n    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))\n    // 2. Answering requests for components by fetching configuration objects\n    //    from that default in-memory registry and resolving them into standard\n    //    component definition objects (of the form { createViewModel: ..., template: ... })\n    // Custom loaders may override either of these facilities, i.e.,\n    // 1. To supply configuration objects from some other source (e.g., conventions)\n    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.\n\n    var defaultConfigRegistry = {};\n\n    ko.components.register = function(componentName, config) {\n        if (!config) {\n            throw new Error('Invalid configuration for ' + componentName);\n        }\n\n        if (ko.components.isRegistered(componentName)) {\n            throw new Error('Component ' + componentName + ' is already registered');\n        }\n\n        defaultConfigRegistry[componentName] = config;\n    };\n\n    ko.components.isRegistered = function(componentName) {\n        return defaultConfigRegistry.hasOwnProperty(componentName);\n    };\n\n    ko.components.unregister = function(componentName) {\n        delete defaultConfigRegistry[componentName];\n        ko.components.clearCachedDefinition(componentName);\n    };\n\n    ko.components.defaultLoader = {\n        'getConfig': function(componentName, callback) {\n            var result = defaultConfigRegistry.hasOwnProperty(componentName)\n                ? defaultConfigRegistry[componentName]\n                : null;\n            callback(result);\n        },\n\n        'loadComponent': function(componentName, config, callback) {\n            var errorCallback = makeErrorCallback(componentName);\n            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {\n                resolveConfig(componentName, errorCallback, loadedConfig, callback);\n            });\n        },\n\n        'loadTemplate': function(componentName, templateConfig, callback) {\n            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);\n        },\n\n        'loadViewModel': function(componentName, viewModelConfig, callback) {\n            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);\n        }\n    };\n\n    var createViewModelKey = 'createViewModel';\n\n    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it\n    // into the standard component definition format:\n    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.\n    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed\n    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,\n    // so this is implemented manually below.\n    function resolveConfig(componentName, errorCallback, config, callback) {\n        var result = {},\n            makeCallBackWhenZero = 2,\n            tryIssueCallback = function() {\n                if (--makeCallBackWhenZero === 0) {\n                    callback(result);\n                }\n            },\n            templateConfig = config['template'],\n            viewModelConfig = config['viewModel'];\n\n        if (templateConfig) {\n            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {\n                    result['template'] = resolvedTemplate;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n\n        if (viewModelConfig) {\n            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {\n                    result[createViewModelKey] = resolvedViewModel;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n    }\n\n    function resolveTemplate(errorCallback, templateConfig, callback) {\n        if (typeof templateConfig === 'string') {\n            // Markup - parse it\n            callback(ko.utils.parseHtmlFragment(templateConfig));\n        } else if (templateConfig instanceof Array) {\n            // Assume already an array of DOM nodes - pass through unchanged\n            callback(templateConfig);\n        } else if (isDocumentFragment(templateConfig)) {\n            // Document fragment - use its child nodes\n            callback(ko.utils.makeArray(templateConfig.childNodes));\n        } else if (templateConfig['element']) {\n            var element = templateConfig['element'];\n            if (isDomElement(element)) {\n                // Element instance - copy its child nodes\n                callback(cloneNodesFromTemplateSourceElement(element));\n            } else if (typeof element === 'string') {\n                // Element ID - find it, then copy its child nodes\n                var elemInstance = document.getElementById(element);\n                if (elemInstance) {\n                    callback(cloneNodesFromTemplateSourceElement(elemInstance));\n                } else {\n                    errorCallback('Cannot find element with ID ' + element);\n                }\n            } else {\n                errorCallback('Unknown element type: ' + element);\n            }\n        } else {\n            errorCallback('Unknown template value: ' + templateConfig);\n        }\n    }\n\n    function resolveViewModel(errorCallback, viewModelConfig, callback) {\n        if (typeof viewModelConfig === 'function') {\n            // Constructor - convert to standard factory function format\n            // By design, this does *not* supply componentInfo to the constructor, as the intent is that\n            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only\n            // be used in factory functions, not viewmodel constructors.\n            callback(function (params /*, componentInfo */) {\n                return new viewModelConfig(params);\n            });\n        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {\n            // Already a factory function - use it as-is\n            callback(viewModelConfig[createViewModelKey]);\n        } else if ('instance' in viewModelConfig) {\n            // Fixed object instance - promote to createViewModel format for API consistency\n            var fixedInstance = viewModelConfig['instance'];\n            callback(function (params, componentInfo) {\n                return fixedInstance;\n            });\n        } else if ('viewModel' in viewModelConfig) {\n            // Resolved AMD module whose value is of the form { viewModel: ... }\n            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);\n        } else {\n            errorCallback('Unknown viewModel value: ' + viewModelConfig);\n        }\n    }\n\n    function cloneNodesFromTemplateSourceElement(elemInstance) {\n        switch (ko.utils.tagNameLower(elemInstance)) {\n            case 'script':\n                return ko.utils.parseHtmlFragment(elemInstance.text);\n            case 'textarea':\n                return ko.utils.parseHtmlFragment(elemInstance.value);\n            case 'template':\n                // For browsers with proper <template> element support (i.e., where the .content property\n                // gives a document fragment), use that document fragment.\n                if (isDocumentFragment(elemInstance.content)) {\n                    return ko.utils.cloneNodes(elemInstance.content.childNodes);\n                }\n        }\n\n        // Regular elements such as <div>, and <template> elements on old browsers that don't really\n        // understand <template> and just treat it as a regular container\n        return ko.utils.cloneNodes(elemInstance.childNodes);\n    }\n\n    function isDomElement(obj) {\n        if (window['HTMLElement']) {\n            return obj instanceof HTMLElement;\n        } else {\n            return obj && obj.tagName && obj.nodeType === 1;\n        }\n    }\n\n    function isDocumentFragment(obj) {\n        if (window['DocumentFragment']) {\n            return obj instanceof DocumentFragment;\n        } else {\n            return obj && obj.nodeType === 11;\n        }\n    }\n\n    function possiblyGetConfigFromAmd(errorCallback, config, callback) {\n        if (typeof config['require'] === 'string') {\n            // The config is the value of an AMD module\n            if (amdRequire || window['require']) {\n                (amdRequire || window['require'])([config['require']], callback);\n            } else {\n                errorCallback('Uses require, but no AMD loader is present');\n            }\n        } else {\n            callback(config);\n        }\n    }\n\n    function makeErrorCallback(componentName) {\n        return function (message) {\n            throw new Error('Component \\'' + componentName + '\\': ' + message);\n        };\n    }\n\n    ko.exportSymbol('components.register', ko.components.register);\n    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);\n    ko.exportSymbol('components.unregister', ko.components.unregister);\n\n    // Expose the default loader so that developers can directly ask it for configuration\n    // or to resolve configuration\n    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);\n\n    // By default, the default loader is the only registered component loader\n    ko.components['loaders'].push(ko.components.defaultLoader);\n\n    // Privately expose the underlying config registry for use in old-IE shim\n    ko.components._allRegisteredComponents = defaultConfigRegistry;\n})();\n(function (undefined) {\n    // Overridable API for determining which component name applies to a given node. By overriding this,\n    // you can for example map specific tagNames to components that are not preregistered.\n    ko.components['getComponentNameForNode'] = function(node) {\n        var tagNameLower = ko.utils.tagNameLower(node);\n        if (ko.components.isRegistered(tagNameLower)) {\n            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603\n            if (tagNameLower.indexOf('-') != -1 || ('' + node) == \"[object HTMLUnknownElement]\" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {\n                return tagNameLower;\n            }\n        }\n    };\n\n    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {\n        // Determine if it's really a custom element matching a component\n        if (node.nodeType === 1) {\n            var componentName = ko.components['getComponentNameForNode'](node);\n            if (componentName) {\n                // It does represent a component, so add a component binding for it\n                allBindings = allBindings || {};\n\n                if (allBindings['component']) {\n                    // Avoid silently overwriting some other 'component' binding that may already be on the element\n                    throw new Error('Cannot use the \"component\" binding on a custom element matching a component');\n                }\n\n                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };\n\n                allBindings['component'] = valueAccessors\n                    ? function() { return componentBindingValue; }\n                    : componentBindingValue;\n            }\n        }\n\n        return allBindings;\n    }\n\n    var nativeBindingProviderInstance = new ko.bindingProvider();\n\n    function getComponentParamsFromCustomElement(elem, bindingContext) {\n        var paramsAttribute = elem.getAttribute('params');\n\n        if (paramsAttribute) {\n            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),\n                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {\n                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });\n                }),\n                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {\n                    var paramValue = paramValueComputed.peek();\n                    // Does the evaluation of the parameter value unwrap any observables?\n                    if (!paramValueComputed.isActive()) {\n                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.\n                        // Example: \"someVal: firstName, age: 123\" (whether or not firstName is an observable/computed)\n                        return paramValue;\n                    } else {\n                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)\n                        // level of observability, and any inner (resulting model value) level of observability.\n                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a\n                        // writable observable, the computed will also be writable and pass the value on to the observable.\n                        return ko.computed({\n                            'read': function() {\n                                return ko.utils.unwrapObservable(paramValueComputed());\n                            },\n                            'write': ko.isWriteableObservable(paramValue) && function(value) {\n                                paramValueComputed()(value);\n                            },\n                            disposeWhenNodeIsRemoved: elem\n                        });\n                    }\n                });\n\n            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'\n            // This is in case the developer wants to react to outer (binding) observability separately from inner\n            // (model value) observability, or in case the model value observable has subobservables.\n            if (!result.hasOwnProperty('$raw')) {\n                result['$raw'] = rawParamComputedValues;\n            }\n\n            return result;\n        } else {\n            // For consistency, absence of a \"params\" attribute is treated the same as the presence of\n            // any empty one. Otherwise component viewmodels need special code to check whether or not\n            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.\n            return { '$raw': {} };\n        }\n    }\n\n    // --------------------------------------------------------------------------------\n    // Compatibility code for older (pre-HTML5) IE browsers\n\n    if (ko.utils.ieVersion < 9) {\n        // Whenever you preregister a component, enable it as a custom element in the current document\n        ko.components['register'] = (function(originalFunction) {\n            return function(componentName) {\n                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element\n                return originalFunction.apply(this, arguments);\n            }\n        })(ko.components['register']);\n\n        // Whenever you create a document fragment, enable all preregistered component names as custom elements\n        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements\n        document.createDocumentFragment = (function(originalFunction) {\n            return function() {\n                var newDocFrag = originalFunction(),\n                    allComponents = ko.components._allRegisteredComponents;\n                for (var componentName in allComponents) {\n                    if (allComponents.hasOwnProperty(componentName)) {\n                        newDocFrag.createElement(componentName);\n                    }\n                }\n                return newDocFrag;\n            };\n        })(document.createDocumentFragment);\n    }\n})();(function(undefined) {\n\n    var componentLoadingOperationUniqueId = 0;\n\n    ko.bindingHandlers['component'] = {\n        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {\n            var currentViewModel,\n                currentLoadingOperationId,\n                disposeAssociatedComponentViewModel = function () {\n                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];\n                    if (typeof currentViewModelDispose === 'function') {\n                        currentViewModelDispose.call(currentViewModel);\n                    }\n                    currentViewModel = null;\n                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion\n                    currentLoadingOperationId = null;\n                },\n                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));\n\n            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);\n\n            ko.computed(function () {\n                var value = ko.utils.unwrapObservable(valueAccessor()),\n                    componentName, componentParams;\n\n                if (typeof value === 'string') {\n                    componentName = value;\n                } else {\n                    componentName = ko.utils.unwrapObservable(value['name']);\n                    componentParams = ko.utils.unwrapObservable(value['params']);\n                }\n\n                if (!componentName) {\n                    throw new Error('No component name specified');\n                }\n\n                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;\n                ko.components.get(componentName, function(componentDefinition) {\n                    // If this is not the current load operation for this element, ignore it.\n                    if (currentLoadingOperationId !== loadingOperationId) {\n                        return;\n                    }\n\n                    // Clean up previous state\n                    disposeAssociatedComponentViewModel();\n\n                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.\n                    if (!componentDefinition) {\n                        throw new Error('Unknown component \\'' + componentName + '\\'');\n                    }\n                    cloneTemplateIntoElement(componentName, componentDefinition, element);\n                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),\n                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {\n                            ctx['$component'] = componentViewModel;\n                            ctx['$componentTemplateNodes'] = originalChildNodes;\n                        });\n                    currentViewModel = componentViewModel;\n                    ko.applyBindingsToDescendants(childBindingContext, element);\n                });\n            }, null, { disposeWhenNodeIsRemoved: element });\n\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n\n    ko.virtualElements.allowedBindings['component'] = true;\n\n    function cloneTemplateIntoElement(componentName, componentDefinition, element) {\n        var template = componentDefinition['template'];\n        if (!template) {\n            throw new Error('Component \\'' + componentName + '\\' has no template');\n        }\n\n        var clonedNodesArray = ko.utils.cloneNodes(template);\n        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);\n    }\n\n    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {\n        var componentViewModelFactory = componentDefinition['createViewModel'];\n        return componentViewModelFactory\n            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })\n            : componentParams; // Template-only component\n    }\n\n})();\nvar attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };\nko.bindingHandlers['attr'] = {\n    'update': function(element, valueAccessor, allBindings) {\n        var value = ko.utils.unwrapObservable(valueAccessor()) || {};\n        ko.utils.objectForEach(value, function(attrName, attrValue) {\n            attrValue = ko.utils.unwrapObservable(attrValue);\n\n            // To cover cases like \"attr: { checked:someProp }\", we want to remove the attribute entirely\n            // when someProp is a \"no value\"-like value (strictly null, false, or undefined)\n            // (because the absence of the \"checked\" attr is how to mark an element as not checked, etc.)\n            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);\n            if (toRemove)\n                element.removeAttribute(attrName);\n\n            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the\n            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,\n            // but instead of figuring out the mode, we'll just set the attribute through the Javascript\n            // property for IE <= 8.\n            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {\n                attrName = attrHtmlToJavascriptMap[attrName];\n                if (toRemove)\n                    element.removeAttribute(attrName);\n                else\n                    element[attrName] = attrValue;\n            } else if (!toRemove) {\n                element.setAttribute(attrName, attrValue.toString());\n            }\n\n            // Treat \"name\" specially - although you can think of it as an attribute, it also needs\n            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)\n            // Deliberately being case-sensitive here because XHTML would regard \"Name\" as a different thing\n            // entirely, and there's no strong reason to allow for such casing in HTML.\n            if (attrName === \"name\") {\n                ko.utils.setElementName(element, toRemove ? \"\" : attrValue.toString());\n            }\n        });\n    }\n};\n(function() {\n\nko.bindingHandlers['checked'] = {\n    'after': ['value', 'attr'],\n    'init': function (element, valueAccessor, allBindings) {\n        var checkedValue = ko.pureComputed(function() {\n            // Treat \"value\" like \"checkedValue\" when it is included with \"checked\" binding\n            if (allBindings['has']('checkedValue')) {\n                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));\n            } else if (allBindings['has']('value')) {\n                return ko.utils.unwrapObservable(allBindings.get('value'));\n            }\n\n            return element.value;\n        });\n\n        function updateModel() {\n            // This updates the model value from the view value.\n            // It runs in response to DOM events (click) and changes in checkedValue.\n            var isChecked = element.checked,\n                elemValue = useCheckedValue ? checkedValue() : isChecked;\n\n            // When we're first setting up this computed, don't change any model state.\n            if (ko.computedContext.isInitial()) {\n                return;\n            }\n\n            // We can ignore unchecked radio buttons, because some other radio\n            // button will be getting checked, and that one can take care of updating state.\n            if (isRadio && !isChecked) {\n                return;\n            }\n\n            var modelValue = ko.dependencyDetection.ignore(valueAccessor);\n            if (valueIsArray) {\n                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;\n                if (oldElemValue !== elemValue) {\n                    // When we're responding to the checkedValue changing, and the element is\n                    // currently checked, replace the old elem value with the new elem value\n                    // in the model array.\n                    if (isChecked) {\n                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);\n                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);\n                    }\n\n                    oldElemValue = elemValue;\n                } else {\n                    // When we're responding to the user having checked/unchecked a checkbox,\n                    // add/remove the element value to the model array.\n                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);\n                }\n                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {\n                    modelValue(writableValue);\n                }\n            } else {\n                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);\n            }\n        };\n\n        function updateView() {\n            // This updates the view value from the model value.\n            // It runs in response to changes in the bound (checked) value.\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (valueIsArray) {\n                // When a checkbox is bound to an array, being checked represents its value being present in that array\n                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;\n            } else if (isCheckbox) {\n                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish\n                element.checked = modelValue;\n            } else {\n                // For radio buttons, being checked means that the radio button's value corresponds to the model value\n                element.checked = (checkedValue() === modelValue);\n            }\n        };\n\n        var isCheckbox = element.type == \"checkbox\",\n            isRadio = element.type == \"radio\";\n\n        // Only bind to check boxes and radio buttons\n        if (!isCheckbox && !isRadio) {\n            return;\n        }\n\n        var rawValue = valueAccessor(),\n            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),\n            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),\n            oldElemValue = valueIsArray ? checkedValue() : undefined,\n            useCheckedValue = isRadio || valueIsArray;\n\n        // IE 6 won't allow radio buttons to be selected unless they have a name\n        if (isRadio && !element.name)\n            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });\n\n        // Set up two computeds to update the binding:\n\n        // The first responds to changes in the checkedValue value and to element clicks\n        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });\n        ko.utils.registerEventHandler(element, \"click\", updateModel);\n\n        // The second responds to changes in the model value (the one associated with the checked binding)\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n\n        rawValue = undefined;\n    }\n};\nko.expressionRewriting.twoWayBindings['checked'] = true;\n\nko.bindingHandlers['checkedValue'] = {\n    'update': function (element, valueAccessor) {\n        element.value = ko.utils.unwrapObservable(valueAccessor());\n    }\n};\n\n})();var classesWrittenByBindingKey = '__ko__cssValue';\nko.bindingHandlers['css'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value !== null && typeof value == \"object\") {\n            ko.utils.objectForEach(value, function(className, shouldHaveClass) {\n                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);\n                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);\n            });\n        } else {\n            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value\n            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);\n            element[classesWrittenByBindingKey] = value;\n            ko.utils.toggleDomNodeCssClass(element, value, true);\n        }\n    }\n};\nko.bindingHandlers['enable'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value && element.disabled)\n            element.removeAttribute(\"disabled\");\n        else if ((!value) && (!element.disabled))\n            element.disabled = true;\n    }\n};\n\nko.bindingHandlers['disable'] = {\n    'update': function (element, valueAccessor) {\n        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });\n    }\n};\n// For certain common events (currently just 'click'), allow a simplified data-binding syntax\n// e.g. click:handler instead of the usual full-length event:{click:handler}\nfunction makeEventHandlerShortcut(eventName) {\n    ko.bindingHandlers[eventName] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var newValueAccessor = function () {\n                var result = {};\n                result[eventName] = valueAccessor();\n                return result;\n            };\n            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);\n        }\n    }\n}\n\nko.bindingHandlers['event'] = {\n    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var eventsToHandle = valueAccessor() || {};\n        ko.utils.objectForEach(eventsToHandle, function(eventName) {\n            if (typeof eventName == \"string\") {\n                ko.utils.registerEventHandler(element, eventName, function (event) {\n                    var handlerReturnValue;\n                    var handlerFunction = valueAccessor()[eventName];\n                    if (!handlerFunction)\n                        return;\n\n                    try {\n                        // Take all the event args, and prefix with the viewmodel\n                        var argsForHandler = ko.utils.makeArray(arguments);\n                        viewModel = bindingContext['$data'];\n                        argsForHandler.unshift(viewModel);\n                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);\n                    } finally {\n                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                            if (event.preventDefault)\n                                event.preventDefault();\n                            else\n                                event.returnValue = false;\n                        }\n                    }\n\n                    var bubble = allBindings.get(eventName + 'Bubble') !== false;\n                    if (!bubble) {\n                        event.cancelBubble = true;\n                        if (event.stopPropagation)\n                            event.stopPropagation();\n                    }\n                });\n            }\n        });\n    }\n};\n// \"foreach: someExpression\" is equivalent to \"template: { foreach: someExpression }\"\n// \"foreach: { data: someExpression, afterAdd: myfn }\" is equivalent to \"template: { foreach: someExpression, afterAdd: myfn }\"\nko.bindingHandlers['foreach'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() {\n            var modelValue = valueAccessor(),\n                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here\n\n            // If unwrappedValue is the array, pass in the wrapped value on its own\n            // The value will be unwrapped and tracked within the template binding\n            // (See https://github.com/SteveSanderson/knockout/issues/523)\n            if ((!unwrappedValue) || typeof unwrappedValue.length == \"number\")\n                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };\n\n            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates\n            ko.utils.unwrapObservable(modelValue);\n            return {\n                'foreach': unwrappedValue['data'],\n                'as': unwrappedValue['as'],\n                'includeDestroyed': unwrappedValue['includeDestroyed'],\n                'afterAdd': unwrappedValue['afterAdd'],\n                'beforeRemove': unwrappedValue['beforeRemove'],\n                'afterRender': unwrappedValue['afterRender'],\n                'beforeMove': unwrappedValue['beforeMove'],\n                'afterMove': unwrappedValue['afterMove'],\n                'templateEngine': ko.nativeTemplateEngine.instance\n            };\n        };\n    },\n    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);\n    }\n};\nko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['foreach'] = true;\nvar hasfocusUpdatingProperty = '__ko_hasfocusUpdating';\nvar hasfocusLastValue = '__ko_hasfocusLastValue';\nko.bindingHandlers['hasfocus'] = {\n    'init': function(element, valueAccessor, allBindings) {\n        var handleElementFocusChange = function(isFocused) {\n            // Where possible, ignore which event was raised and determine focus state using activeElement,\n            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.\n            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,\n            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus\n            // from calling 'blur()' on the element when it loses focus.\n            // Discussion at https://github.com/SteveSanderson/knockout/pull/352\n            element[hasfocusUpdatingProperty] = true;\n            var ownerDoc = element.ownerDocument;\n            if (\"activeElement\" in ownerDoc) {\n                var active;\n                try {\n                    active = ownerDoc.activeElement;\n                } catch(e) {\n                    // IE9 throws if you access activeElement during page load (see issue #703)\n                    active = ownerDoc.body;\n                }\n                isFocused = (active === element);\n            }\n            var modelValue = valueAccessor();\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);\n\n            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function\n            element[hasfocusLastValue] = isFocused;\n            element[hasfocusUpdatingProperty] = false;\n        };\n        var handleElementFocusIn = handleElementFocusChange.bind(null, true);\n        var handleElementFocusOut = handleElementFocusChange.bind(null, false);\n\n        ko.utils.registerEventHandler(element, \"focus\", handleElementFocusIn);\n        ko.utils.registerEventHandler(element, \"focusin\", handleElementFocusIn); // For IE\n        ko.utils.registerEventHandler(element, \"blur\",  handleElementFocusOut);\n        ko.utils.registerEventHandler(element, \"focusout\",  handleElementFocusOut); // For IE\n    },\n    'update': function(element, valueAccessor) {\n        var value = !!ko.utils.unwrapObservable(valueAccessor());\n\n        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {\n            value ? element.focus() : element.blur();\n\n            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).\n            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current\n            // element was focused already.\n            if (!value && element[hasfocusLastValue]) {\n                element.ownerDocument.body.focus();\n            }\n\n            // For IE, which doesn't reliably fire \"focus\" or \"blur\" events synchronously\n            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? \"focusin\" : \"focusout\"]);\n        }\n    }\n};\nko.expressionRewriting.twoWayBindings['hasfocus'] = true;\n\nko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make \"hasFocus\" an alias\nko.expressionRewriting.twoWayBindings['hasFocus'] = true;\nko.bindingHandlers['html'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        // setHtml will unwrap the value if needed\n        ko.utils.setHtml(element, valueAccessor());\n    }\n};\n// Makes a binding like with or if\nfunction makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {\n    ko.bindingHandlers[bindingKey] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var didDisplayOnLastUpdate,\n                savedNodes;\n            ko.computed(function() {\n                var rawValue = valueAccessor(),\n                    dataValue = ko.utils.unwrapObservable(rawValue),\n                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue\n                    isFirstRender = !savedNodes,\n                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);\n\n                if (needsRefresh) {\n                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.\n                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {\n                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);\n                    }\n\n                    if (shouldDisplay) {\n                        if (!isFirstRender) {\n                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));\n                        }\n                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);\n                    } else {\n                        ko.virtualElements.emptyNode(element);\n                    }\n\n                    didDisplayOnLastUpdate = shouldDisplay;\n                }\n            }, null, { disposeWhenNodeIsRemoved: element });\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings\n    ko.virtualElements.allowedBindings[bindingKey] = true;\n}\n\n// Construct the actual binding handlers\nmakeWithIfBinding('if');\nmakeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);\nmakeWithIfBinding('with', true /* isWith */, false /* isNot */,\n    function(bindingContext, dataValue) {\n        return bindingContext.createStaticChildContext(dataValue);\n    }\n);\nvar captionPlaceholder = {};\nko.bindingHandlers['options'] = {\n    'init': function(element) {\n        if (ko.utils.tagNameLower(element) !== \"select\")\n            throw new Error(\"options binding applies only to SELECT elements\");\n\n        // Remove all existing <option>s.\n        while (element.length > 0) {\n            element.remove(0);\n        }\n\n        // Ensures that the binding processor doesn't try to bind the options\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor, allBindings) {\n        function selectedOptions() {\n            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });\n        }\n\n        var selectWasPreviouslyEmpty = element.length == 0,\n            multiple = element.multiple,\n            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,\n            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),\n            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),\n            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),\n            arrayToDomNodeChildrenOptions = {},\n            captionValue,\n            filteredArray,\n            previousSelectedValues = [];\n\n        if (!valueAllowUnset) {\n            if (multiple) {\n                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);\n            } else if (element.selectedIndex >= 0) {\n                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));\n            }\n        }\n\n        if (unwrappedArray) {\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // If caption is included, add it to the array\n            if (allBindings['has']('optionsCaption')) {\n                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));\n                // If caption value is null or undefined, don't show a caption\n                if (captionValue !== null && captionValue !== undefined) {\n                    filteredArray.unshift(captionPlaceholder);\n                }\n            }\n        } else {\n            // If a falsy value is provided (e.g. null), we'll simply empty the select element\n        }\n\n        function applyToObject(object, predicate, defaultValue) {\n            var predicateType = typeof predicate;\n            if (predicateType == \"function\")    // Given a function; run it against the data value\n                return predicate(object);\n            else if (predicateType == \"string\") // Given a string; treat it as a property name on the data value\n                return object[predicate];\n            else                                // Given no optionsText arg; use the data value itself\n                return defaultValue;\n        }\n\n        // The following functions can run at two different times:\n        // The first is when the whole array is being updated directly from this binding handler.\n        // The second is when an observable value for a specific array entry is updated.\n        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.\n        var itemUpdate = false;\n        function optionForArrayItem(arrayEntry, index, oldOptions) {\n            if (oldOptions.length) {\n                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];\n                itemUpdate = true;\n            }\n            var option = element.ownerDocument.createElement(\"option\");\n            if (arrayEntry === captionPlaceholder) {\n                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));\n                ko.selectExtensions.writeValue(option, undefined);\n            } else {\n                // Apply a value to the option element\n                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);\n                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));\n\n                // Apply some text to the option element\n                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);\n                ko.utils.setTextContent(option, optionText);\n            }\n            return [option];\n        }\n\n        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection\n        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208\n        arrayToDomNodeChildrenOptions['beforeRemove'] =\n            function (option) {\n                element.removeChild(option);\n            };\n\n        function setSelectionCallback(arrayEntry, newOptions) {\n            if (itemUpdate && valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else if (previousSelectedValues.length) {\n                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.\n                // That's why we first added them without selection. Now it's time to set the selection.\n                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;\n                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);\n\n                // If this option was changed from being selected during a single-item update, notify the change\n                if (itemUpdate && !isSelected) {\n                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                }\n            }\n        }\n\n        var callback = setSelectionCallback;\n        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == \"function\") {\n            callback = function(arrayEntry, newOptions) {\n                setSelectionCallback(arrayEntry, newOptions);\n                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);\n            }\n        }\n\n        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);\n\n        ko.dependencyDetection.ignore(function () {\n            if (valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else {\n                // Determine if the selection has changed as a result of updating the options list\n                var selectionChanged;\n                if (multiple) {\n                    // For a multiple-select box, compare the new selection count to the previous one\n                    // But if nothing was selected before, the selection can't have changed\n                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;\n                } else {\n                    // For a single-select box, compare the current value to the previous value\n                    // But if nothing was selected before or nothing is selected now, just look for a change in selection\n                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)\n                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])\n                        : (previousSelectedValues.length || element.selectedIndex >= 0);\n                }\n\n                // Ensure consistency between model value and selected option.\n                // If the dropdown was changed so that selection is no longer the same,\n                // notify the value or selectedOptions binding.\n                if (selectionChanged) {\n                    ko.utils.triggerEvent(element, \"change\");\n                }\n            }\n        });\n\n        // Workaround for IE bug\n        ko.utils.ensureSelectElementIsRenderedCorrectly(element);\n\n        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)\n            element.scrollTop = previousScrollTop;\n    }\n};\nko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();\nko.bindingHandlers['selectedOptions'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        ko.utils.registerEventHandler(element, \"change\", function () {\n            var value = valueAccessor(), valueToWrite = [];\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                if (node.selected)\n                    valueToWrite.push(ko.selectExtensions.readValue(node));\n            });\n            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);\n        });\n    },\n    'update': function (element, valueAccessor) {\n        if (ko.utils.tagNameLower(element) != \"select\")\n            throw new Error(\"values binding applies only to SELECT elements\");\n\n        var newValue = ko.utils.unwrapObservable(valueAccessor()),\n            previousScrollTop = element.scrollTop;\n\n        if (newValue && typeof newValue.length == \"number\") {\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;\n                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE\n                    ko.utils.setOptionNodeSelectionState(node, isSelected);\n                }\n            });\n        }\n\n        element.scrollTop = previousScrollTop;\n    }\n};\nko.expressionRewriting.twoWayBindings['selectedOptions'] = true;\nko.bindingHandlers['style'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor() || {});\n        ko.utils.objectForEach(value, function(styleName, styleValue) {\n            styleValue = ko.utils.unwrapObservable(styleValue);\n\n            if (styleValue === null || styleValue === undefined || styleValue === false) {\n                // Empty string removes the value, whereas null/undefined have no effect\n                styleValue = \"\";\n            }\n\n            element.style[styleName] = styleValue;\n        });\n    }\n};\nko.bindingHandlers['submit'] = {\n    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        if (typeof valueAccessor() != \"function\")\n            throw new Error(\"The value for a submit binding must be a function\");\n        ko.utils.registerEventHandler(element, \"submit\", function (event) {\n            var handlerReturnValue;\n            var value = valueAccessor();\n            try { handlerReturnValue = value.call(bindingContext['$data'], element); }\n            finally {\n                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                    if (event.preventDefault)\n                        event.preventDefault();\n                    else\n                        event.returnValue = false;\n                }\n            }\n        });\n    }\n};\nko.bindingHandlers['text'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).\n        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        ko.utils.setTextContent(element, valueAccessor());\n    }\n};\nko.virtualElements.allowedBindings['text'] = true;\n(function () {\n\nif (window && window.navigator) {\n    var parseVersion = function (matches) {\n        if (matches) {\n            return parseFloat(matches[1]);\n        }\n    };\n\n    // Detect various browser versions because some old versions don't fully support the 'input' event\n    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),\n        userAgent = window.navigator.userAgent,\n        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\\/([^ ]*) safari/i)),\n        firefoxVersion = parseVersion(userAgent.match(/Firefox\\/([^ ]*)/));\n}\n\n// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.\n// But it does fire the 'selectionchange' event on many of those, presumably because the\n// cursor is moving and that counts as the selection changing. The 'selectionchange' event is\n// fired at the document level only and doesn't directly indicate which element changed. We\n// set up just one event handler for the document and use 'activeElement' to determine which\n// element was changed.\nif (ko.utils.ieVersion < 10) {\n    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),\n        selectionChangeHandlerName = ko.utils.domData.nextKey();\n    var selectionChangeHandler = function(event) {\n        var target = this.activeElement,\n            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);\n        if (handler) {\n            handler(event);\n        }\n    };\n    var registerForSelectionChangeEvent = function (element, handler) {\n        var ownerDoc = element.ownerDocument;\n        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {\n            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);\n            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);\n        }\n        ko.utils.domData.set(element, selectionChangeHandlerName, handler);\n    };\n}\n\nko.bindingHandlers['textInput'] = {\n    'init': function (element, valueAccessor, allBindings) {\n\n        var previousElementValue = element.value,\n            timeoutHandle,\n            elementValueBeforeEvent;\n\n        var updateModel = function (event) {\n            clearTimeout(timeoutHandle);\n            elementValueBeforeEvent = timeoutHandle = undefined;\n\n            var elementValue = element.value;\n            if (previousElementValue !== elementValue) {\n                // Provide a way for tests to know exactly which event was processed\n                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;\n                previousElementValue = elementValue;\n                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);\n            }\n        };\n\n        var deferUpdateModel = function (event) {\n            if (!timeoutHandle) {\n                // The elementValueBeforeEvent variable is set *only* during the brief gap between an\n                // event firing and the updateModel function running. This allows us to ignore model\n                // updates that are from the previous state of the element, usually due to techniques\n                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.\n                elementValueBeforeEvent = element.value;\n                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;\n                timeoutHandle = ko.utils.setTimeout(handler, 4);\n            }\n        };\n\n        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);\n        // so we'll make sure all updates are asynchronous\n        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;\n\n        var updateView = function () {\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (modelValue === null || modelValue === undefined) {\n                modelValue = '';\n            }\n\n            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateView, 4);\n                return;\n            }\n\n            // Update the element only if the element and model are different. On some browsers, updating the value\n            // will move the cursor to the end of the input, which would be bad while the user is typing.\n            if (element.value !== modelValue) {\n                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value\n                element.value = modelValue;\n            }\n        };\n\n        var onEvent = function (event, handler) {\n            ko.utils.registerEventHandler(element, event, handler);\n        };\n\n        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {\n            // Provide a way for tests to specify exactly which events are bound\n            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {\n                if (eventName.slice(0,5) == 'after') {\n                    onEvent(eventName.slice(5), deferUpdateModel);\n                } else {\n                    onEvent(eventName, updateModel);\n                }\n            });\n        } else {\n            if (ko.utils.ieVersion < 10) {\n                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever\n                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,\n                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it\n                // when using autocomplete, we'll use 'propertychange' for it also.\n                onEvent('propertychange', function(event) {\n                    if (event.propertyName === 'value') {\n                        ieUpdateModel(event);\n                    }\n                });\n\n                if (ko.utils.ieVersion == 8) {\n                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from\n                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following\n                    // events too.\n                    onEvent('keyup', updateModel);      // A single keystoke\n                    onEvent('keydown', updateModel);    // The first character when a key is held down\n                }\n                if (ko.utils.ieVersion >= 8) {\n                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using\n                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text\n                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'\n                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.\n                    // These are also needed in IE8 because of the bug described above.\n                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.\n                    onEvent('dragend', deferUpdateModel);\n                }\n            } else {\n                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed\n                // through the user interface.\n                onEvent('input', updateModel);\n\n                if (safariVersion < 5 && ko.utils.tagNameLower(element) === \"textarea\") {\n                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'\n                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.\n                    onEvent('keydown', deferUpdateModel);\n                    onEvent('paste', deferUpdateModel);\n                    onEvent('cut', deferUpdateModel);\n                } else if (operaVersion < 11) {\n                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.\n                    // We can try to catch some of those using 'keydown'.\n                    onEvent('keydown', deferUpdateModel);\n                } else if (firefoxVersion < 4.0) {\n                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete\n                    onEvent('DOMAutoComplete', updateModel);\n\n                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.\n                    onEvent('dragdrop', updateModel);       // <3.5\n                    onEvent('drop', updateModel);           // 3.5\n                }\n            }\n        }\n\n        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.\n        onEvent('change', updateModel);\n\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n    }\n};\nko.expressionRewriting.twoWayBindings['textInput'] = true;\n\n// textinput is an alias for textInput\nko.bindingHandlers['textinput'] = {\n    // preprocess is the only way to set up a full alias\n    'preprocess': function (value, name, addBinding) {\n        addBinding('textInput', value);\n    }\n};\n\n})();ko.bindingHandlers['uniqueName'] = {\n    'init': function (element, valueAccessor) {\n        if (valueAccessor()) {\n            var name = \"ko_unique_\" + (++ko.bindingHandlers['uniqueName'].currentIndex);\n            ko.utils.setElementName(element, name);\n        }\n    }\n};\nko.bindingHandlers['uniqueName'].currentIndex = 0;\nko.bindingHandlers['value'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit\n        if (element.tagName.toLowerCase() == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });\n            return;\n        }\n\n        // Always catch \"change\" event; possibly other events too if asked\n        var eventsToCatch = [\"change\"];\n        var requestedEventsToCatch = allBindings.get(\"valueUpdate\");\n        var propertyChangedFired = false;\n        var elementValueBeforeEvent = null;\n\n        if (requestedEventsToCatch) {\n            if (typeof requestedEventsToCatch == \"string\") // Allow both individual event names, and arrays of event names\n                requestedEventsToCatch = [requestedEventsToCatch];\n            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);\n            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);\n        }\n\n        var valueUpdateHandler = function() {\n            elementValueBeforeEvent = null;\n            propertyChangedFired = false;\n            var modelValue = valueAccessor();\n            var elementValue = ko.selectExtensions.readValue(element);\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);\n        }\n\n        // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n        // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == \"input\" && element.type == \"text\"\n                                       && element.autocomplete != \"off\" && (!element.form || element.form.autocomplete != \"off\");\n        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, \"propertychange\") == -1) {\n            ko.utils.registerEventHandler(element, \"propertychange\", function () { propertyChangedFired = true });\n            ko.utils.registerEventHandler(element, \"focus\", function () { propertyChangedFired = false });\n            ko.utils.registerEventHandler(element, \"blur\", function() {\n                if (propertyChangedFired) {\n                    valueUpdateHandler();\n                }\n            });\n        }\n\n        ko.utils.arrayForEach(eventsToCatch, function(eventName) {\n            // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n            // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)\n            var handler = valueUpdateHandler;\n            if (ko.utils.stringStartsWith(eventName, \"after\")) {\n                handler = function() {\n                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between\n                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen\n                    // at the earliest asynchronous opportunity. We store this temporary information so that\n                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,\n                    // we can overwrite that model value change with the value the user just typed. Otherwise,\n                    // techniques like rateLimit can trigger model changes at critical moments that will\n                    // override the user's inputs, causing keystrokes to be lost.\n                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);\n                    ko.utils.setTimeout(valueUpdateHandler, 0);\n                };\n                eventName = eventName.substring(\"after\".length);\n            }\n            ko.utils.registerEventHandler(element, eventName, handler);\n        });\n\n        var updateFromModel = function () {\n            var newValue = ko.utils.unwrapObservable(valueAccessor());\n            var elementValue = ko.selectExtensions.readValue(element);\n\n            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateFromModel, 0);\n                return;\n            }\n\n            var valueHasChanged = (newValue !== elementValue);\n\n            if (valueHasChanged) {\n                if (ko.utils.tagNameLower(element) === \"select\") {\n                    var allowUnset = allBindings.get('valueAllowUnset');\n                    var applyValueAction = function () {\n                        ko.selectExtensions.writeValue(element, newValue, allowUnset);\n                    };\n                    applyValueAction();\n\n                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {\n                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n                        // because you're not allowed to have a model value that disagrees with a visible UI selection.\n                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                    } else {\n                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n                        // to apply the value as well.\n                        ko.utils.setTimeout(applyValueAction, 0);\n                    }\n                } else {\n                    ko.selectExtensions.writeValue(element, newValue);\n                }\n            }\n        };\n\n        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });\n    },\n    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding\n};\nko.expressionRewriting.twoWayBindings['value'] = true;\nko.bindingHandlers['visible'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        var isCurrentlyVisible = !(element.style.display == \"none\");\n        if (value && !isCurrentlyVisible)\n            element.style.display = \"\";\n        else if ((!value) && isCurrentlyVisible)\n            element.style.display = \"none\";\n    }\n};\n// 'click' is just a shorthand for the usual full-length event:{click:handler}\nmakeEventHandlerShortcut('click');\n// If you want to make a custom template engine,\n//\n// [1] Inherit from this class (like ko.nativeTemplateEngine does)\n// [2] Override 'renderTemplateSource', supplying a function with this signature:\n//\n//        function (templateSource, bindingContext, options) {\n//            // - templateSource.text() is the text of the template you should render\n//            // - bindingContext.$data is the data you should pass into the template\n//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,\n//            //     and bindingContext.$root available in the template too\n//            // - options gives you access to any other properties set on \"data-bind: { template: options }\"\n//            // - templateDocument is the document object of the template\n//            //\n//            // Return value: an array of DOM nodes\n//        }\n//\n// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:\n//\n//        function (script) {\n//            // Return value: Whatever syntax means \"Evaluate the JavaScript statement 'script' and output the result\"\n//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'\n//        }\n//\n//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.\n//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)\n//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.\n\nko.templateEngine = function () { };\n\nko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    throw new Error(\"Override renderTemplateSource\");\n};\n\nko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {\n    throw new Error(\"Override createJavaScriptEvaluatorBlock\");\n};\n\nko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {\n    // Named template\n    if (typeof template == \"string\") {\n        templateDocument = templateDocument || document;\n        var elem = templateDocument.getElementById(template);\n        if (!elem)\n            throw new Error(\"Cannot find template with ID \" + template);\n        return new ko.templateSources.domElement(elem);\n    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {\n        // Anonymous template\n        return new ko.templateSources.anonymousTemplate(template);\n    } else\n        throw new Error(\"Unknown template type: \" + template);\n};\n\nko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);\n};\n\nko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {\n    // Skip rewriting if requested\n    if (this['allowTemplateRewriting'] === false)\n        return true;\n    return this['makeTemplateSource'](template, templateDocument)['data'](\"isRewritten\");\n};\n\nko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    var rewritten = rewriterCallback(templateSource['text']());\n    templateSource['text'](rewritten);\n    templateSource['data'](\"isRewritten\", true);\n};\n\nko.exportSymbol('templateEngine', ko.templateEngine);\n\nko.templateRewriting = (function () {\n    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\\"[^\\\"]*\\\"|\\'[^\\']*\\'|[^>]*))?)*\\s+)data-bind\\s*=\\s*([\"'])([\\s\\S]*?)\\3/gi;\n    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*-->/g;\n\n    function validateDataBindValuesForRewriting(keyValueArray) {\n        var allValidators = ko.expressionRewriting.bindingRewriteValidators;\n        for (var i = 0; i < keyValueArray.length; i++) {\n            var key = keyValueArray[i]['key'];\n            if (allValidators.hasOwnProperty(key)) {\n                var validator = allValidators[key];\n\n                if (typeof validator === \"function\") {\n                    var possibleErrorMessage = validator(keyValueArray[i]['value']);\n                    if (possibleErrorMessage)\n                        throw new Error(possibleErrorMessage);\n                } else if (!validator) {\n                    throw new Error(\"This template engine does not support the '\" + key + \"' binding within its templates\");\n                }\n            }\n        }\n    }\n\n    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {\n        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);\n        validateDataBindValuesForRewriting(dataBindKeyValueArray);\n        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});\n\n        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional\n        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this\n        // extra indirection.\n        var applyBindingsToNextSiblingScript =\n            \"ko.__tr_ambtns(function($context,$element){return(function(){return{ \" + rewrittenDataBindAttributeValue + \" } })()},'\" + nodeName.toLowerCase() + \"')\";\n        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;\n    }\n\n    return {\n        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {\n            if (!templateEngine['isTemplateRewritten'](template, templateDocument))\n                templateEngine['rewriteTemplate'](template, function (htmlString) {\n                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);\n                }, templateDocument);\n        },\n\n        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {\n            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);\n            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ \"<!-- ko -->\", /* nodeName: */ \"#comment\", templateEngine);\n            });\n        },\n\n        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {\n            return ko.memoization.memoize(function (domNode, bindingContext) {\n                var nodeToBind = domNode.nextSibling;\n                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {\n                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);\n                }\n            });\n        }\n    }\n})();\n\n\n// Exported only because it has to be referenced by string lookup from within rewritten template\nko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);\n(function() {\n    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving\n    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)\n    //\n    // Two are provided by default:\n    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element\n    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but\n    //                                           without reading/writing the actual element text content, since it will be overwritten\n    //                                           with the rendered template output.\n    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.\n    // Template sources need to have the following functions:\n    //   text() \t\t\t- returns the template text from your storage location\n    //   text(value)\t\t- writes the supplied template text to your storage location\n    //   data(key)\t\t\t- reads values stored using data(key, value) - see below\n    //   data(key, value)\t- associates \"value\" with this template and the key \"key\". Is used to store information like \"isRewritten\".\n    //\n    // Optionally, template sources can also have the following functions:\n    //   nodes()            - returns a DOM element containing the nodes of this template, where available\n    //   nodes(value)       - writes the given DOM element to your storage location\n    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()\n    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().\n    //\n    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were\n    // using and overriding \"makeTemplateSource\" to return an instance of your custom template source.\n\n    ko.templateSources = {};\n\n    // ---- ko.templateSources.domElement -----\n\n    // template types\n    var templateScript = 1,\n        templateTextArea = 2,\n        templateTemplate = 3,\n        templateElement = 4;\n\n    ko.templateSources.domElement = function(element) {\n        this.domElement = element;\n\n        if (element) {\n            var tagNameLower = ko.utils.tagNameLower(element);\n            this.templateType =\n                tagNameLower === \"script\" ? templateScript :\n                tagNameLower === \"textarea\" ? templateTextArea :\n                    // For browsers with proper <template> element support, where the .content property gives a document fragment\n                tagNameLower == \"template\" && element.content && element.content.nodeType === 11 ? templateTemplate :\n                templateElement;\n        }\n    }\n\n    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {\n        var elemContentsProperty = this.templateType === templateScript ? \"text\"\n                                 : this.templateType === templateTextArea ? \"value\"\n                                 : \"innerHTML\";\n\n        if (arguments.length == 0) {\n            return this.domElement[elemContentsProperty];\n        } else {\n            var valueToWrite = arguments[0];\n            if (elemContentsProperty === \"innerHTML\")\n                ko.utils.setHtml(this.domElement, valueToWrite);\n            else\n                this.domElement[elemContentsProperty] = valueToWrite;\n        }\n    };\n\n    var dataDomDataPrefix = ko.utils.domData.nextKey() + \"_\";\n    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {\n        if (arguments.length === 1) {\n            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);\n        } else {\n            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);\n        }\n    };\n\n    var templatesDomDataKey = ko.utils.domData.nextKey();\n    function getTemplateDomData(element) {\n        return ko.utils.domData.get(element, templatesDomDataKey) || {};\n    }\n    function setTemplateDomData(element, data) {\n        ko.utils.domData.set(element, templatesDomDataKey, data);\n    }\n\n    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {\n        var element = this.domElement;\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(element),\n                containerData = templateData.containerData;\n            return containerData || (\n                this.templateType === templateTemplate ? element.content :\n                this.templateType === templateElement ? element :\n                undefined);\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(element, {containerData: valueToWrite});\n        }\n    };\n\n    // ---- ko.templateSources.anonymousTemplate -----\n    // Anonymous templates are normally saved/retrieved as DOM nodes through \"nodes\".\n    // For compatibility, you can also read \"text\"; it will be serialized from the nodes on demand.\n    // Writing to \"text\" is still supported, but then the template data will not be available as DOM nodes.\n\n    ko.templateSources.anonymousTemplate = function(element) {\n        this.domElement = element;\n    }\n    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();\n    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;\n    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(this.domElement);\n            if (templateData.textData === undefined && templateData.containerData)\n                templateData.textData = templateData.containerData.innerHTML;\n            return templateData.textData;\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(this.domElement, {textData: valueToWrite});\n        }\n    };\n\n    ko.exportSymbol('templateSources', ko.templateSources);\n    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);\n    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);\n})();\n(function () {\n    var _templateEngine;\n    ko.setTemplateEngine = function (templateEngine) {\n        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))\n            throw new Error(\"templateEngine must inherit from ko.templateEngine\");\n        _templateEngine = templateEngine;\n    }\n\n    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {\n        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);\n        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n            nextInQueue = ko.virtualElements.nextSibling(node);\n            action(node, nextInQueue);\n        }\n    }\n\n    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {\n        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n        // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n        if (continuousNodeArray.length) {\n            var firstNode = continuousNodeArray[0],\n                lastNode = continuousNodeArray[continuousNodeArray.length - 1],\n                parentNode = firstNode.parentNode,\n                provider = ko.bindingProvider['instance'],\n                preprocessNode = provider['preprocessNode'];\n\n            if (preprocessNode) {\n                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {\n                    var nodePreviousSibling = node.previousSibling;\n                    var newNodes = preprocessNode.call(provider, node);\n                    if (newNodes) {\n                        if (node === firstNode)\n                            firstNode = newNodes[0] || nextNodeInRange;\n                        if (node === lastNode)\n                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;\n                    }\n                });\n\n                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.\n                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real\n                // first node needs to be in the array).\n                continuousNodeArray.length = 0;\n                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do\n                    return;\n                }\n                if (firstNode === lastNode) {\n                    continuousNodeArray.push(firstNode);\n                } else {\n                    continuousNodeArray.push(firstNode, lastNode);\n                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n                }\n            }\n\n            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n            // whereas a regular applyBindings won't introduce new memoized nodes\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.applyBindings(bindingContext, node);\n            });\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);\n            });\n\n            // Make sure any changes done by applyBindings or unmemoize are reflected in the array\n            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n        }\n    }\n\n    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {\n        return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                        : null;\n    }\n\n    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {\n        options = options || {};\n        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n        var templateDocument = (firstTargetNode || template || {}).ownerDocument;\n        var templateEngineToUse = (options['templateEngine'] || _templateEngine);\n        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);\n        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);\n\n        // Loosely check result is an array of DOM nodes\n        if ((typeof renderedNodesArray.length != \"number\") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != \"number\"))\n            throw new Error(\"Template engine must return an array of DOM nodes\");\n\n        var haveAddedNodesToParent = false;\n        switch (renderMode) {\n            case \"replaceChildren\":\n                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"replaceNode\":\n                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"ignoreTargetNode\": break;\n            default:\n                throw new Error(\"Unknown renderMode: \" + renderMode);\n        }\n\n        if (haveAddedNodesToParent) {\n            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);\n            if (options['afterRender'])\n                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);\n        }\n\n        return renderedNodesArray;\n    }\n\n    function resolveTemplateName(template, data, context) {\n        // The template can be specified as:\n        if (ko.isObservable(template)) {\n            // 1. An observable, with string value\n            return template();\n        } else if (typeof template === 'function') {\n            // 2. A function of (data, context) returning a string\n            return template(data, context);\n        } else {\n            // 3. A string\n            return template;\n        }\n    }\n\n    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {\n        options = options || {};\n        if ((options['templateEngine'] || _templateEngine) == undefined)\n            throw new Error(\"Set a template engine before calling renderTemplate\");\n        renderMode = renderMode || \"replaceChildren\";\n\n        if (targetNodeOrNodeArray) {\n            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)\n            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == \"replaceNode\") ? firstTargetNode.parentNode : firstTargetNode;\n\n            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes\n                function () {\n                    // Ensure we've got a proper binding context to work with\n                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))\n                        ? dataOrBindingContext\n                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { \"exportDependencies\": true });\n\n                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),\n                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n\n                    if (renderMode == \"replaceNode\") {\n                        targetNodeOrNodeArray = renderedNodesArray;\n                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n                    }\n                },\n                null,\n                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }\n            );\n        } else {\n            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n            return ko.memoization.memoize(function (domNode) {\n                ko.renderTemplate(template, dataOrBindingContext, options, domNode, \"replaceNode\");\n            });\n        }\n    };\n\n    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {\n        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n        var arrayItemContext;\n\n        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n        var executeTemplateForArrayItem = function (arrayValue, index) {\n            // Support selecting template as a function of the data being rendered\n            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {\n                context['$index'] = index;\n            });\n\n            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);\n            return executeTemplate(null, \"ignoreTargetNode\", templateName, arrayItemContext, options);\n        }\n\n        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {\n            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);\n            if (options['afterRender'])\n                options['afterRender'](addedNodesArray, arrayValue);\n\n            // release the \"cache\" variable, so that it can be collected by\n            // the GC when its value isn't used from within the bindings anymore.\n            arrayItemContext = null;\n        };\n\n        return ko.dependentObservable(function () {\n            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).\n            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.\n            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);\n\n        }, null, { disposeWhenNodeIsRemoved: targetNode });\n    };\n\n    var templateComputedDomDataKey = ko.utils.domData.nextKey();\n    function disposeOldComputedAndStoreNewOne(element, newComputed) {\n        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);\n        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))\n            oldComputed.dispose();\n        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);\n    }\n\n    ko.bindingHandlers['template'] = {\n        'init': function(element, valueAccessor) {\n            // Support anonymous templates\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            if (typeof bindingValue == \"string\" || bindingValue['name']) {\n                // It's a named template - clear the element\n                ko.virtualElements.emptyNode(element);\n            } else if ('nodes' in bindingValue) {\n                // We've been given an array of DOM nodes. Save them as the template source.\n                // There is no known use case for the node array being an observable array (if the output\n                // varies, put that behavior *into* your template - that's what templates are for), and\n                // the implementation would be a mess, so assert that it's not observable.\n                var nodes = bindingValue['nodes'] || [];\n                if (ko.isObservable(nodes)) {\n                    throw new Error('The \"nodes\" option must be a plain, non-observable array.');\n                }\n                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            } else {\n                // It's an anonymous template - store the element contents, then clear the element\n                var templateNodes = ko.virtualElements.childNodes(element),\n                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            }\n            return { 'controlsDescendantBindings': true };\n        },\n        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var value = valueAccessor(),\n                options = ko.utils.unwrapObservable(value),\n                shouldDisplay = true,\n                templateComputed = null,\n                templateName;\n\n            if (typeof options == \"string\") {\n                templateName = value;\n                options = {};\n            } else {\n                templateName = options['name'];\n\n                // Support \"if\"/\"ifnot\" conditions\n                if ('if' in options)\n                    shouldDisplay = ko.utils.unwrapObservable(options['if']);\n                if (shouldDisplay && 'ifnot' in options)\n                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);\n            }\n\n            if ('foreach' in options) {\n                // Render once for each data point (treating data set as empty if shouldDisplay==false)\n                var dataArray = (shouldDisplay && options['foreach']) || [];\n                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);\n            } else if (!shouldDisplay) {\n                ko.virtualElements.emptyNode(element);\n            } else {\n                // Render once for this single data point (or use the viewModel if no data was provided)\n                var innerBindingContext = ('data' in options) ?\n                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it\n                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context\n                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);\n            }\n\n            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)\n            disposeOldComputedAndStoreNewOne(element, templateComputed);\n        }\n    };\n\n    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.\n    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {\n        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);\n\n        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])\n            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)\n\n        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, \"name\"))\n            return null; // Named templates can be rewritten, so return \"no error\"\n        return \"This template engine does not support anonymous templates nested within its templates\";\n    };\n\n    ko.virtualElements.allowedBindings['template'] = true;\n})();\n\nko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);\nko.exportSymbol('renderTemplate', ko.renderTemplate);\n// Go through the items that have been added and deleted and try to find matches between them.\nko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n        var failedCompares, l, r, leftItem, rightItem;\n        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n            for (r = 0; rightItem = right[r]; ++r) {\n                if (leftItem['value'] === rightItem['value']) {\n                    leftItem['moved'] = rightItem['index'];\n                    rightItem['moved'] = leftItem['index'];\n                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list\n                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures\n                    break;\n                }\n            }\n            failedCompares += r;\n        }\n    }\n};\n\nko.utils.compareArrays = (function () {\n    var statusNotInOld = 'added', statusNotInNew = 'deleted';\n\n    // Simple calculation based on Levenshtein distance.\n    function compareArrays(oldArray, newArray, options) {\n        // For backward compatibility, if the third arg is actually a bool, interpret\n        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});\n        oldArray = oldArray || [];\n        newArray = newArray || [];\n\n        if (oldArray.length < newArray.length)\n            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);\n        else\n            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);\n    }\n\n    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n        var myMin = Math.min,\n            myMax = Math.max,\n            editDistanceMatrix = [],\n            smlIndex, smlIndexMax = smlArray.length,\n            bigIndex, bigIndexMax = bigArray.length,\n            compareRange = (bigIndexMax - smlIndexMax) || 1,\n            maxDistance = smlIndexMax + bigIndexMax + 1,\n            thisRow, lastRow,\n            bigIndexMaxForRow, bigIndexMinForRow;\n\n        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n            lastRow = thisRow;\n            editDistanceMatrix.push(thisRow = []);\n            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n            bigIndexMinForRow = myMax(0, smlIndex - 1);\n            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n                if (!bigIndex)\n                    thisRow[bigIndex] = smlIndex + 1;\n                else if (!smlIndex)  // Top row - transform empty array into new array via additions\n                    thisRow[bigIndex] = bigIndex + 1;\n                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])\n                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)\n                else {\n                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)\n                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)\n                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n                }\n            }\n        }\n\n        var editScript = [], meMinusOne, notInSml = [], notInBig = [];\n        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {\n                notInSml.push(editScript[editScript.length] = {     // added\n                    'status': statusNotInSml,\n                    'value': bigArray[--bigIndex],\n                    'index': bigIndex });\n            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n                notInBig.push(editScript[editScript.length] = {     // deleted\n                    'status': statusNotInBig,\n                    'value': smlArray[--smlIndex],\n                    'index': smlIndex });\n            } else {\n                --bigIndex;\n                --smlIndex;\n                if (!options['sparse']) {\n                    editScript.push({\n                        'status': \"retained\",\n                        'value': bigArray[bigIndex] });\n                }\n            }\n        }\n\n        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n        // smlIndexMax keeps the time complexity of this algorithm linear.\n        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);\n\n        return editScript.reverse();\n    }\n\n    return compareArrays;\n})();\n\nko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);\n(function () {\n    // Objective:\n    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n    //   previously mapped - retain those nodes, and just insert/delete other ones\n\n    // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n    // You can use this, for example, to activate bindings on those nodes.\n\n    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n        // Map this array value inside a dependentObservable so we re-map when any dependency changes\n        var mappedNodes = [];\n        var dependentObservable = ko.dependentObservable(function() {\n            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];\n\n            // On subsequent evaluations, just replace the previously-inserted DOM nodes\n            if (mappedNodes.length > 0) {\n                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);\n                if (callbackAfterAddingNodes)\n                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);\n            }\n\n            // Replace the contents of the mappedNodes array, thereby updating the record\n            // of which nodes would be deleted if valueToMap was itself later removed\n            mappedNodes.length = 0;\n            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);\n        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });\n        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };\n    }\n\n    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),\n        deletedItemDummyValue = ko.utils.domData.nextKey();\n\n    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {\n        // Compare the provided array against the previous one\n        array = array || [];\n        options = options || {};\n        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;\n        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];\n        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });\n        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);\n\n        // Build the new mapping result\n        var newMappingResult = [];\n        var lastMappingResultIndex = 0;\n        var newMappingResultIndex = 0;\n\n        var nodesToDelete = [];\n        var itemsToProcess = [];\n        var itemsForBeforeRemoveCallbacks = [];\n        var itemsForMoveCallbacks = [];\n        var itemsForAfterAddCallbacks = [];\n        var mapData;\n\n        function itemMovedOrRetained(editScriptIndex, oldPosition) {\n            mapData = lastMappingResult[oldPosition];\n            if (newMappingResultIndex !== oldPosition)\n                itemsForMoveCallbacks[editScriptIndex] = mapData;\n            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray\n            mapData.indexObservable(newMappingResultIndex++);\n            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);\n            newMappingResult.push(mapData);\n            itemsToProcess.push(mapData);\n        }\n\n        function callCallback(callback, items) {\n            if (callback) {\n                for (var i = 0, n = items.length; i < n; i++) {\n                    if (items[i]) {\n                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {\n                            callback(node, i, items[i].arrayEntry);\n                        });\n                    }\n                }\n            }\n        }\n\n        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {\n            movedIndex = editScriptItem['moved'];\n            switch (editScriptItem['status']) {\n                case \"deleted\":\n                    if (movedIndex === undefined) {\n                        mapData = lastMappingResult[lastMappingResultIndex];\n\n                        // Stop tracking changes to the mapping for these nodes\n                        if (mapData.dependentObservable) {\n                            mapData.dependentObservable.dispose();\n                            mapData.dependentObservable = undefined;\n                        }\n\n                        // Queue these nodes for later removal\n                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {\n                            if (options['beforeRemove']) {\n                                newMappingResult.push(mapData);\n                                itemsToProcess.push(mapData);\n                                if (mapData.arrayEntry === deletedItemDummyValue) {\n                                    mapData = null;\n                                } else {\n                                    itemsForBeforeRemoveCallbacks[i] = mapData;\n                                }\n                            }\n                            if (mapData) {\n                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);\n                            }\n                        }\n                    }\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"retained\":\n                    itemMovedOrRetained(i, lastMappingResultIndex++);\n                    break;\n\n                case \"added\":\n                    if (movedIndex !== undefined) {\n                        itemMovedOrRetained(i, movedIndex);\n                    } else {\n                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };\n                        newMappingResult.push(mapData);\n                        itemsToProcess.push(mapData);\n                        if (!isFirstExecution)\n                            itemsForAfterAddCallbacks[i] = mapData;\n                    }\n                    break;\n            }\n        }\n\n        // Store a copy of the array items we just considered so we can difference it next time\n        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);\n\n        // Call beforeMove first before any changes have been made to the DOM\n        callCallback(options['beforeMove'], itemsForMoveCallbacks);\n\n        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)\n        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);\n\n        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)\n        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {\n            // Get nodes for newly added items\n            if (!mapData.mappedNodes)\n                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));\n\n            // Put nodes in the right place if they aren't there already\n            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {\n                if (node !== nextNode)\n                    ko.virtualElements.insertAfter(domNode, node, lastNode);\n            }\n\n            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)\n            if (!mapData.initialized && callbackAfterAddingNodes) {\n                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);\n                mapData.initialized = true;\n            }\n        }\n\n        // If there's a beforeRemove callback, call it after reordering.\n        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using\n        // some sort of animation, which is why we first reorder the nodes that will be removed. If the\n        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.\n        // Perhaps we'll make that change in the future if this scenario becomes more common.\n        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);\n\n        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item\n        // as already \"removed\" so we won't call beforeRemove for it again, and it ensures that the item won't match up\n        // with an actual item in the array and appear as \"retained\" or \"moved\".\n        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {\n            if (itemsForBeforeRemoveCallbacks[i]) {\n                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;\n            }\n        }\n\n        // Finally call afterMove and afterAdd callbacks\n        callCallback(options['afterMove'], itemsForMoveCallbacks);\n        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);\n    }\n})();\n\nko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);\nko.nativeTemplateEngine = function () {\n    this['allowTemplateRewriting'] = false;\n}\n\nko.nativeTemplateEngine.prototype = new ko.templateEngine();\nko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;\nko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly\n        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,\n        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;\n\n    if (templateNodes) {\n        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);\n    } else {\n        var templateText = templateSource['text']();\n        return ko.utils.parseHtmlFragment(templateText, templateDocument);\n    }\n};\n\nko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();\nko.setTemplateEngine(ko.nativeTemplateEngine.instance);\n\nko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);\n(function() {\n    ko.jqueryTmplTemplateEngine = function () {\n        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl\n        // doesn't expose a version number, so we have to infer it.\n        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,\n        // which KO internally refers to as version \"2\", so older versions are no longer detected.\n        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {\n            if (!jQueryInstance || !(jQueryInstance['tmpl']))\n                return 0;\n            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.\n            try {\n                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {\n                    // Since 1.0.0pre, custom tags should append markup to an array called \"__\"\n                    return 2; // Final version of jquery.tmpl\n                }\n            } catch(ex) { /* Apparently not the version we were looking for */ }\n\n            return 1; // Any older version that we don't support\n        })();\n\n        function ensureHasReferencedJQueryTemplates() {\n            if (jQueryTmplVersion < 2)\n                throw new Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");\n        }\n\n        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {\n            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);\n        }\n\n        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {\n            templateDocument = templateDocument || document;\n            options = options || {};\n            ensureHasReferencedJQueryTemplates();\n\n            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)\n            var precompiled = templateSource['data']('precompiled');\n            if (!precompiled) {\n                var templateText = templateSource['text']() || \"\";\n                // Wrap in \"with($whatever.koBindingContext) { ... }\"\n                templateText = \"{{ko_with $item.koBindingContext}}\" + templateText + \"{{/ko_with}}\";\n\n                precompiled = jQueryInstance['template'](null, templateText);\n                templateSource['data']('precompiled', precompiled);\n            }\n\n            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays\n            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);\n\n            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);\n            resultNodes['appendTo'](templateDocument.createElement(\"div\")); // Using \"appendTo\" forces jQuery/jQuery.tmpl to perform necessary cleanup work\n\n            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders\n            return resultNodes;\n        };\n\n        this['createJavaScriptEvaluatorBlock'] = function(script) {\n            return \"{{ko_code ((function() { return \" + script + \" })()) }}\";\n        };\n\n        this['addTemplate'] = function(templateName, templateMarkup) {\n            document.write(\"<script type='text/html' id='\" + templateName + \"'>\" + templateMarkup + \"<\" + \"/script>\");\n        };\n\n        if (jQueryTmplVersion > 0) {\n            jQueryInstance['tmpl']['tag']['ko_code'] = {\n                open: \"__.push($1 || '');\"\n            };\n            jQueryInstance['tmpl']['tag']['ko_with'] = {\n                open: \"with($1) {\",\n                close: \"} \"\n            };\n        }\n    };\n\n    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();\n    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;\n\n    // Use this one by default *only if jquery.tmpl is referenced*\n    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();\n    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)\n        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);\n\n    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);\n})();\n}));\n}());\n})();\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// Returns the widest zoom level that can be displayed without showing the grey div background\n// above and below the map. Just makes things look nicer than using 'fitBounds(bounds)', which\n// can often show the grey areas.\nfunction calculateInitZoomLevel() {\n  var mapHeight = document.getElementsByClassName('map')[0].clientHeight;\n  if (mapHeight <= 295) {\n    return 0;\n  } else if (mapHeight <= 534) {\n    return 1;\n  } else if (mapHeight <= 1122) {\n    return 2;\n  } else if (mapHeight <= 2120) {\n    return 3;\n  }\n  return 4;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (calculateInitZoomLevel);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction calculateResponsiveLatLng() {\n  var windowWidth = document.body.clientWidth;\n  var latLng = {};\n\n  if (windowWidth > 1366) {\n    latLng.lat = -2;\n    latLng.lng = 12;\n  } else if (windowWidth > 1226) {\n    latLng.lat = 17;\n    latLng.lng = 3;\n  } else if (windowWidth > 1020) {\n    latLng.lat = 20;\n    latLng.lng = 2;\n  } else if (windowWidth > 840) {\n    latLng.lat = 24;\n    latLng.lng = 9;\n  } else if (windowWidth > 775) {\n    latLng.lat = 27;\n    latLng.lng = 7;\n  } else if (windowWidth > 751) {\n    latLng.lat = 21;\n    latLng.lng = 7;\n  } else if (windowWidth > 660) {\n    latLng.lat = 9;\n    latLng.lng = 10;\n  } else if (windowWidth > 616) {\n    latLng.lat = 11;\n    latLng.lng = 0;\n  } else if (windowWidth > 563) {\n    latLng.lat = 9;\n    latLng.lng = 7;\n  } else if (windowWidth > 413) {\n    latLng.lat = 14;\n    latLng.lng = 4;\n  } else if (windowWidth > 374) {\n    latLng.lat = 9;\n    latLng.lng = 6;\n  } else {\n    latLng.lat = 14;\n    latLng.lng = 0;\n  }\n\n  return latLng;\n} // End of calculateResponsiveLatLng().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (calculateResponsiveLatLng);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/gif;base64,R0lGODlhgACAAIABAFGvvP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEFEQkNEMUM1Q0NEMTFFNzkyRkZGQTZDQzIwNkJBQTIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEFEQkNEMUQ1Q0NEMTFFNzkyRkZGQTZDQzIwNkJBQTIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0QURCQ0QxQTVDQ0QxMUU3OTJGRkZBNkNDMjA2QkFBMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0QURCQ0QxQjVDQ0QxMUU3OTJGRkZBNkNDMjA2QkFBMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769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\"\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\"\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__modules_generateMap__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_styles_css__ = __webpack_require__(89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_styles_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__css_styles_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_initLoadingScreen__ = __webpack_require__(90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_audio__ = __webpack_require__(0);\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\n(function appInit() {\n  // Enables Webpack's hot module replacement for index.html if in development mode.\n  if (false) {\n    require('../index.html'); // eslint-disable-line global-require\n  }\n\n  // This event handler solves an issue with the menu animation firing on initial page load.\n  // See here for more details... https://css-tricks.com/transitions-only-after-page-load\n  window.onanimationstart = function () {\n    var body = document.getElementsByClassName('disable-init-animations')[0];\n    body.classList.remove('disable-init-animations');\n    window.onanimationstart = null;\n  };\n\n  Object(__WEBPACK_IMPORTED_MODULE_0__modules_generateMap__[\"a\" /* default */])();\n\n  Object(__WEBPACK_IMPORTED_MODULE_2__modules_initLoadingScreen__[\"a\" /* default */])().then(function () {\n    // Fades in the map area after all neccessary files are loaded for initial page render.\n    var initMapContainerLoadingScreen = document.getElementsByClassName('init-map-container-loading-screen')[0];\n    initMapContainerLoadingScreen.classList.add('init-map-container-loading-screen--fade');\n\n    // Now that the map has faded into view we'll animate the clouds.\n    // I'm using the ES6 spread operator here to spread the HTMLCollection object into an array.\n    var cloudArray = [].concat(_toConsumableArray(document.getElementsByClassName('clouds')));\n    cloudArray.forEach(function (cloud, index) {\n      cloud.classList.add('clouds__cloud-' + (index + 1) + '--animate');\n    });\n\n    __WEBPACK_IMPORTED_MODULE_3__modules_audio__[\"j\" /* ocean */].start(0);\n    setTimeout(map.dropMarkers, 1100);\n  });\n})();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_knockout__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_knockout___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_knockout__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__islands__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ViewModel__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__getNumberToDivideTextboxHeightBy__ = __webpack_require__(66);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__makeMarker__ = __webpack_require__(67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__setMinAndMaxZoomLevels__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__getOverlayTileURL__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__mapStyles__ = __webpack_require__(80);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n\n\n\n\n\n\n\n\n\nfunction generateMap() {\n  // Google Maps API key.\n  var key = 'AIzaSyDvNMjcb6i4p55qJpL3vzSiCp9KRwW4QQ0';\n\n  // 'google-maps-api' npm package by 'Jam3'.\n  // For more details, visit https://github.com/Jam3/google-maps-api\n  var googleMapsAPIModule = __webpack_require__(81)(key); // eslint-disable-line global-require\n\n  googleMapsAPIModule().then(function (mapObject) {\n    var _calculateResponsiveL = Object(__WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__[\"a\" /* default */])(),\n        lat = _calculateResponsiveL.lat,\n        lng = _calculateResponsiveL.lng;\n\n    var map = new mapObject.Map(document.getElementsByClassName('map')[0], {\n      center: {\n        lat: lat,\n        lng: lng\n      },\n      disableDefaultUI: true,\n      styles: __WEBPACK_IMPORTED_MODULE_9__mapStyles__[\"a\" /* default */],\n      scrollwheel: window.innerWidth <= 768\n    });\n\n    // Changes the default grey map background. While page loads we'll set the background to\n    // white, so that the map seems to fade in from white nicely. Then after a 100ms timeout we\n    // change the background to a top-to-bottom blue/white gradient, so that the ocean blends\n    // nicely with the blue at the top of the map, and the Antarctic blends nicely with the white\n    // at the bottom.\n    map.background = document.getElementsByClassName('map')[0].children[0];\n    map.background.style.background = 'rgb(255, 255, 255)';\n    setTimeout(function () {\n      map.background.style.background = 'linear-gradient(rgb(81, 175, 188) 41%, rgb(233, 240, 244) 59%)';\n    }, 100);\n\n    global.map = map;\n\n    // Helpful later for when we want to filter the markers.\n    map.markers = [];\n\n    // This tracks if the map is displaying its initial global view or not, i.e. is the viewport\n    // showing all the islands or has a user selected an island from the menu and thus zoomed in\n    // on that island. This boolean will determine if the viewport pans to a marker when it is\n    // selected. In global view the viewport will pan, but when zoomed in on an island the\n    // viewport won't pan to the marker when clicked.\n    map.globalView = true;\n\n    var infoWindow = new mapObject.InfoWindow();\n\n    map.dropMarkers = function () {\n      // 'index * 300' is passed into the makeMarker function so that it receives a longer timeout\n      // value each time it is called. This results in a 'falling rain' effect when the markers\n      // drop into view on page load.\n      __WEBPACK_IMPORTED_MODULE_1__islands__[\"a\" /* default */].forEach(function (item, index) {\n        return Object(__WEBPACK_IMPORTED_MODULE_6__makeMarker__[\"a\" /* default */])(index, index * 300, map, mapObject, infoWindow);\n      });\n    };\n\n    map.bounceMarker = function (island) {\n      var iteration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      for (var i = 0; i < map.markers.length; i++) {\n        if (island.name === map.markers[i].title) {\n          map.markers[i].setAnimation(null);\n          map.markers[i].setAnimation(mapObject.Animation.BOUNCE);\n          stopBounce(i);\n        }\n      }\n\n      function stopBounce(index) {\n        setTimeout(function () {\n          map.markers[index].setAnimation(null);\n        }, 710 * iteration);\n      }\n    };\n\n    map.getIslandBounds = function (island) {\n      var _island$latLngBounds = _slicedToArray(island.latLngBounds, 2),\n          southWestCoordinates = _island$latLngBounds[0],\n          northEastCoordinates = _island$latLngBounds[1];\n\n      var islandBounds = new mapObject.LatLngBounds(southWestCoordinates, northEastCoordinates);\n      return islandBounds;\n    };\n\n    map.showOverlayTiles = function (islandName, islandBounds, currentZoomLevel, minZoomLevel, maxZoomLevel) {\n      var overlayMinZoom = minZoomLevel;\n      var overlayMaxZoom = maxZoomLevel;\n      var tileURL = Object(__WEBPACK_IMPORTED_MODULE_8__getOverlayTileURL__[\"a\" /* default */])(map, mapObject, islandName, islandBounds, currentZoomLevel, overlayMinZoom, overlayMaxZoom);\n      map.overlayMapTypes.insertAt(0, tileURL);\n    };\n\n    map.goToSelectedIsland = function (island) {\n      // Empties cache of any previously loaded overlays. This ensures overlay fonts are correctly\n      // rendered if the previous island is ever selected again - the tyopgraphy won't be doubled\n      // up and thickened each time the overlay tiles are loaded.\n      map.overlayMapTypes.removeAt(0);\n\n      mapObject.event.trigger(map, 'resize');\n\n      var islandBounds = map.getIslandBounds(island);\n      map.fitBounds(islandBounds);\n\n      var islandName = island.name;\n      var currentZoomLevel = map.getZoom();\n\n      var _setMinAndMaxZoomLeve = Object(__WEBPACK_IMPORTED_MODULE_7__setMinAndMaxZoomLevels__[\"a\" /* default */])(islandName),\n          _setMinAndMaxZoomLeve2 = _slicedToArray(_setMinAndMaxZoomLeve, 2),\n          minZoomLevel = _setMinAndMaxZoomLeve2[0],\n          maxZoomLevel = _setMinAndMaxZoomLeve2[1];\n\n      // Caps the maximum zoom level so that each island is seen at its most appropriate zoom\n      // level without overflowing the browser window.\n\n\n      if (currentZoomLevel > maxZoomLevel) {\n        map.setZoom(maxZoomLevel);\n      }\n\n      // This conditional adjusts the 'y' position of the map to account for the\n      // <section class='textbox'> being absolutely positioned over the map in desktop view.\n      if (document.body.clientWidth >= 1366) {\n        var textboxHeight = document.getElementsByClassName('textbox')[0].clientHeight;\n        var numberToDivideTextboxHeightBy = Object(__WEBPACK_IMPORTED_MODULE_5__getNumberToDivideTextboxHeightBy__[\"a\" /* default */])(islandName);\n        var textboxCompensation = textboxHeight / numberToDivideTextboxHeightBy;\n        map.panBy(0, textboxCompensation);\n      }\n\n      // Finally, we'll get and set the appropriate overlay tiles for the selected island.\n      map.showOverlayTiles(islandName, islandBounds, currentZoomLevel, minZoomLevel, maxZoomLevel);\n    }; // End of goToSelectedIsland().\n\n    return map;\n  }).then(function (map) {\n    __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.applyBindings(new __WEBPACK_IMPORTED_MODULE_2__ViewModel__[\"a\" /* default */](map));\n\n    var zoomLevel = Object(__WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__[\"a\" /* default */])();\n    map.setZoom(zoomLevel);\n\n    // Updates the height of '.textbox-underlayer' with the value obtained by querying the height\n    // of '.textbox' after it's been loaded with new data. By blending the opacity of the\n    // background colours of each div we get a very subtle but pleasing effect.\n    setTimeout(function () {\n      var textbox = document.getElementsByClassName('textbox')[0];\n      var textboxUnderlayer = document.getElementsByClassName('textbox-underlayer')[0];\n      textboxUnderlayer.style.height = textbox.clientHeight + 'px';\n    }, 50);\n  }).catch(function (err) {\n    console.warn(err);\n    alert('Google Maps was unable to load. Please check your network connection or try again later.');\n  }); // End of googleMapsAPIModule().\n} // End of googleMapView().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (generateMap);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(3)))\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_knockout__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_knockout___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_knockout__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__islands__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__IslandConstructor__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__audio__ = __webpack_require__(0);\n\n\n\n\n\n\n\n\n\nfunction ViewModel(map) {\n  var _this = this;\n\n  // An array containing which islands should be shown in the menu.\n  // Contents depend on whether a filter is currently selected or not.\n  this.islandsToList = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observableArray();\n\n  this.currentlySelectedIsland = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(null);\n\n  // Updates the height of '.textbox-underlayer' with the value obtained by querying the height of\n  // '.textbox' after it's been loaded with new data. By blending the opacity of the background\n  // colours of each div we get a very subtle but pleasing glazed glass-like effect when the app is\n  // viewed on desktop. Effect is disabled on mobile/tablet as the map doesn't pass beneath the\n  // textbox when viewed on such devices.\n  this.currentlySelectedIsland.subscribe(function () {\n    setTimeout(function () {\n      var textbox = document.getElementsByClassName('textbox')[0];\n      var textboxUnderlayer = document.getElementsByClassName('textbox-underlayer')[0];\n      textboxUnderlayer.style.height = textbox.clientHeight + 'px';\n    }, 0);\n  });\n\n  this.currentlySelectedOcean = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(null);\n\n  // When true the 'filter' background colour flashes yellow.\n  this.filterChanged = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  // See above.\n  this.currentlySelectedOcean.subscribe(function () {\n    _this.filterChanged(true);\n    map.globalView ? __WEBPACK_IMPORTED_MODULE_7__audio__[\"e\" /* filterChange */].volume(0.3) : __WEBPACK_IMPORTED_MODULE_7__audio__[\"e\" /* filterChange */].volume(0.8);\n    __WEBPACK_IMPORTED_MODULE_7__audio__[\"e\" /* filterChange */].play();\n    setTimeout(function () {\n      _this.filterChanged(false);\n    }, 170);\n  });\n\n  this.playMouseClick = function () {\n    map.globalView ? __WEBPACK_IMPORTED_MODULE_7__audio__[\"g\" /* mouseClick */].volume(0.25) : __WEBPACK_IMPORTED_MODULE_7__audio__[\"g\" /* mouseClick */].volume(0.35);\n    __WEBPACK_IMPORTED_MODULE_7__audio__[\"g\" /* mouseClick */].play();\n  };\n\n  // When true the 'menu--visible' class is applied to the menu, causing it to animate into view.\n  this.menuVisible = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  this.numberOfTimesUserHasOpenedMenu = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(0);\n\n  this.userHasSeenMenuButton = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  // This observable makes sure the menu border colours only change when\n  // the menu is toggled and not also when a filter is selected/unselected.\n  this.menuHasBeenToggled = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  // Triggered each time the arrow button is clicked. Clicking outside the menu also closes the menu\n  // due to '.fade-map-container' also having the below binding. CSS 'pointer-events' are\n  // appropriately used on '.fade-map-container' to enable this behaviour without resorting to\n  // jQuery.\n  this.toggleMenuVisibility = function () {\n    _this.menuHasBeenToggled(true);\n\n    _this.playMouseClick();\n\n    if (!_this.menuVisible()) {\n      _this.menuVisible(true);\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_7__audio__[\"m\" /* slideRight */].volume(0.55) : __WEBPACK_IMPORTED_MODULE_7__audio__[\"m\" /* slideRight */].volume(1.0);\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"m\" /* slideRight */].play();\n      _this.numberOfTimesUserHasOpenedMenu(_this.numberOfTimesUserHasOpenedMenu() + 1);\n      if (_this.numberOfTimesUserHasOpenedMenu() === 1) {\n        _this.userHasSeenMenuButton(true);\n      }\n    } else {\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_7__audio__[\"l\" /* slideLeft */].volume(0.55) : __WEBPACK_IMPORTED_MODULE_7__audio__[\"l\" /* slideLeft */].volume(1.0);\n      _this.menuVisible(false);\n      setTimeout(function () {\n        __WEBPACK_IMPORTED_MODULE_7__audio__[\"l\" /* slideLeft */].play();\n      }, 40);\n    }\n  };\n\n  // This value of this observable determines what background color the menu arrow button has.\n  // The colour varies depending on whether the menu is currently visible or not, and if the current\n  // event is a mouseover or mouseout event. See the menu arrow button's data binding in the HTML\n  // for more information.\n  this.arrowButtonEventType = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable();\n\n  this.trackArrowButtonEventType = function (data, event) {\n    _this.arrowButtonEventType(event.type);\n    if (event.type === 'mouseenter') {\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_7__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].volume(0.35) : __WEBPACK_IMPORTED_MODULE_7__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].volume(0.7);\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].play();\n    }\n  };\n\n  // The colour scheme for the page is pretty, but because of it I think some first-time users\n  // might not notice the menu button on the left of the screen. So if 15 seconds after page load\n  // the user still hasn't clicked on the menu button then we'll flash its background color 5\n  // times to get their attention.\n  window.onload = function () {\n    setTimeout(function () {\n      if (_this.userHasSeenMenuButton() === false) {\n        _this.timeToGetUsersAttention(true);\n      }\n    }, 15000);\n  };\n\n  this.timeToGetUsersAttention = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  this.flash = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  this.numberOfFlashes = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(0);\n\n  this.timeToGetUsersAttention.subscribe(function () {\n    var flashArrowButton = setInterval(function () {\n      _this.flash(true);\n      setTimeout(function () {\n        _this.flash(false);\n        _this.numberOfFlashes(_this.numberOfFlashes() + 1);\n        if (_this.numberOfFlashes() === 5) {\n          clearInterval(flashArrowButton);\n        }\n      }, 255);\n    }, 510);\n  });\n\n  this.cloudImgSrcPaths = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observableArray();\n\n  // Using Webpack's code splitting feature, we'll only download the cloud .png files if the user is\n  // viewing the site on a desktop, in which case they'll likely have a faster internet connection.\n  // By not downloading the cloud .png files on mobile we'll improve the page load speed.\n  if (window.innerWidth >= 1366) {\n    __webpack_require__.e/* import() */(0).then(__webpack_require__.bind(null, 91)).then(function (cloudsArray) {\n      cloudsArray.default.forEach(function (cloudImgSrcPath) {\n        _this.cloudImgSrcPaths.push(cloudImgSrcPath);\n      });\n    });\n  }\n\n  this.showAllIslandsOnLoad = function () {\n    __WEBPACK_IMPORTED_MODULE_1__islands__[\"a\" /* default */].forEach(function (island) {\n      return _this.islandsToList.push(new __WEBPACK_IMPORTED_MODULE_2__IslandConstructor__[\"a\" /* default */](island));\n    });\n\n    // Caches all the islands on initial page load. This is useful later for when a filter is\n    // unselected and all island names need to be displayed again in the menu. We can just pass this\n    // 'islandsCached' array to 'islandsToList' without having to loop through the Model again.\n    _this.islandsCached = _this.islandsToList();\n  }();\n\n  // Loops through the model to find out how many unique oceans there are. With this new returned\n  // array we can then create a 'foreach' binding in our View to construct a filter icon for each\n  // unique ocean.\n  this.uniqueOceans = __WEBPACK_IMPORTED_MODULE_1__islands__[\"a\" /* default */].map(function (island) {\n    return island.ocean;\n  }).filter(function (ocean, index, array) {\n    return array.indexOf(ocean) === index;\n  });\n\n  // Filters the island list and markers depending on which ocean is selected.\n  this.selectOcean = function (selectedOcean) {\n    _this.menuHasBeenToggled(false);\n    if (_this.currentlySelectedOcean() === selectedOcean) {\n      _this.currentlySelectedOcean(null);\n      _this.islandsToList(_this.islandsCached);\n      map.markers.forEach(function (marker) {\n        return marker.setMap(map);\n      });\n    } else {\n      var filteredIslands = _this.islandsCached.filter(function (island) {\n        return island.ocean === selectedOcean;\n      });\n      _this.islandsToList(filteredIslands);\n      _this.currentlySelectedOcean(selectedOcean);\n      map.markers.forEach(function (marker) {\n        marker.ocean === selectedOcean ? marker.setMap(map) : marker.setMap(null);\n      });\n    }\n  };\n\n  this.seagullSFXArePlaying = false;\n\n  this.whiteCloudFlashWhenIslandSelected = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false);\n\n  this.islandSelectedFromMenu = function (selectedIsland) {\n    if (selectedIsland !== _this.currentlySelectedIsland()) {\n      // Sets the map background color to the same colour as the ocean, so that each selected island\n      // from the menu fades into view nicely, instead of a flash of the original blue/white\n      // gradient background being briefly shown while each island loads.\n      if (map.background.style.background !== 'rgb(81, 175, 188)') {\n        map.background.style.background = 'rgb(81, 175, 188)';\n      }\n\n      _this.toggleMenuVisibility();\n\n      // Now we're gonna increase the volume of the ocean and lift the frequency of the lowpass\n      // filter from 2khz to 22khz - the limit of human hearing - so that the ocean sounds a lot\n      // closer when we zoom down to the selected island. On a related note, here's Father Ted\n      // helping us better understand physics... https://www.youtube.com/watch?v=OXypyrutq_M\n      if (map.globalView) {\n        __WEBPACK_IMPORTED_MODULE_7__audio__[\"f\" /* gainNode */].gain.exponentialRampToValueAtTime(1, __WEBPACK_IMPORTED_MODULE_7__audio__[\"c\" /* audioCtx */].currentTime + 1);\n        __WEBPACK_IMPORTED_MODULE_7__audio__[\"d\" /* biquadFilter */].frequency.exponentialRampToValueAtTime(22000, __WEBPACK_IMPORTED_MODULE_7__audio__[\"c\" /* audioCtx */].currentTime + 1);\n      }\n\n      if (!_this.seagullSFXArePlaying) {\n        __WEBPACK_IMPORTED_MODULE_7__audio__[\"k\" /* playOrStopSeagullSFX */]();\n        _this.seagullSFXArePlaying = true;\n      }\n\n      // We will now zoom in on an island, so we're no longer in 'global view'. This boolean will\n      // determine if the viewport pans to a marker when it is selected. In global view the viewport\n      // will pan, but when zoomed in on an island the viewport will not pan to the marker when\n      // clicked.\n      map.globalView = false;\n\n      setTimeout(function () {\n        _this.currentlySelectedIsland(selectedIsland);\n        map.goToSelectedIsland(_this.currentlySelectedIsland());\n        setTimeout(function () {\n          map.bounceMarker(selectedIsland, 3);\n        }, 480);\n      }, 100);\n\n      // Flashes a 100% width/height white div briefly while map loads the selected island. It's\n      // meant to give a 'passing through clouds' type of effect! :)\n      _this.whiteCloudFlashWhenIslandSelected(true);\n      setTimeout(function () {\n        return _this.whiteCloudFlashWhenIslandSelected(false);\n      }, 700);\n    } else {\n      _this.toggleMenuVisibility();\n    }\n\n    _this.activateHomeScreenLinkWhenNotInGlobalView(true);\n  };\n\n  // This binding makes the appropriate marker bounce once when an island name is hovered over in\n  // the menu in global view. It also plays the appropriate sound effect.\n  this.islandNameHover = function (island) {\n    if (map.globalView) {\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"i\" /* mouseEnterIslandNameOrHomeLink */].volume(0.3);\n      map.bounceMarker(island);\n    } else {\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"i\" /* mouseEnterIslandNameOrHomeLink */].volume(0.7);\n    }\n    __WEBPACK_IMPORTED_MODULE_7__audio__[\"i\" /* mouseEnterIslandNameOrHomeLink */].play();\n  };\n\n  // Used to throttle window resize events in the subsequent 'resize' event listener.\n  this.currentlyZoomingOrPanning = false;\n\n  window.addEventListener('resize', function () {\n    // This 'map' conditional prevents the rest of the callback from being executed if the map has\n    // not finished loading yet on initial page load.\n    if (map) {\n      // This next conditional prevents the clouds from rendering again if the user loads\n      // the application initially in desktop view, then switches to mobile view, and then\n      // switches back to desktop view. We don't want the clouds reappearing and animating again\n      // in that case. We only want the clouds to be seen after the initial page load.\n      if (_this.initialHomeScreenLoad() && window.innerWidth <= 1366) {\n        _this.initialHomeScreenLoad(false);\n      }\n      if (_this.currentlySelectedIsland() !== null) {\n        if (!_this.currentlyZoomingOrPanning) {\n          window.requestAnimationFrame(function () {\n            map.goToSelectedIsland(_this.currentlySelectedIsland());\n            _this.currentlyZoomingOrPanning = false;\n          });\n        }\n        _this.currentlyZoomingOrPanning = true;\n      } else if (!_this.currentlyZoomingOrPanning) {\n        window.requestAnimationFrame(function () {\n          var zoomLevel = Object(__WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__[\"a\" /* default */])();\n          map.setZoom(zoomLevel);\n\n          var _calculateResponsiveL = Object(__WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__[\"a\" /* default */])(),\n              lat = _calculateResponsiveL.lat,\n              lng = _calculateResponsiveL.lng;\n\n          map.setCenter({\n            lat: lat,\n            lng: lng\n          });\n          _this.currentlyZoomingOrPanning = false;\n        });\n        _this.currentlyZoomingOrPanning = true;\n      }\n    }\n    map.setOptions({\n      scrollwheel: window.innerWidth <= 768\n    });\n    _this.getWindowWidth();\n  }, { passive: true }); // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n\n  this.viewedOnDesktop = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable();\n\n  this.getWindowWidth = function () {\n    window.innerWidth >= 1366 ? _this.viewedOnDesktop(true) : _this.viewedOnDesktop(false);\n  };\n\n  this.getWindowWidth();\n\n  this.homeLinkEventType = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable();\n\n  this.trackHomeLinkEventType = function (data, event) {\n    _this.homeLinkEventType(event.type);\n    if (event.type === 'mouseenter' && !map.globalView) {\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].volume(0.7);\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].play();\n    }\n  };\n\n  // This observable ensures the clouds are only seen the first time the user loads the page, and\n  // not again if the user clicks the home screen link in the menu later on.\n  this.initialHomeScreenLoad = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(true);\n\n  // This observable is 'false' by default for the initial page load and only set to 'true' whenever\n  // an island is selected from the menu. When 'true' the image of the world map at the bottom of\n  // the world map turns from a black and white image to a color image. Clicking on this image will\n  // then take the user back to the home screen and set this observable to 'false' again.\n  this.activateHomeScreenLinkWhenNotInGlobalView = __WEBPACK_IMPORTED_MODULE_0_knockout___default.a.observable(false).extend({\n    rateLimit: 350\n  });\n\n  this.getHomeScreenLink = function () {\n    if (_this.activateHomeScreenLinkWhenNotInGlobalView()) {\n      return __WEBPACK_IMPORTED_MODULE_5__img_misc_home_screen_link_active_png___default.a;\n    }\n    return __WEBPACK_IMPORTED_MODULE_6__img_misc_home_screen_link_inactive_png___default.a;\n  };\n\n  this.backToHomeScreen = function () {\n    if (!map.globalView) {\n      if (_this.initialHomeScreenLoad()) {\n        _this.initialHomeScreenLoad(false);\n      }\n\n      setTimeout(function () {\n        map.background.style.background = 'linear-gradient(rgb(81, 175, 188) 41%, rgb(233, 240, 244) 59%)';\n        map.setOptions({\n          scrollwheel: window.innerWidth <= 768\n        });\n      }, 700);\n\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"g\" /* mouseClick */].volume(0.35);\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"g\" /* mouseClick */].play();\n      _this.menuVisible(false);\n      _this.whiteCloudFlashWhenIslandSelected(true);\n      setTimeout(function () {\n        return _this.whiteCloudFlashWhenIslandSelected(false);\n      }, 700);\n\n      setTimeout(function () {\n        var _calculateResponsiveL2 = Object(__WEBPACK_IMPORTED_MODULE_4__calculateResponsiveLatLng__[\"a\" /* default */])(),\n            lat = _calculateResponsiveL2.lat,\n            lng = _calculateResponsiveL2.lng;\n\n        map.setCenter({\n          lat: lat,\n          lng: lng\n        });\n\n        map.setZoom(Object(__WEBPACK_IMPORTED_MODULE_3__calculateInitZoomLevel__[\"a\" /* default */])());\n      }, 350);\n\n      setTimeout(function () {\n        _this.currentlySelectedIsland(null);\n      }, 100);\n\n      _this.activateHomeScreenLinkWhenNotInGlobalView(false);\n\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"f\" /* gainNode */].gain.exponentialRampToValueAtTime(0.2, __WEBPACK_IMPORTED_MODULE_7__audio__[\"c\" /* audioCtx */].currentTime + 1);\n      __WEBPACK_IMPORTED_MODULE_7__audio__[\"d\" /* biquadFilter */].frequency.exponentialRampToValueAtTime(2500, __WEBPACK_IMPORTED_MODULE_7__audio__[\"c\" /* audioCtx */].currentTime + 1.25);\n\n      if (_this.seagullSFXArePlaying) {\n        __WEBPACK_IMPORTED_MODULE_7__audio__[\"k\" /* playOrStopSeagullSFX */]();\n        _this.seagullSFXArePlaying = false;\n      }\n\n      map.globalView = true;\n    }\n  };\n} // End of ViewModel().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ViewModel);\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction IslandConstructor(island) {\n  this.name = island.name;\n  this.ocean = island.ocean;\n  this.latLngBounds = island.latLngBounds;\n  this.markerPosition = island.markerPosition;\n  this.bookExcerpt = island.bookExcerpt;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (IslandConstructor);\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABCBAMAAABTOW5MAAAAHlBMVEVMaXG3wrrR4NXT4drZ4tkZhZTi5d8fiZcZhZQlkqNtb6GWAAAACHRSTlMACitYmabt+t2aZU8AAAJTSURBVEjHpVdLbt0wDBwFeQCXatoD5CEPWb/XXCAIgq5zhW56DhYokMkN0tt2IdkmKTqxUS1ljfiZISkDw6Ji5yK587SQO8wISeEeiHBZ82b5zC1qhBwLIKtmOVopl4cLymoOo1/l+VivLne362kX9X6V5x/n+jFTpPR8dcivs3FA14xMSwHg9GTukzQQqI/ldNc+KQpEU12Ri2MK4MbEkbHbj0qkBaSWrqHTU7UQJYXUKdVe1h3y5+HsHZN2NEBk3hIGBc0ORYjK5K32HLx4iCIoWXQWhbZ9vkzZ6MyrsdKcsjqiQunEKL3CmhUh1RiZUcXpVzs9TqavAeMl35nB7yOGDwYT7ZKK+58NolsgChL4dvbl406I/YSW5bFGA8RaEEqHaA4R6gGYstR7mCmfzDU91FYpmGwaiIyQqaI790uGl7Iew+ChAtDQXYZu4yCoSUNqV+QYsd3TSmY1x5J3SjUbr+98d8JIIWKNvP11EEkhGjoO32zwmkHSKTDZD41JGNtE0B/Heej9QirHdOhlgyOG6ecw1404Usrc5JQJkUiMlDp3X+FQXwqhClWYD74kekAIGXhc+ButtA5IpiOm5ylkDACbIQOpHqOzwSlqaW02h1iO7QgQCjUfyzafEkuhc1OwLk6rKqFSzRVfcnE6AqVJWVbeJE4B9rmwHoyBiGfXaCVhpnd+DZdVl+ENEAZSJkimuSGy/4Vo/qJaElO3vpHZ77iqmyEdhuvbgZcPX8WK8n3fc5+K68ch+s/e4V/rBkhUSHyeU+ruH5Hdvy4rbSSsfzTjsPzeAMkUAAAAAElFTkSuQmCC\"\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,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\"\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.0.4\n *  howlerjs.com\n *\n *  (c) 2013-2017, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto iOS enabler.\n      self.mobileAutoEnable = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.value = vol;\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.value = muted ? 0 : self._volume;\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'running' : 'running';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Mobile browsers will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _enableMobileAudio: function() {\n      var self = this || Howler;\n\n      // Only run this on mobile devices if audio isn't already eanbled.\n      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);\n      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));\n      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {\n        return;\n      }\n\n      self._mobileEnabled = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function() {\n        // Fix Android can not play in suspend state.\n        Howler._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._mobileEnabled = true;\n          self.mobileAutoEnable = false;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchend', unlock, true);\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchend', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n        self.ctx.suspend().then(function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        });\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio on iOS.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {\n        Howler._enableMobileAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload) {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        var num = 0;\n        for (var i=0; i<self._sounds.length; i++) {\n          if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n            num++;\n            id = self._sounds[i]._id;\n          }\n        }\n\n        if (num === 1) {\n          sprite = null;\n        } else {\n          id = null;\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Makr this sounded as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          setTimeout(function() {\n            self._emit('play', sound._id);\n          }, 0);\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n      // Update the parameters of the sound\n      sound._paused = false;\n      sound._ended = false;\n      sound._sprite = sprite;\n      sound._seek = seek;\n      sound._start = self._sprite[sprite][0] / 1000;\n      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n            }, 0);\n          }\n        };\n\n        var isRunning = (Howler.state === 'running');\n        if (self._state === 'loaded' && isRunning) {\n          playWebAudio();\n        } else {\n          // Wait for the audio to load and then begin playback.\n          var event = !isRunning && self._state === 'loaded' ? 'resume' : 'load';\n          self.once(event, playWebAudio, isRunning ? sound._id : null);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n          node.play();\n\n          // Setup the new end timer.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            self._emit('play', sound._id);\n          }\n        };\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));\n        if (node.readyState === 4 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          var listener = function() {\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n      var diff = Math.abs(from - to);\n      var dir = from > to ? 'out' : 'in';\n      var steps = diff / 0.01;\n      var stepLen = (steps > 0) ? len / steps : len;\n\n      // Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.\n      if (stepLen < 4) {\n        steps = Math.ceil(steps / (4 / stepLen));\n        stepLen = 4;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          var vol = from;\n          sound._interval = setInterval(function(soundId, sound) {\n            // Update the volume amount, but only if the volume should change.\n            if (steps > 0) {\n              vol += (dir === 'in' ? 0.01 : -0.01);\n            }\n\n            // Make sure the volume is in the right bounds.\n            vol = Math.max(0, vol);\n            vol = Math.min(1, vol);\n\n            // Round to within 2 decimal points.\n            vol = Math.round(vol * 100) / 100;\n\n            // Change the volume.\n            if (self._webAudio) {\n              if (typeof id === 'undefined') {\n                self._volume = vol;\n              }\n\n              sound._volume = vol;\n            } else {\n              self.volume(vol, soundId, true);\n            }\n\n            // When the fade is complete, stop it and fire event.\n            if ((to < from && vol <= to) || (to > from && vol >= to)) {\n              clearInterval(sound._interval);\n              sound._interval = null;\n              self.volume(to, soundId);\n              self._emit('fade', soundId);\n            }\n          }.bind(self, ids[i], sound), stepLen);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            sound._rateSeek = self.seek(id[i]);\n            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.value = rate;\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return self;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Restart the playback if the sound was playing.\n          if (playing) {\n            self.play(id, true);\n          }\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node) {\n            sound._node.currentTime = seek;\n          }\n\n          self._emit('seek', id);\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n          if (!checkIE) {\n            sounds[i]._node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n          }\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n\n        // Remove the references in the global Howler object.\n        var index = Howler._howls.indexOf(self);\n        if (index >= 0) {\n          Howler._howls.splice(index, 1);\n        }\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function() {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // don't move onto the next task until this one is done\n        self.once(task.event, function() {\n          self._queue.shift();\n          self._loadQueue();\n        });\n\n        task.action();\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && self._node && !self._node.ended) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        clearTimeout(self._endTimers[id]);\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop;\n      }\n      sound._node.bufferSource.playbackRate.value = sound._rate;\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n\n      if (self._scratchBuffer) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}\n      }\n      node.bufferSource = null;\n\n      return self;\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else {\n        self._node = new Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = 'auto';\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Decode the buffer into an audio source.\n    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      }\n    }, function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    });\n  };\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.value = Howler._muted ? 0 : 1;\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (true) {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Define globally in case AMD is not available or unused.\n  if (typeof window !== 'undefined') {\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.0.4\n *  howlerjs.com\n *\n *  (c) 2013-2017, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n  \n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              sound._panner.setPosition(pan, 0, 0);\n            } else {\n              sound._panner.pan.value = pan;\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or\n   * all in the group. The most common usage is to set the 'x' position for\n   * left/right panning. Setting any value higher than 1.0 will begin to\n   * decrease the volume of the sound as it moves further away.\n   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setPosition(x, y, z);\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setOrientation(x, y, z);\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.\n   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of\n   *                      `coneOuterGain` outside this angle.\n   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.\n   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves\n   *                      away from listener. Can be `linear`, `inverse` or `exponential`.\n   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *     refDistance - (1 by default) A reference distance for reducing volume as the source\n   *                    moves away from the listener.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.\n   * \n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,\n            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,\n            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,\n            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,\n            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.panningModel = pa.panningModel;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.value = sound._stereo;\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id);\n    }\n  };\n})();\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ocean.ogg\";\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ocean.mp3\";\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/slide-left.ogg\";\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/slide-left.mp3\";\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/slide-right.ogg\";\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/slide-right.mp3\";\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/filter-change.ogg\";\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/filter-change.mp3\";\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-enter-island-name-or-home-link.ogg\";\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-enter-island-name-or-home-link.mp3\";\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-enter-arrow-button-or-marker-or-home-link.ogg\";\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-enter-arrow-button-or-marker-or-home-link.mp3\";\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-click.ogg\";\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/mouse-click.mp3\";\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ajax-success.ogg\";\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ajax-success.mp3\";\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ajax-error.ogg\";\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/ajax-error.mp3\";\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-1.ogg\";\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-1.mp3\";\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-2.ogg\";\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-2.mp3\";\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-3.ogg\";\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-3.mp3\";\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-4.ogg\";\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-4.mp3\";\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-5.ogg\";\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-5.mp3\";\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-6.ogg\";\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-6.mp3\";\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-7.ogg\";\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-7.mp3\";\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-8.ogg\";\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-8.mp3\";\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-9.ogg\";\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-9.mp3\";\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-10.ogg\";\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-10.mp3\";\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-11.ogg\";\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-11.mp3\";\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-12.ogg\";\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-12.mp3\";\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-13.ogg\";\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-13.mp3\";\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-14.ogg\";\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-14.mp3\";\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-15.ogg\";\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"sounds/seagull-15.mp3\";\n\n/***/ }),\n/* 66 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction getNumberToDivideTextboxHeightBy(currentIsland) {\n  var number = void 0;\n  switch (currentIsland) {\n    case 'Amsterdam Island':\n      number = 1.85;\n      break;\n    case 'Christmas Island':\n      number = 1.7;\n      break;\n    case 'St Kilda':\n      number = 1.875;\n      break;\n    case 'Ascension Island':\n      number = 1.74;\n      break;\n    case 'Brava':\n      number = 1.75;\n      break;\n    case 'Tristan da Cunha':\n      number = 1.7;\n      break;\n    case 'Antipodes Island':\n      number = 1.55;\n      break;\n    case 'Banaba Island':\n      number = 1.61;\n      break;\n    case 'Pingelap':\n      number = 1.55;\n      break;\n    case 'Easter Island':\n      number = 1.5;\n      break;\n    case 'Pukapuka':\n      number = 1.8;\n      break;\n    case 'Peter I Island':\n      number = 1.9;\n      break;\n    case 'Deception Island':\n      number = 1.85;\n      break;\n    case 'Rudolph Island':\n      number = 1.4;\n      break;\n    default:\n      throw new Error('Error adjusting pan position in desktop view.');\n  }\n  return number;\n} // End of getNumberToDivideTextboxHeightBy().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getNumberToDivideTextboxHeightBy);\n\n/***/ }),\n/* 67 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__islands__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__populateInfoWindow__ = __webpack_require__(68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__makeCustomMarkerIcon__ = __webpack_require__(71);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__audio__ = __webpack_require__(0);\n\n\n\n\n\n\nfunction makeMarker(position, timeout, map, mapObject, infoWindow) {\n  // We'll make two custom marker icons, each a different colour, so that the default brown\n  // marker turns green when it is hovered over, or when the relevant island name is hovered\n  // over in the menu. The markerSrcPathPosition variable is passed into makeCustomMarkerIcon()\n  // so a different angled pin image is selected each time we make a marker.\n  var markerSrcPathPosition = Math.floor(Math.random() * 3);\n  var defaultIcon = Object(__WEBPACK_IMPORTED_MODULE_2__makeCustomMarkerIcon__[\"a\" /* default */])('brown', markerSrcPathPosition, mapObject);\n  var highlightedIcon = Object(__WEBPACK_IMPORTED_MODULE_2__makeCustomMarkerIcon__[\"a\" /* default */])('green', markerSrcPathPosition, mapObject);\n\n  setTimeout(function () {\n    var markerPosition = __WEBPACK_IMPORTED_MODULE_0__islands__[\"a\" /* default */][position].markerPosition;\n    var islandName = __WEBPACK_IMPORTED_MODULE_0__islands__[\"a\" /* default */][position].name;\n    var ocean = __WEBPACK_IMPORTED_MODULE_0__islands__[\"a\" /* default */][position].ocean;\n    var marker = new mapObject.Marker({\n      icon: __WEBPACK_IMPORTED_MODULE_3__img_misc_tinygif_gif___default.a,\n      map: map,\n      position: markerPosition,\n      title: islandName,\n      ocean: ocean,\n      class: 'marker' + position,\n      optimized: false,\n      flat: true,\n      draggable: true,\n      animation: mapObject.Animation.DROP\n    });\n\n    // Setting 'marker.icon' to the 'tinygif.gif' image above and then switching it to the\n    // actual desired icon 20ms later fixes a marker flicker bug that Google have yet to\n    // address. For more info on this bug see... https://issuetracker.google.com/issues/35820791\n    // For more info on the tinygif graphic (which comes in handy for all sorts of things!)\n    // see... http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever\n    setTimeout(function () {\n      marker.setIcon(defaultIcon);\n    }, 20);\n\n    map.markers.push(marker);\n\n    // Setting each 'marker.draggable' to 'true' above prevents the markers from\n    // appearing in multiple places at once when the map is zoomed out as wide as possible. If a\n    // user actually does then try to drag a marker the marker's position is reset to it's\n    // original position on 'mouseup'.\n    marker.addListener('mouseup', function () {\n      this.setPosition(markerPosition);\n    });\n\n    // Changes the colour of a marker when a user hovers over it.\n    marker.addListener('mouseover', function () {\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_4__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].volume(0.35) : __WEBPACK_IMPORTED_MODULE_4__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].volume(0.7);\n      __WEBPACK_IMPORTED_MODULE_4__audio__[\"h\" /* mouseEnterArrowButtonOrMarkerOrHomeLink */].play();\n      this.setIcon(highlightedIcon);\n    });\n\n    marker.addListener('mouseout', function () {\n      this.setIcon(defaultIcon);\n    });\n\n    marker.addListener('click', function () {\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_4__audio__[\"g\" /* mouseClick */].volume(0.25) : __WEBPACK_IMPORTED_MODULE_4__audio__[\"g\" /* mouseClick */].volume(0.35);\n      __WEBPACK_IMPORTED_MODULE_4__audio__[\"g\" /* mouseClick */].play();\n      Object(__WEBPACK_IMPORTED_MODULE_1__populateInfoWindow__[\"a\" /* default */])(this, infoWindow, map, mapObject);\n    });\n  }, timeout);\n} // End of makeMarker().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (makeMarker);\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__styleInfoWindow__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__audio__ = __webpack_require__(0);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n\n\n\n// Populates a marker's info window, first with a spinner loading graphic, then with the ajax\n// response from the World Tides API. See https://www.worldtides.info/apidocs for more information.\nfunction populateInfoWindow(marker, infoWindow, map, mapObject) {\n  // This function isn't called until we get an AJAX response/error.\n  function showCloseButton() {\n    // See the following link for more info on reasons for using setTimeout with a 0ms delay...\n    // https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful\n    // ...in our case, we need to do it or else the 'img.src' switch is done too early\n    // then overwritten again.\n    setTimeout(function () {\n      // This unhides the 'x' close button in the info window, which is set to 'display: none'\n      // while the loading spinner is shown. We then replace the close button image itself with\n      // one that has a transparent background, so that it blends nicely with the background\n      // color of the info window.\n      var nearestRetrievableClass = document.getElementsByClassName('gm-style-iw')[0];\n      var closeButton = nearestRetrievableClass.nextSibling;\n      closeButton.style.display = 'block';\n      var img = closeButton.firstChild;\n      img.setAttribute('src', __WEBPACK_IMPORTED_MODULE_1__img_misc_close_button_transparent_background_gif___default.a);\n    }, 0);\n\n    mapObject.event.addListenerOnce(infoWindow, 'closeclick', function () {\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_3__audio__[\"g\" /* mouseClick */].volume(0.25) : __WEBPACK_IMPORTED_MODULE_3__audio__[\"g\" /* mouseClick */].volume(0.35);\n      __WEBPACK_IMPORTED_MODULE_3__audio__[\"g\" /* mouseClick */].play();\n      infoWindow.setContent(null);\n      infoWindow.marker = null;\n      infoWindow.close();\n    });\n  }\n\n  infoWindow.marker = marker;\n\n  // Ensures the marker only bounces three times.\n  setTimeout(function () {\n    marker.setAnimation(null);\n  }, 2150);\n\n  if (map.globalView) {\n    map.panTo(marker.position);\n  }\n\n  infoWindow.setContent('<img class=\\'infowindow__loading-spinner\\' src=\\'' + __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif___default.a + '\\'/>');\n\n  infoWindow.open(map, marker);\n  Object(__WEBPACK_IMPORTED_MODULE_2__styleInfoWindow__[\"a\" /* default */])();\n\n  var lat = marker.position.lat();\n  var lng = marker.position.lng();\n  var timestamp = Math.floor(Date.now() / 1000);\n\n  // The target url for the ajax request queries the World Tides API for predicted tide heights in\n  // the ocean surrounding the island. If the ajax request is successful the API responds with a\n  // JSON object, which contains a 'heights' array property. This array contains the predicted\n  // average tide height for each 30 minute period over the next week. By finding the time/date\n  // of the maximum tide height, the user can then be told when it's safest to approach the\n  // island, as obviously the higher the tide is then the less chance there is of hitting rocks\n  // and getting shipwrecked. Sail safe folks! :)\n  var targetUrl = 'https://www.worldtides.info/api?heights&lat=' + lat + '&lon=' + lng + '&start=' + timestamp + '&length=604800&key=bf1c3079-2eee-4c95-8e55-ebc8fc0b33cc';\n\n  fetch(targetUrl).then(function (response) {\n    if (!response.ok) {\n      throw Error(response.statusText);\n    }\n    return response.json();\n  }).then(function (data) {\n    var parsedHeights = [];\n\n    // Each object in the data.heights array contains the tide height and the date/time of\n    // that tide height. We just want the height for now, so we push each value to the\n    // 'parsedHeights' array.\n    data.heights.forEach(function (item) {\n      return parsedHeights.push(item.height);\n    });\n\n    var highestTide = Math.max.apply(Math, parsedHeights);\n    var indexOfHighestTide = parsedHeights.indexOf(highestTide);\n\n    // With the index number of the highest tide, we can now go to that same index number in\n    // the original 'data.heights' array and retrieve the date and time of the highest tide.\n    var dateAndTime = data.heights[indexOfHighestTide].date;\n\n    // Lets parse that retrieved date and time into a format we can read.\n    var parsedDateAndTime = new Date(dateAndTime);\n    var string = parsedDateAndTime.toString();\n    var splitString = string.split(' ');\n\n    // Removes the time zone from the time shown eventually to the user.\n    splitString.splice(5, 4);\n\n    // Removes the seconds unit from the time eventually shown to the user,\n    // i.e. turns '21:42:00' into '21:42'.\n    splitString[4] = splitString[4].slice(0, -3);\n\n    // We'll now format the date so that its contents are unabbreviated and properly suffixed,\n    // i.e. 'Mon' will become 'Monday', 'Aug' will become 'August', '04' will become '4th', etc.\n    // Here we also enable Webpack's code splitting feature. This allows us to withhold loading\n    // certain scripts until the time they're actually needed - in our case, when a user clicks\n    // a marker. The '_unabbreviateDate' script is small - only 2kb - so it hardly makes a\n    // difference for this website, but that's besides the point. You could imagine how handy\n    // code splitting could be when scaled up to much larger projects. Projects I'd like to work\n    // on! Hire me, for god's sake! :)\n    __webpack_require__.e/* import() */(1).then(__webpack_require__.bind(null, 92)).then(function (unabbreviateDate) {\n      var dayMonthDateAndTime = unabbreviateDate.default(splitString);\n      return dayMonthDateAndTime;\n    }).then(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 4),\n          day = _ref2[0],\n          month = _ref2[1],\n          date = _ref2[2],\n          time = _ref2[3];\n\n      var safestDateAndTimeToDock = '<p class=\"infowindow__text\">According to\\n      <a class=\"infowindow__text__world-tides-link\"\\n      target=\"_blank\" href=\"https://www.worldtides.info\">World Tides</a>,\\n      the safest date and time to travel to ' + marker.title + ' over the next week is\\n      ' + day + ', ' + month + ' ' + date + ', at ' + time + '.';\n\n      infoWindow.setContent(safestDateAndTimeToDock);\n\n      // Even though the info window is already open, we're going to call its open method\n      // again so the map auto pans to fit the newly populated info window on screen. If we\n      // don't do this the info window text may not be fully readable. We'll also have to call\n      // the styleInfoWindow function again, otherwise the info window will lose its custom\n      // styling that we set first time around.\n      infoWindow.open(map, marker);\n      Object(__WEBPACK_IMPORTED_MODULE_2__styleInfoWindow__[\"a\" /* default */])();\n\n      showCloseButton();\n\n      map.globalView ? __WEBPACK_IMPORTED_MODULE_3__audio__[\"b\" /* ajaxSuccess */].volume(0.4) : __WEBPACK_IMPORTED_MODULE_3__audio__[\"b\" /* ajaxSuccess */].volume(1.0);\n      __WEBPACK_IMPORTED_MODULE_3__audio__[\"b\" /* ajaxSuccess */].play();\n    });\n  }).catch(function (err) {\n    map.globalView ? __WEBPACK_IMPORTED_MODULE_3__audio__[\"a\" /* ajaxError */].volume(0.4) : __WEBPACK_IMPORTED_MODULE_3__audio__[\"a\" /* ajaxError */].volume(1.0);\n    __WEBPACK_IMPORTED_MODULE_3__audio__[\"a\" /* ajaxError */].play();\n    infoWindow.setContent('<div class=\"infowindow__text infowindow__text--error\">Can\\'t retrieve information right now,\\n    please try again later.</div>');\n    showCloseButton();\n    throw new Error(err);\n  });\n} // End of populateInfoWindow().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (populateInfoWindow);\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/gif;base64,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\"\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n// Dynamically style the border and background of the Info Window. We have to do some pretty nasty\n// traversing of the DOM here, but I think the end result is far nicer than Google's default.\nfunction styleInfoWindow() {\n  var nearestRetrievableClass = document.getElementsByClassName('gm-style-iw')[0];\n  var infoWindowStylingDiv = nearestRetrievableClass.previousElementSibling;\n  infoWindowStylingDiv.children[1].style.borderRadius = '.75vh';\n\n  var infoWindowUnderlayerParent = infoWindowStylingDiv.children[3];\n  infoWindowUnderlayerParent.style.border = '.6vh solid rgb(172, 226, 234)';\n  infoWindowUnderlayerParent.style.borderRadius = '.75vh';\n\n  // Give the Info Window a glazed, glass-like background in desktop view, so the map can be seen\n  // passing beneath. The combination of the two divs - with different background colours and\n  // opacity settings layered on top of each other - is a subtle but nice effect I think. The same\n  // effect can also be seen on '.textbox' and '.menu__icon-arrow' in desktop view.\n  if (window.innerWidth >= 1366) {\n    var infowindowUnderlayer = document.createElement('div');\n    infowindowUnderlayer.style.backgroundColor = 'rgba(255, 255, 255, 0)';\n    infowindowUnderlayer.style.width = '100%';\n    infowindowUnderlayer.style.height = '100%';\n    infoWindowUnderlayerParent.style.backgroundColor = 'rgba(232, 244, 248, 0.875)';\n    infoWindowUnderlayerParent.appendChild(infowindowUnderlayer);\n  } else {\n    infoWindowUnderlayerParent.style.backgroundColor = 'rgb(232, 244, 248)';\n  }\n\n  // Styles the point of the infowindow.\n  var infoWindowPoint = infoWindowStylingDiv.children[2];\n\n  var _infoWindowPoint$chil = _slicedToArray(infoWindowPoint.children, 2),\n      leftSideOfPoint = _infoWindowPoint$chil[0],\n      rightSideOfPoint = _infoWindowPoint$chil[1];\n\n  leftSideOfPoint.firstChild.style.backgroundColor = 'rgb(172, 226, 234)';\n  rightSideOfPoint.firstChild.style.backgroundColor = 'rgb(172, 226, 234)';\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (styleInfoWindow);\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png__ = __webpack_require__(73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png__ = __webpack_require__(74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png__ = __webpack_require__(75);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png__ = __webpack_require__(77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png__);\n\n\n\n\n\n\n\nfunction makeCustomMarkerIcon(color, markerSrcPathPosition, mapObject) {\n  var customMarkerIcon = void 0;\n\n  // These two arrays contains src paths for pin images leaning at different angles. In the\n  // makeCustomeMarkerIcon() we will randomly select one of them for each colour, just to add a bit\n  // of variety to our pin icons.\n  var brownMarkerSrcPaths = [__WEBPACK_IMPORTED_MODULE_0__img_pins_left_leaning_brown_pin_png___default.a, __WEBPACK_IMPORTED_MODULE_1__img_pins_straight_brown_pin_png___default.a, __WEBPACK_IMPORTED_MODULE_2__img_pins_right_leaning_brown_pin_png___default.a];\n  var greenMarkerSrcPaths = [__WEBPACK_IMPORTED_MODULE_3__img_pins_left_leaning_green_pin_png___default.a, __WEBPACK_IMPORTED_MODULE_4__img_pins_straight_green_pin_png___default.a, __WEBPACK_IMPORTED_MODULE_5__img_pins_right_leaning_green_pin_png___default.a];\n\n  if (color === 'brown') {\n    var randomlySelectedBrownPin = brownMarkerSrcPaths[markerSrcPathPosition];\n    customMarkerIcon = new mapObject.MarkerImage(randomlySelectedBrownPin, new mapObject.Size(34, 40), new mapObject.Point(0, 0), new mapObject.Point(10, 34), new mapObject.Size(34, 40));\n  } else if (color === 'green') {\n    var randomlySelectedGreenPin = greenMarkerSrcPaths[markerSrcPathPosition];\n    customMarkerIcon = new mapObject.MarkerImage(randomlySelectedGreenPin, new mapObject.Size(34, 40), new mapObject.Point(0, 0), new mapObject.Point(10, 34), new mapObject.Size(34, 40));\n  }\n  return customMarkerIcon;\n} // End of makeCustomMarkerIcon().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (makeCustomMarkerIcon);\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAANlBMVEVMaXE0JiQHBwemenWab2tvUU0EBQSQZ2RkSUZ4WFRzV1F6W1eEYFx+gH+IYl+BXlrOzs+poJ9aShZfAAAAEXRSTlMAFj3+/v4o/v7+hL9L8////nTCTVsAAAGhSURBVEjH5ZbLtsMgCEVD1CSC0fb/f/YCmldXxc4vg3bQsxeHV9Jp+u8BCZGIEOEnNVLOpZTIEQjG8nVV/UEM9Og96+8Emnpq+htBI/36SVh6p/oHUULq6pNX4Ehx5ECz4BYnEYNRxAVUVyXnuAWjTclL3FOEbdtCf3SwXp6EiUGAZHbVnUky2xfAnBtm7zi8yLk9AtirAVlSaAE6M05gzo3LXpU4OiolRxjsakvR9AwMr4JWKfsgQhGMkmlLyj5T1E+zWdJcMfUANsMWthR1biFugxR8og9PPAv5JmsDH55CC+guIO8q9zY3TzpwiU6j6iKdnqKG6At2E8g51EmcTw5GCpk39PEc4MIzGRmeRNHGxu81wPPkWJ2rvttWcv5+1rmd3RYWY8zOHXmynpEAC0Dvhnhsb1evopQGEOt7BG+3u85O7y7gAn0iZe+fAC4cFkEVqERQeYueq4TEenlj7e9Il7wLcOnLrIGvfZ+X+WJGwPx67yjfFepnmA5gf+0k8pF+gpZDPY3lDeFQT6r+4Y0tjQf2tC8Av/8nEPvff/kD5DsfUH16u2cAAAAASUVORK5CYII=\"\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAASFBMVEVMaXGecW4EBQIFBQSUa2c8SxxnS0h9W1daQz+MZmKeu0xmXEimrGNTXyKinHhubjhwcXOXemavr7GFYF1yVFCpeXZ1dnjX2NmyiyVZAAAAE3RSTlMA/jYj/hT+/v7+Ps10b6Ooydv+B5ahDAAAAZVJREFUSMfV1tGSgyAMBVCBICgqteLu///pJpC2agX0celMX3rPBIRgm+Z/DN3Hoa+Fh2kG6LplMcb5oYb0JIQATFMeRzC+SPoY7yJgEVxfyEPKJ5AIijyYQAC8hTFcQxcAMNhNqga+RH4RUxenBDsQ2iJYVwGbdWO8bfNT6gmsgldOaWtt6wv7MIhV8C7jYlvK28rOzWmfKZ/AWDkbw8IVEigtgEssOKuOQJxPCM0VADeAPgBX7YfuLphhB/xdUOqG2HB4knbA2hIZqH+OAPe6mD8BOdFzf25B/LK2zxYgITaADI7zAzUAt0L3OhoYjUcqBwR8XQEhgpABNHuA4xVAIwOW2KCHK8DkK/QLUIdyz2GePnEpQWocZ6dCpIbm2/L1pFqntD4j2J8IUjb1dAKv/EmNiYHZgjGfp7fDvK/gR6WUVpk4v34G7+nZ+HGUUsVRyifkfqyTNJRkUc4r9wwJsKgAJR/Pn4eUG1Kr8Pj9gFSiDPQHXFkCbUgC/ITqeQb62qv9Da7Hm8YhUHf+bSjc5fNf/gBLMiNOeFSilgAAAABJRU5ErkJggg==\"\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAARVBMVEVMaXFeRkKHY2BQQjsdFhQODwmEYV6IYl9uUE0xJCN6fH2PameRaWXNzc6jpKWBXVmQZ2R3V1NjSUWZb2tbQz+jeHGyi4HKvLD/AAAAD3RSTlMAvrWEKUBZ/v0W+ZHm+vldvLSeAAABwklEQVRIx+1VWXbDIAy0ARthu2Ezvv9RKwkvpC2QA1Qv+crM00iaIcPwX281rwJrndWH8C0dKcXonNNi7uPXeCQEayyrrd26lBiTy3iEW+v9aNqCWMvZITN8s4k48a4gQIuhiw76IkB9X8ryCIUkZoz1ETQu6dcQAFWCcTGlIxYEz4T6pla62X2IvqRh2BCtT00XwcsGweCaCKr10wNarsKxM9D7LB9CY2YawqV4EhDLBbJ9ahoi46GHN5gEnQmMB4ZXBzAi0sC4V0eDhh2rdQGzpUSuOxUxIVjREJ/PFQtCAK8a+8/BiZciInjoJUdrdEahKNTzJlL2gytGAMBvjWHTkQ3kiAA8gidWxXizdUe8g3YqAtrsPtcslI7H1dwg8CkqLYiAD9iPoLE3Kpo2JODHvQWtRZgTecLlMLx1kNVwcnSu3NwEUMbUXtU7lrypbFgYDVXl3X6ydpob3STrBDT4o4Z3GtBNU4OAL5+wV9h2Pp2XqgGnJlPRYA/jpFQbr+QLFilHLolwrHaD12sZp1zqrFYLM30ti7wIUxePx0BCAe7ih68XNSAcY00HPszUgBfJQNP90xVIUGb4vAzK+fuXbzpcLcrEe256AAAAAElFTkSuQmCC\"\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAASFBMVEVMaXEHBwdadlVqi2BWdlF3mWspOCZyk2dfgFgEBQNjhVl5lWxylGdBYDx9f4FtjmJMbUlniF5+oHCEqXWHu4DOzs9TpDKio6Tl3rzCAAAAGHRSTlMAPb1J/f4W/v4ocdKWi/v+///////+//4HGXCpAAAB0UlEQVRIx+WWyXbDMAhFG1lCowdZTvL/f1pAchz3RDj7ski64J4HPFD68/PfA4aQlFIpwFfZIc5zztlRqEsEkjGW8iuh1UV+MCvmzyxRiSDmxxXzGXgRokQslN+IvQ8hP7X8AyBm6OYPazEYZ8K5sS9QgUMk59lpoYmEHZuzhlu0MKawngk762VZdN86MO+AtVkTMIgulLKr2Ow0AaNkQ7Jr2bZSyGscDwHyasBMEmw1e4YCom/ohClI2EZwyw4udjXuEpyPgBovriIZQl4KmTAljWqw1MdLAj/pO4jD3VjiAGi8INW0YeO4Frp2zQqCRDCnmnRTUMIGWqrpmFML6N0E2oA11SbYOVeBodcxbR65x4Plp4aJx9gToF2ltZ3f3hpEHp+bCGX9e6RMLD1gqMt93CiLUO+Pzz3Afg07QcNaeDuEl+ntHcDWaVRYku/ZZvGE0OnaSj0jssID9G7IMNE2tgKLwvweEfFMjyPiu9Ojhz4xVKA+yQyMnoKRz0RsQL3Tmr4jnX1KMRqr8DbjUyt/BHSPAvyNY7xP083fDuIKuN2f00jfFRKubgfifVL8h1wRSjQNruk6vSEYXBNnf/GLTVbBhDV5gO//J8DKOmv3C+FiJ5n3tNWzAAAAAElFTkSuQmCC\"\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAUVBMVEVMaXFPa0kEBQQEBgJHYUIAAABefFZqi2FylGh9oHGe0VKNxFCPwmlSbEiPsn1wcXNNeC15oGteikY0USGvr7Fkg1xXdFFBWT2HrHp1dnjX2NkX8WKHAAAAFXRSTlMA/ic4/hT+/v7+Gj5vx6LJbtupfP7WzvN8AAABn0lEQVRIx9WW2YKDIAxFDSKLiHWpaOf/P3QIS0etgH2cvHqPCSE3WlX/I1rlor0n7vpRCMH5six86kpQ20spUY76ZWGMTVmki/JAWMCwDKHkZvWBiCmMTgO9dPodwZBIp+iFB/iRyAAhwa4mSxiVy/CJMMgAXG67YyNiACBdkkJgC1msmgGlFKbsPaDc1cKMfbnVU529OTUGgEVgKMxGx8VfBlsPlIYJjyEF6oGuKzWmugXw+0B7AnTRD0eAlYHxCEzFkk6AVgXD2Uk9nMFenMoa7gNYKZ2y/rkAqE4ZVIozACsCVCULwpA7AOV2pIYc4H3A/CSBwRmEFLBz23tnIGASgNgulobBSADBoPy4lxgASwECHbrJ/QrAvgKrGxsXYyTQodJ3l8dOWUA3Pi7nSIZNbKsHp1+pJgnAjtIZwLuYm5TefR1GD/iGUjoPhCTV8fPTTRO+fp7nuiYucnoXjX6tmtRRXwQaop9G1z7uEKR+PF+PoA9EIcPjJwI+R7GmN3Dz0FXvAKss9fQAkKa6HQh8o680At/8bZBhrq+f/AJRfCapkrmKmwAAAABJRU5ErkJggg==\"\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAUVBMVEVMaXF6n20lMyEBBgFdflRXdlEpNiVqjGBniF10l2hri2EMFwtylWdJYkODhIZzk2g4XSZZcllPbEnHyMhXhmBvkWRQbkpigllKZkWAp3KBvnwzYopdAAAAFXRSTlMA/iQw/v4T/v7+WUa8tvmTd6fb+9miVutwAAAB0UlEQVRIx+2UbZaDIAxFDQKKWqutoLD/hU4SalvbIc4CJsd/fbd5+aKq/uMQ3XXAuHbqj3JIKUVwzvlm7s71V5cSan3D0S6niIuR9Ey0bbuui+yscxTvwKo72ZGDTLwAkWjgLUXLhNam7Eo1ED89ITCXS/CQ4hegTRGwDmJM8FG1NrZcdIwAET6qXoSqB1Y/RrdXPQmAAshjfsthpNlh2dxRLpbqNUHf5MlF8A07QS2H6KgaEHAHQJiCxUtogAHqJQO3uViAHRxghyJbWk3YMIwwAUszxoZSW3cg+Fkwnwe8OyIgGK+EBPlwIDvKgNfSKQMDR0fhZssrkZfUcVM5wWb0thWJNqZ8aP7lSBN1KThqXNp39OlIU2e3rgTgHexngBlQH3gUhRS4c3g58XiZeTcKq4dnE/Fz30CpiBjpfaSmvk6Zgal4nHw6XMYzBS2rsoXOXsE9HiN29TClb5ai8Ez6p3T3g/esigAu+O6G1DSJsJpaAPAJmJvdPY0gmHVSStBjkr7VBOShhQvqlaiv52SWabpwTH2tTgBVj+N66THqR5xl6O/jODHQvwDxWULg+P+yvrrfx7nPQtLKHaLZUYKaXefvLGYElK3+Hgrt//7LD/2QLY0II50UAAAAAElFTkSuQmCC\"\n\n/***/ }),\n/* 78 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// Sets the min and max zoom levels allowed so that each island is always seen at its most\n// appropriate zoom level without overflowing the browser window. Also determines the min and max\n// zoom levels to display overlay tiles at.\nfunction setMinAndMaxZoomLevels(currentIsland) {\n  var minZoomLevel = void 0;\n  var maxZoomLevel = void 0;\n  switch (currentIsland) {\n    case 'Rudolph Island':\n      minZoomLevel = 8;\n      maxZoomLevel = 9;\n      break;\n    case 'Peter I Island':\n      minZoomLevel = 9;\n      maxZoomLevel = 10;\n      break;\n    case 'Deception Island':\n      minZoomLevel = 9;\n      maxZoomLevel = 11;\n      break;\n    case 'Easter Island':\n      minZoomLevel = 10;\n      maxZoomLevel = 12;\n      break;\n    case 'Tristan da Cunha':\n      minZoomLevel = 10;\n      maxZoomLevel = 12;\n      break;\n    case 'Christmas Island':\n      minZoomLevel = 10;\n      maxZoomLevel = 12;\n      break;\n    case 'Amsterdam Island':\n      minZoomLevel = 9;\n      maxZoomLevel = 12;\n      break;\n    case 'Brava':\n      minZoomLevel = 11;\n      maxZoomLevel = 13;\n      break;\n    case 'Antipodes Island':\n      minZoomLevel = 11;\n      maxZoomLevel = 13;\n      break;\n    case 'Ascension Island':\n      minZoomLevel = 10;\n      maxZoomLevel = 13;\n      break;\n    case 'St Kilda':\n      minZoomLevel = 10;\n      maxZoomLevel = 13;\n      break;\n    case 'Pukapuka':\n      minZoomLevel = 11;\n      maxZoomLevel = 13;\n      break;\n    case 'Banaba Island':\n      minZoomLevel = 12;\n      maxZoomLevel = 14;\n      break;\n    case 'Pingelap':\n      minZoomLevel = 13;\n      maxZoomLevel = 14;\n      break;\n    default:\n      throw new Error('Error setting minimum and maximum zoom levels.');\n  }\n\n  return [minZoomLevel, maxZoomLevel];\n} // End of setMinAndMaxZoomLevels().\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (setMinAndMaxZoomLevels);\n\n/***/ }),\n/* 79 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif__);\n\n// This code is modified from examples provided by the Google Developers site and Maptiler,\n// and to be honest I'm not entirely sure what some of it is doing! What's 'z2 = Math.pow()'?!\n// Seems like witchcraft to me! But it's still working after feeding it my own variables and\n// making a few adjustments, and that's the most important thing! #juniordevforlife\n//\n// https://developers.google.com/maps/documentation/javascript/examples/maptype-image\n// https://www.maptiler.com/how-to/map-processing/\nfunction getOverlayTileURL(map, mapObject, islandName, islandBounds, currentZoomLevel, overlayMinZoom, overlayMaxZoom) {\n  var tileURL = new mapObject.ImageMapType({\n    getTileUrl: function getTileUrl(coord, currentZoomLevel) {\n      var proj = map.getProjection();\n      var z2 = Math.pow(2, currentZoomLevel); // eslint-disable-line no-restricted-properties\n      var tileXSize = 256 / z2;\n      var tileYSize = 256 / z2;\n      var mapTilesBaseURL =  true ? './img/overlays/' + islandName + '/' : './src/img/overlays/' + islandName + '/';\n      var tileBounds = new mapObject.LatLngBounds(proj.fromPointToLatLng(new mapObject.Point(coord.x * tileXSize, (coord.y + 1) * tileYSize)), proj.fromPointToLatLng(new mapObject.Point((coord.x + 1) * tileXSize, coord.y * tileYSize)));\n      var y = coord.y;\n      var x = coord.x >= 0 ? coord.x : z2 + coord.x;\n      if (islandBounds.intersects(tileBounds) && overlayMinZoom <= currentZoomLevel && currentZoomLevel <= overlayMaxZoom) {\n        var url = '' + mapTilesBaseURL + currentZoomLevel + '/' + x + '/' + y + '.png';\n        return url;\n      }\n      return __WEBPACK_IMPORTED_MODULE_0__img_misc_tinygif_gif___default.a;\n    },\n\n    tileSize: new mapObject.Size(256, 256),\n    isPng: true,\n    opacity: 1.0\n  });\n\n  return tileURL;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (getOverlayTileURL);\n\n/***/ }),\n/* 80 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar mapStyles = [{\n  featureType: 'landscape',\n  elementType: 'all',\n  stylers: [{\n    lightness: -5\n  }, {\n    saturation: -24\n  }, {\n    gamma: 0.95\n  }]\n}, {\n  featureType: 'road',\n  elementType: 'all',\n  stylers: [{\n    visibility: 'on'\n  }]\n}, {\n  featureType: 'road.local',\n  elementType: 'all',\n  stylers: [{\n    lightness: 0\n  }]\n}, {\n  featureType: 'road.local',\n  elementType: 'geometry.fill',\n  stylers: [{\n    lightness: -3\n  }]\n}, {\n  featureType: 'water',\n  elementType: 'all',\n  stylers: [{\n    color: '#51AFBC'\n  }]\n}, {\n  elementType: 'labels',\n  stylers: [{\n    visibility: 'off'\n  }]\n}]; // End of mapStyles.\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (mapStyles);\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/** @module google-maps-api */\n\nvar script = __webpack_require__( 82 ),\n  promise = __webpack_require__( 83 );\n\nvar maps = null,\n  callBacks = [],\n  key;\n\nwindow.$$mapsCB = function() {\n\n  maps = google.maps;\n\n  for( var i = 0, len = callBacks.length; i < len; i++ ) {\n\n    resolve.apply( undefined, callBacks[ i ] );\n  }\n};\n\nfunction resolve( onOk, onErr, onComplete, err ) {\n\n  if( !err ) {\n\n    onOk( maps );\n\n    if( onComplete )\n      onComplete( undefined, maps );\n  } else {\n\n    onErr( err );\n\n    if( onComplete )\n      onComplete( err );\n  }\n}\n\n\n/**\n * Load a Google Maps API Object asynchronously. This module will return a Promise.\n * Which will on resolved will return the \"google.maps\" object.\n *\n * Or if you prefer you can simply use the callback instead.\n *\n * @param  {String} apikey Your Google Maps API Key\n * @param  {Function} [onComplete] A callback which will return the google.maps object\n * @return {Promise} When this promise resolves it will return the google.maps object\n *\n * @example using via promise\n *\n * ```javascript\n * var mapsapi = require( 'google-maps-api' )( 'your api key' );\n *\n * mapsapi().then( function( maps ) {\n *\n *  //use the google.maps object as you please\n * });\n * ```\n *\n * @example using via callback\n * ```javascript\n * require( 'google-maps-api' )( 'your api key', function( maps ) {\n *\n *  //use the google.maps object as you please\n * })\n * ```\n */\nmodule.exports = function( apikey, libraries, onComplete ) {\n\n  key = apikey || key;\n  if (typeof libraries == 'function') {\n    onComplete = libraries;\n    libraries = [];\n  }\n\n  return function() {\n\n    return new promise( function( onOk, onErr ) {\n\n      if( !key ) {\n\n        resolve( onOk, onErr, onComplete, new Error( 'No API key passed to require(\\'google-maps-api\\')' ) );\n      } else {\n\n        if( maps ) {\n\n          resolve( onOk, onErr, onComplete );\n        } else {\n\n          callBacks.push( [ onOk, onErr, onComplete ] );\n\n          if (callBacks.length == 1) {\n            var auth = '';\n            if (typeof key == 'string') {\n\n              auth = '&key=' + key;\n            } else if (typeof key == 'object') {\n\n              auth = '&' + Object.keys(key).map(function (k) {\n                return k + '=' + encodeURIComponent(key[k]);\n              }).join('&');\n            }\n\n            var url = 'https://maps.googleapis.com/maps/api/js?v=3&callback=$$mapsCB' + auth;\n            if (Array.isArray(libraries) && libraries.length > 0) {\n              url+='&libraries='+libraries.join(',');\n            }\n            script( url );\n          }\n        }\n      }\n    });\n  };\n};\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  * $script.js JS loader & dependency manager\n  * https://github.com/ded/script.js\n  * (c) Dustin Diaz 2014 | License MIT\n  */\n\n(function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  else this[name] = definition()\n})('$script', function () {\n  var doc = document\n    , head = doc.getElementsByTagName('head')[0]\n    , s = 'string'\n    , f = false\n    , push = 'push'\n    , readyState = 'readyState'\n    , onreadystatechange = 'onreadystatechange'\n    , list = {}\n    , ids = {}\n    , delay = {}\n    , scripts = {}\n    , scriptpath\n    , urlArgs\n\n  function every(ar, fn) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f\n    return 1\n  }\n  function each(ar, fn) {\n    every(ar, function (el) {\n      return !fn(el)\n    })\n  }\n\n  function $script(paths, idOrDone, optDone) {\n    paths = paths[push] ? paths : [paths]\n    var idOrDoneIsDone = idOrDone && idOrDone.call\n      , done = idOrDoneIsDone ? idOrDone : optDone\n      , id = idOrDoneIsDone ? paths.join('') : idOrDone\n      , queue = paths.length\n    function loopFn(item) {\n      return item.call ? item() : list[item]\n    }\n    function callback() {\n      if (!--queue) {\n        list[id] = 1\n        done && done()\n        for (var dset in delay) {\n          every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])\n        }\n      }\n    }\n    setTimeout(function () {\n      each(paths, function loading(path, force) {\n        if (path === null) return callback()\n        \n        if (!force && !/^https?:\\/\\//.test(path) && scriptpath) {\n          path = (path.indexOf('.js') === -1) ? scriptpath + path + '.js' : scriptpath + path;\n        }\n        \n        if (scripts[path]) {\n          if (id) ids[id] = 1\n          return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)\n        }\n\n        scripts[path] = 1\n        if (id) ids[id] = 1\n        create(path, callback)\n      })\n    }, 0)\n    return $script\n  }\n\n  function create(path, fn) {\n    var el = doc.createElement('script'), loaded\n    el.onload = el.onerror = el[onreadystatechange] = function () {\n      if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;\n      el.onload = el[onreadystatechange] = null\n      loaded = 1\n      scripts[path] = 2\n      fn()\n    }\n    el.async = 1\n    el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;\n    head.insertBefore(el, head.lastChild)\n  }\n\n  $script.get = create\n\n  $script.order = function (scripts, id, done) {\n    (function callback(s) {\n      s = scripts.shift()\n      !scripts.length ? $script(s, id, done) : $script(s, callback)\n    }())\n  }\n\n  $script.path = function (p) {\n    scriptpath = p\n  }\n  $script.urlArgs = function (str) {\n    urlArgs = str;\n  }\n  $script.ready = function (deps, ready, req) {\n    deps = deps[push] ? deps : [deps]\n    var missing = [];\n    !each(deps, function (dep) {\n      list[dep] || missing[push](dep);\n    }) && every(deps, function (dep) {return list[dep]}) ?\n      ready() : !function (key) {\n      delay[key] = delay[key] || []\n      delay[key][push](ready)\n      req && req(missing)\n    }(deps.join('|'))\n    return $script\n  }\n\n  $script.done = function (idOrDone) {\n    $script([null], idOrDone)\n  }\n\n  return $script\n});\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(1)\n__webpack_require__(86)\n__webpack_require__(87)\n__webpack_require__(88)\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(85);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(10)))\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Promise = __webpack_require__(1)\nvar asap = __webpack_require__(2)\n\nmodule.exports = Promise\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this\n  self.then(null, function (err) {\n    asap(function () {\n      throw err\n    })\n  })\n}\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = __webpack_require__(1)\nvar asap = __webpack_require__(2)\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nfunction ValuePromise(value) {\n  this.then = function (onFulfilled) {\n    if (typeof onFulfilled !== 'function') return this\n    return new Promise(function (resolve, reject) {\n      asap(function () {\n        try {\n          resolve(onFulfilled(value))\n        } catch (ex) {\n          reject(ex);\n        }\n      })\n    })\n  }\n}\nValuePromise.prototype = Promise.prototype\n\nvar TRUE = new ValuePromise(true)\nvar FALSE = new ValuePromise(false)\nvar NULL = new ValuePromise(null)\nvar UNDEFINED = new ValuePromise(undefined)\nvar ZERO = new ValuePromise(0)\nvar EMPTYSTRING = new ValuePromise('')\n\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value\n\n  if (value === null) return NULL\n  if (value === undefined) return UNDEFINED\n  if (value === true) return TRUE\n  if (value === false) return FALSE\n  if (value === 0) return ZERO\n  if (value === '') return EMPTYSTRING\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value))\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex)\n      })\n    }\n  }\n\n  return new ValuePromise(value)\n}\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr)\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    var remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { res(i, val) }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) { \n    reject(value);\n  });\n}\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) { \n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    })\n  });\n}\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n}\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n//This file contains then/promise specific extensions that are only useful for node.js interop\n\nvar Promise = __webpack_require__(1)\nvar asap = __webpack_require__(2)\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity\n  return function () {\n    var self = this\n    var args = Array.prototype.slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop()\n      }\n      args.push(function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      })\n      var res = fn.apply(self, args)\n      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {\n        resolve(res)\n      }\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null\n    var ctx = this\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx)\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) { reject(ex) })\n      } else {\n        asap(function () {\n          callback.call(ctx, ex)\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value)\n    })\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err)\n    })\n  })\n}\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 90 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = initLoadingScreen;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif__);\n\n\nfunction initLoadingScreen() {\n  return new Promise(function (resolve) {\n    // The loading screen UI has to be generated without using Knockout because the Knockout\n    // bindings are not applied until after the map is loaded.\n\n    // Create and append loading spinner...\n    var loadingSpinner = document.createElement('img');\n    loadingSpinner.setAttribute('src', __WEBPACK_IMPORTED_MODULE_0__img_misc_loading_gif___default.a);\n    loadingSpinner.setAttribute('class', 'loading-spinner');\n    var initMapContainerLoadingScreen = document.getElementsByClassName('init-map-container-loading-screen')[0];\n    initMapContainerLoadingScreen.appendChild(loadingSpinner);\n\n    // This conditional compensates the position of the loading spinner if the user is viewing\n    // the application in desktop mode. We want to move the loading spinner up a bit because the\n    // 'textbox' element is absolutely positioned over the map in desktop view, so it would look\n    // better if we move the loading spinner to be roughly halfway between the top border of the\n    // textbox and the top border of the viewport.\n    if (document.body.clientWidth >= 1366) {\n      var windowHeight = window.innerHeight;\n      var compensation = windowHeight / 1.775;\n      loadingSpinner.style.bottom = compensation + 'px';\n    }\n\n    // Waits till all initial DOM content is loaded, then fades the loading spinner out and resolves\n    // the promise, which in turn triggers the application to fade in to view.\n    window.addEventListener('load', function () {\n      loadingSpinner.style.opacity = 1;\n      // Fade out the loading spinner before fading in the map area...\n      setTimeout(function fadeOutLoadingSpinner() {\n        loadingSpinner.style.opacity -= 0.05;\n        if (loadingSpinner.style.opacity <= 0) {\n          loadingSpinner.style.display = 'none';\n          resolve();\n        } else {\n          requestAnimationFrame(fadeOutLoadingSpinner);\n        }\n      }, 1000);\n    }, { passive: true }); // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n  });\n}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData === 0) {\n \t\t\treturn new Promise(function(resolve) { resolve(); });\n \t\t}\n\n \t\t// a Promise means \"currently loading\".\n \t\tif(installedChunkData) {\n \t\t\treturn installedChunkData[2];\n \t\t}\n\n \t\t// setup Promise in chunk cache\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunkData[2] = promise;\n\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) {\n \t\t\t\t\tchunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\t}\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n \t\thead.appendChild(script);\n\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4bf9a09b4bc0efc74d24","import 'howler';\r\nimport oceanOGG from '../../sounds/ocean.ogg';\r\nimport oceanMP3 from '../../sounds/ocean.mp3';\r\nimport slideLeftOGG from '../../sounds/slide-left.ogg';\r\nimport slideLeftMP3 from '../../sounds/slide-left.mp3';\r\nimport slideRightOGG from '../../sounds/slide-right.ogg';\r\nimport slideRightMP3 from '../../sounds/slide-right.mp3';\r\nimport filterChangeOGG from '../../sounds/filter-change.ogg';\r\nimport filterChangeMP3 from '../../sounds/filter-change.mp3';\r\nimport mouseEnterIslandNameOrHomeLinkOGG from '../../sounds/mouse-enter-island-name-or-home-link.ogg';\r\nimport mouseEnterIslandNameOrHomeLinkMP3 from '../../sounds/mouse-enter-island-name-or-home-link.mp3';\r\nimport mouseEnterArrowButtonOrMarkerOrHomeLinkOGG from '../../sounds/mouse-enter-arrow-button-or-marker-or-home-link.ogg';\r\nimport mouseEnterArrowButtonOrMarkerOrHomeLinkMP3 from '../../sounds/mouse-enter-arrow-button-or-marker-or-home-link.mp3';\r\nimport mouseClickOGG from '../../sounds/mouse-click.ogg';\r\nimport mouseClickMP3 from '../../sounds/mouse-click.mp3';\r\nimport ajaxSuccessOGG from '../../sounds/ajax-success.ogg';\r\nimport ajaxSuccessMP3 from '../../sounds/ajax-success.mp3';\r\nimport ajaxErrorOGG from '../../sounds/ajax-error.ogg';\r\nimport ajaxErrorMP3 from '../../sounds/ajax-error.mp3';\r\nimport seagull1OGG from '../../sounds/seagull-1.ogg';\r\nimport seagull1MP3 from '../../sounds/seagull-1.mp3';\r\nimport seagull2OGG from '../../sounds/seagull-2.ogg';\r\nimport seagull2MP3 from '../../sounds/seagull-2.mp3';\r\nimport seagull3OGG from '../../sounds/seagull-3.ogg';\r\nimport seagull3MP3 from '../../sounds/seagull-3.mp3';\r\nimport seagull4OGG from '../../sounds/seagull-4.ogg';\r\nimport seagull4MP3 from '../../sounds/seagull-4.mp3';\r\nimport seagull5OGG from '../../sounds/seagull-5.ogg';\r\nimport seagull5MP3 from '../../sounds/seagull-5.mp3';\r\nimport seagull6OGG from '../../sounds/seagull-6.ogg';\r\nimport seagull6MP3 from '../../sounds/seagull-6.mp3';\r\nimport seagull7OGG from '../../sounds/seagull-7.ogg';\r\nimport seagull7MP3 from '../../sounds/seagull-7.mp3';\r\nimport seagull8OGG from '../../sounds/seagull-8.ogg';\r\nimport seagull8MP3 from '../../sounds/seagull-8.mp3';\r\nimport seagull9OGG from '../../sounds/seagull-9.ogg';\r\nimport seagull9MP3 from '../../sounds/seagull-9.mp3';\r\nimport seagull10OGG from '../../sounds/seagull-10.ogg';\r\nimport seagull10MP3 from '../../sounds/seagull-10.mp3';\r\nimport seagull11OGG from '../../sounds/seagull-11.ogg';\r\nimport seagull11MP3 from '../../sounds/seagull-11.mp3';\r\nimport seagull12OGG from '../../sounds/seagull-12.ogg';\r\nimport seagull12MP3 from '../../sounds/seagull-12.mp3';\r\nimport seagull13OGG from '../../sounds/seagull-13.ogg';\r\nimport seagull13MP3 from '../../sounds/seagull-13.mp3';\r\nimport seagull14OGG from '../../sounds/seagull-14.ogg';\r\nimport seagull14MP3 from '../../sounds/seagull-14.mp3';\r\nimport seagull15OGG from '../../sounds/seagull-15.ogg';\r\nimport seagull15MP3 from '../../sounds/seagull-15.mp3';\r\n\r\nlet oceanURL;\r\n\r\n// This is to test if the browser supports playback of '.ogg' files or not. If not, then we'll\r\n// load 'oceanMP3' instead of 'oceanOGG'.\r\nconst el = document.createElement('audio');\r\nel.canPlayType('audio/ogg') ? (oceanURL = oceanOGG) : (oceanURL = oceanMP3);\r\n\r\n// We're using the Web Audio API for playback of 'ocean.ogg/mp3' because, unlike Howler.js, it\r\n// allows us to filter our audio source. Why would we want to filter it? Well, when the user\r\n// loads the page we'll set the lowpass filter to 2khz, so the ocean sounds far away, then when they\r\n// zoom down to an island we'll raise the frequency to 22000khz, effectively disabling the filter,\r\n// so that the ocean will then sound closer to them. We'll also increase the volume. For all other\r\n// sounds we'll use Howler.js because it's got better cross-browser support and we don't need to\r\n// use filters for any of the other sounds.\r\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\r\nconst audioCtx = new AudioContext();\r\nconst ocean = audioCtx.createBufferSource();\r\nconst biquadFilter = audioCtx.createBiquadFilter(); // eslint-disable-line import/no-mutable-exports\r\nconst gainNode = audioCtx.createGain();\r\nconst request = new XMLHttpRequest();\r\n\r\nrequest.open('GET', oceanURL, true);\r\nrequest.responseType = 'arraybuffer';\r\nrequest.onload = () => {\r\n  audioCtx.decodeAudioData(request.response, buffer => {\r\n    // This setTimeout is to delay the playback of the ocean audio until the application starts\r\n    // fading into view after the initial loading screen.\r\n    setTimeout(() => {\r\n      ocean.buffer = buffer;\r\n      ocean.connect(biquadFilter);\r\n      biquadFilter.type = 'lowpass';\r\n      biquadFilter.frequency.value = 2500;\r\n      biquadFilter.connect(gainNode);\r\n      gainNode.gain.setValueAtTime(0.01, 0);\r\n      gainNode.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 2.5);\r\n      gainNode.connect(audioCtx.destination);\r\n      ocean.loop = true;\r\n    }, 1650);\r\n  }, e => {\r\n    console.log(`Error with decoding audio data: ${e.err}`);\r\n  });\r\n};\r\nrequest.send();\r\n\r\nconst slideRight = new Howl({\r\n  src: [slideRightOGG, slideRightMP3],\r\n  volume: 0.55\r\n});\r\nconst slideLeft = new Howl({\r\n  src: [slideLeftOGG, slideLeftMP3],\r\n  volume: 0.55\r\n});\r\nconst filterChange = new Howl({\r\n  src: [filterChangeOGG, filterChangeMP3],\r\n  volume: 0.3\r\n});\r\nconst mouseEnterIslandNameOrHomeLink = new Howl({\r\n  src: [mouseEnterIslandNameOrHomeLinkOGG, mouseEnterIslandNameOrHomeLinkMP3],\r\n  volume: 0.3\r\n});\r\nconst mouseEnterArrowButtonOrMarkerOrHomeLink = new Howl({\r\n  src: [mouseEnterArrowButtonOrMarkerOrHomeLinkOGG, mouseEnterArrowButtonOrMarkerOrHomeLinkMP3],\r\n  volume: 0.35\r\n});\r\nconst mouseClick = new Howl({\r\n  src: [mouseClickOGG, mouseClickMP3],\r\n  volume: 0.25\r\n});\r\nconst ajaxSuccess = new Howl({\r\n  src: [ajaxSuccessOGG, ajaxSuccessMP3],\r\n  volume: 0.4\r\n});\r\nconst ajaxError = new Howl({\r\n  src: [ajaxErrorOGG, ajaxErrorMP3],\r\n  volume: 0.4\r\n});\r\nconst seagull1 = new Howl({\r\n  src: [seagull1OGG, seagull1MP3],\r\n  volume: 0.5\r\n});\r\nconst seagull2 = new Howl({\r\n  src: [seagull2OGG, seagull2MP3],\r\n  volume: 0.6\r\n});\r\nconst seagull3 = new Howl({\r\n  src: [seagull3OGG, seagull3MP3],\r\n  volume: 0.5\r\n});\r\nconst seagull4 = new Howl({\r\n  src: [seagull4OGG, seagull4MP3],\r\n  volume: 0.6\r\n});\r\nconst seagull5 = new Howl({\r\n  src: [seagull5OGG, seagull5MP3],\r\n  volume: 1.0\r\n});\r\nconst seagull6 = new Howl({\r\n  src: [seagull6OGG, seagull6MP3],\r\n  volume: 0.5\r\n});\r\nconst seagull7 = new Howl({\r\n  src: [seagull7OGG, seagull7MP3],\r\n  volume: 0.4\r\n});\r\nconst seagull8 = new Howl({\r\n  src: [seagull8OGG, seagull8MP3],\r\n  volume: 0.1\r\n});\r\nconst seagull9 = new Howl({\r\n  src: [seagull9OGG, seagull9MP3],\r\n  volume: 0.075\r\n});\r\nconst seagull10 = new Howl({\r\n  src: [seagull10OGG, seagull10MP3],\r\n  volume: 0.05\r\n});\r\nconst seagull11 = new Howl({\r\n  src: [seagull11OGG, seagull11MP3],\r\n  volume: 0.05\r\n});\r\nconst seagull12 = new Howl({\r\n  src: [seagull12OGG, seagull12MP3],\r\n  volume: 0.1\r\n});\r\nconst seagull13 = new Howl({\r\n  src: [seagull13OGG, seagull13MP3],\r\n  volume: 0.15\r\n});\r\nconst seagull14 = new Howl({\r\n  src: [seagull14OGG, seagull14MP3],\r\n  volume: 0.7\r\n});\r\nconst seagull15 = new Howl({\r\n  src: [seagull15OGG, seagull15MP3],\r\n  volume: 0.35\r\n});\r\n\r\nconst seagulls = [];\r\n\r\nseagulls.push(seagull1, seagull2, seagull3, seagull4, seagull5, seagull6, seagull7, seagull8,\r\n  seagull9, seagull10, seagull11, seagull12, seagull13, seagull14, seagull15);\r\n\r\n// Randomises the playback of the seagull sfx, or else stops it altogether when user clicks on link\r\n// to home screen.\r\nfunction playOrStopSeagullSFX() {\r\n  if (map.globalView) {\r\n    const randomIndex = () => Math.floor(Math.random() * 15);\r\n    const randomTimeoutDuration = () => Math.floor((Math.random() * 5000) + 1000);\r\n\r\n    let lastSelectedSeagull = null;\r\n\r\n    /* eslint-disable  no-underscore-dangle, no-inner-declarations */\r\n    function playRandomlySelectedSeagull() {\r\n      if (!map.globalView) {\r\n        const randomlySelectedSeagull = seagulls[randomIndex()];\r\n        if (randomlySelectedSeagull._src === lastSelectedSeagull) {\r\n          playRandomlySelectedSeagull();\r\n        } else {\r\n          randomlySelectedSeagull.play();\r\n          lastSelectedSeagull = randomlySelectedSeagull._src;\r\n          setTimeout(() => {\r\n            playRandomlySelectedSeagull();\r\n          }, randomTimeoutDuration());\r\n        }\r\n      }\r\n    }\r\n    /* eslint-enable  no-underscore-dangle, no-innerdeclarations */\r\n\r\n    setTimeout(() => {\r\n      playRandomlySelectedSeagull();\r\n    }, 1000);\r\n  } else if (!map.globalView) {\r\n    seagulls.forEach(seagull => {\r\n      seagull.stop();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  audioCtx,\r\n  biquadFilter,\r\n  gainNode,\r\n  slideLeft,\r\n  slideRight,\r\n  filterChange,\r\n  mouseEnterIslandNameOrHomeLink,\r\n  mouseEnterArrowButtonOrMarkerOrHomeLink,\r\n  mouseClick,\r\n  ajaxSuccess,\r\n  ajaxError,\r\n  playOrStopSeagullSFX,\r\n  ocean\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/audio.js","'use strict';\n\nvar asap = require('asap')\n\nmodule.exports = Promise;\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')\n  if (typeof fn !== 'function') throw new TypeError('not a function')\n  var state = null\n  var value = null\n  var deferreds = []\n  var self = this\n\n  this.then = function(onFulfilled, onRejected) {\n    return new self.constructor(function(resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject))\n    })\n  }\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred)\n      return\n    }\n    asap(function() {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value)\n        return\n      }\n      var ret\n      try {\n        ret = cb(value)\n      }\n      catch (e) {\n        deferred.reject(e)\n        return\n      }\n      deferred.resolve(ret)\n    })\n  }\n\n  function resolve(newValue) {\n    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject)\n          return\n        }\n      }\n      state = true\n      value = newValue\n      finale()\n    } catch (e) { reject(e) }\n  }\n\n  function reject(newValue) {\n    state = false\n    value = newValue\n    finale()\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++)\n      handle(deferreds[i])\n    deferreds = null\n  }\n\n  doResolve(fn, resolve, reject)\n}\n\n\nfunction Handler(onFulfilled, onRejected, resolve, reject){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null\n  this.resolve = resolve\n  this.reject = reject\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise/lib/core.js\n// module id = 1\n// module chunks = 2","\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n// linked list of tasks (single, with head node)\nvar head = {task: void 0, next: null};\nvar tail = head;\nvar flushing = false;\nvar requestFlush = void 0;\nvar isNodeJS = false;\n\nfunction flush() {\n    /* jshint loopfunc: true */\n\n    while (head.next) {\n        head = head.next;\n        var task = head.task;\n        head.task = void 0;\n        var domain = head.domain;\n\n        if (domain) {\n            head.domain = void 0;\n            domain.enter();\n        }\n\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function() {\n                   throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    flushing = false;\n}\n\nif (typeof process !== \"undefined\" && process.nextTick) {\n    // Node.js before 0.9. Note that some fake-Node environments, like the\n    // Mocha test runner, introduce a `process` global without a `nextTick`.\n    isNodeJS = true;\n\n    requestFlush = function () {\n        process.nextTick(flush);\n    };\n\n} else if (typeof setImmediate === \"function\") {\n    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        requestFlush = setImmediate.bind(window, flush);\n    } else {\n        requestFlush = function () {\n            setImmediate(flush);\n        };\n    }\n\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    requestFlush = function () {\n        channel.port2.postMessage(0);\n    };\n\n} else {\n    // old browsers\n    requestFlush = function () {\n        setTimeout(flush, 0);\n    };\n}\n\nfunction asap(task) {\n    tail = tail.next = {\n        task: task,\n        domain: isNodeJS && process.domain,\n        next: null\n    };\n\n    if (!flushing) {\n        flushing = true;\n        requestFlush();\n    }\n};\n\nmodule.exports = asap;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/asap/asap.js\n// module id = 2\n// module chunks = 2","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 2","const islandModel = [\r\n  {\r\n    name: 'Banaba Island',\r\n    ocean: 'Pacific Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -0.8702863779015437,\r\n        lng: 169.51314448237304\r\n      },\r\n      {\r\n        lat: -0.8458702856051626,\r\n        lng: 169.55708979487304\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -0.864,\r\n      lng: 169.5352888\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The Banabans do not bury their\r\n    dead. They let the bodies hang from their huts until the flesh has decomposed, then wash the\r\n    skeleton in the sea. The head is separated from the body; the bones are stored under the houses\r\n    and the skull is kept under the stone of the terraces, on which the young men play with the\r\n    frigate birds. They dance around the tame birds and throw objects at them until they cannot\r\n    move any longer and their wings are flattened to the ground.\"</p>`\r\n  },\r\n  {\r\n    name: 'Christmas Island',\r\n    ocean: 'Indian Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -10.57091787279843,\r\n        lng: 105.48796844482422\r\n      },\r\n      {\r\n        lat: -10.408877222163513,\r\n        lng: 105.7454605102539\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -10.5075,\r\n      lng: 105.627\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The rainy season lures them\r\n    out of their holes. Every November, 120 million crabs reach sexual maturity and make their way\r\n    to the sea. A red carpet spreads over the island as they crawl over tarmac and thresholds and\r\n    climb over walls and rock faces, thrusting their shells sideways on their two strong pincers\r\n    and eight thin legs, heading for the ocean to cast their black spawn into the waves just before\r\n    the new moon.\"</p>`\r\n  },\r\n  {\r\n    name: 'St Kilda',\r\n    ocean: 'Atlantic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: 57.79148847846857,\r\n        lng: -8.657574316390992\r\n      },\r\n      {\r\n        lat: 57.83537977470486,\r\n        lng: -8.528828283676148\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: 57.808,\r\n      lng: -8.593201300033561\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The island's future is written\r\n    in its graveyard. Its children are all born in good health, but most stop feeding during their\r\n    fourth, fifth or sixth night. On the seventh day, their palates tighten and their throats\r\n    constrict, so it becomes impossible to get them to swallow anything. Their muscles twitch and\r\n    their jaws hang loose. Their eyes grow staring and they yawn a great deal; their open mouths\r\n    stretch in mocking grimaces. Some die sooner, some later: one dies on the fourth day, another\r\n    not till the twenty-first. The islanders whisper that it is the will of the Almighty. But\r\n    these are the words of pious men. The women who endure so many pregnancies and bear so few\r\n    children remain silent.\"</p>`\r\n  },\r\n  {\r\n    name: 'Brava',\r\n    ocean: 'Atlantic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: 14.806617348077948,\r\n        lng: -24.763381958007812\r\n      },\r\n      {\r\n        lat: 14.89455888825592,\r\n        lng: -24.653518676757812\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: 14.814,\r\n      lng: -24.703\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"This clenched heart lies\r\n    untameable, protected from the wind by the great volcano of the neighbouring island. Everyone\r\n    who lives here is descended from the planters who stayed behind and from their slaves; from\r\n    those who chose to move here and those who were forced to. A people with blue eyes and black\r\n    skin.\"</p>`\r\n  },\r\n  {\r\n    name: 'Antipodes Island',\r\n    ocean: 'Pacific Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -49.712995217581586,\r\n        lng: 178.71195663452147\r\n      },\r\n      {\r\n        lat: -49.65813069173961,\r\n        lng: 178.82181991577147\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -49.708,\r\n      lng: 178.765\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"This place here is\r\n    mountainous, bare of trees and the climate is rough: cold and stormy. The mild air of the Gulf\r\n    Stream is missing. Cattle that are brought here die quickly and quietly in the dun-coloured\r\n    steppes of grass. And the thunderous echo of waves breaking against the hollows of the jagged\r\n    coastline never ceases.\"</p>`\r\n  },\r\n  {\r\n    name: 'Pingelap',\r\n    ocean: 'Pacific Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: 6.201868580927629,\r\n        lng: 160.68466412000726\r\n      },\r\n      {\r\n        lat: 6.227551790678075,\r\n        lng: 160.72019802503655\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: 6.21,\r\n      lng: 160.7035\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"Even the pigs on this island\r\n    are black and white. It is as if they have been made specifically for the seventy-five people\r\n    of Pingelap who see no colour: not the fiery crimson of the sunset, not the azure of the ocean,\r\n    not the garish yellow of the ripe papaya, nor the ever-present deep green of the dense jungle\r\n    of breadfruit palms, coconut palms and mangroves.\"</p>`\r\n  },\r\n  {\r\n    name: 'Deception Island',\r\n    ocean: 'Antarctic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -63.01100977025461,\r\n        lng: -60.80487060546875\r\n      },\r\n      {\r\n        lat: -62.90314869230779,\r\n        lng: -60.45330810546875\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -62.975,\r\n      lng: -60.55\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The inhabitants call this\r\n    place New Sandefjord. It is the the southernmost whale oil processing plant in the world, with\r\n    its own fleet: two triple-masted ships, eight small whaling steamers and two large ones. Apart\r\n    from a handful of Chilean stokers, two hundred Norwegians live here, along with one woman:\r\n    Marie Betsy Rasmussen, the first female ever to be in Antarctica.\"</p>`\r\n  },\r\n  {\r\n    name: 'Easter Island',\r\n    ocean: 'Pacific Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -27.15752454916794,\r\n        lng: -109.42561912536621\r\n      },\r\n      {\r\n        lat: -27.08311708769941,\r\n        lng: -109.26082420349121\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -27.13,\r\n      lng: -109.343\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky:</span>\"Monsters dot the coastline.\r\n    Hollow-eyed beings with elongated ears, weather beaten skin and pouting lips like sullen\r\n    children. No ones knows now how high the giant palms that once covered the island grew. The sap\r\n    that flowed from their trunks was fermented into wine sweet as honey; the wood was made into\r\n    rafts and ropes to transport the statues.\"</p>`\r\n  },\r\n  {\r\n    name: 'Amsterdam Island',\r\n    ocean: 'Indian Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -37.86677966037226,\r\n        lng: 77.48879623413086\r\n      },\r\n      {\r\n        lat: -37.80170309418536,\r\n        lng: 77.6175422668457\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -37.865,\r\n      lng: 77.571\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"No\r\n    one is allowed to settle here, so the personnel at the research station changes constantly.\r\n    Some of the men stay for only a few months, but most for a year and a half, on the island that\r\n    they call simply 'Ams' or 'La Base'. None speak English and all greet each other every day with\r\n    a handshake. There is no boat. Where would they take it? This place is a stray piece of France,\r\n    a cross on a blue nowhere on the various maps of the world that are pinned to the walls,\r\n    alongside a couple of pictures of albatrosses and countless pornographic posters.\"</p>`\r\n  },\r\n  {\r\n    name: 'Tristan da Cunha',\r\n    ocean: 'Atlantic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -37.148305718626126,\r\n        lng: -12.376785278320312\r\n      },\r\n      {\r\n        lat: -37.07876566400408,\r\n        lng: -12.201004028320312\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -37.161,\r\n      lng: -12.285\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The law of this snow dome land\r\n    is simple and bold. Everyone is equal, everything is shared, and a marvelous patriarch oversees\r\n    everything. Their happiness is manifested in monogamous marriage. Nine families exchange food;\r\n    fruit and vines grow in the wild. Whoever runs aground here and wishes to stay must tell the\r\n    story of his life as if it were the story of a stranger. Those who have failed in the\r\n    larger-world are always best suited to life in utopia. A new beginning, a fundamentally better\r\n    life, another 'I' is possible.\"</p>`\r\n  },\r\n  {\r\n    name: 'Pukapuka',\r\n    ocean: 'Pacific Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -10.902952188780274,\r\n        lng: -165.8814097156494\r\n      },\r\n      {\r\n        lat: -10.862494390076495,\r\n        lng: -165.81703669929198\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -10.8575,\r\n      lng: -165.8435\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"On Pukapuka, no one cares if a\r\n    bride is a virgin. A word for 'virgin' does not even exist in their language. A woman who has a\r\n    child out of wedlock earns respect and increases her chances of marriage because she has proved\r\n    her fertility. The young people of the three villages meet at the far edge of the beach once\r\n    darkness falls. There they fight, dance, sing and sleep with each other. It is common for more\r\n    than two people to get together. Sex is a game, and jealousy has no place.\"</p>`\r\n  },\r\n  {\r\n    name: 'Ascension Island',\r\n    ocean: 'Atlantic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -7.989998597281406,\r\n        lng: -14.453201293945312\r\n      },\r\n      {\r\n        lat: -7.893260056660305,\r\n        lng: -14.277420043945312\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -7.975,\r\n      lng: -14.3620632\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"It is a working island for\r\n    telecommunications operators and spies, and a landing site for the cables that run along the\r\n    floor of the Atlantic Ocean to connect the continents. NASA stretches out its feelers here,\r\n    building a tracking facility for intercontinental missiles and scattering glistening white\r\n    parabolic antennae all over the land. They are eavesdropping on the continents, listening to\r\n    the world, to the universe, to the infinity of outer space.\"</p>`\r\n  },\r\n  {\r\n    name: 'Peter I Island',\r\n    ocean: 'Antarctic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: -68.89314425766871,\r\n        lng: -90.86018371582031\r\n      },\r\n      {\r\n        lat: -68.7196278699082,\r\n        lng: -90.33283996582031\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: -68.825,\r\n      lng: -90.54\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The island does not have a\r\n    single sheltering bay, let alone a harbour; only a couple of narrow beaches of black rock and\r\n    glaciers that stretch their tongues into the ocean. It is impossible to reach. There is nothing\r\n    more to say about a land that no one has set foot on.\"</p>`\r\n  },\r\n  {\r\n    name: 'Rudolph Island',\r\n    ocean: 'Arctic Ocean',\r\n    latLngBounds: [\r\n      {\r\n        lat: 81.66662935417675,\r\n        lng: 58.090328216552734\r\n      },\r\n      {\r\n        lat: 81.86798544884091,\r\n        lng: 59.120296478271484\r\n      }\r\n    ],\r\n    markerPosition: {\r\n      lat: 81.76791878109108,\r\n      lng: 58.60531234741211\r\n    },\r\n    bookExcerpt: `<p class=\"textbox__text--book-excerpt\">\r\n    <span class=\"textbox__text--schalansky-span\">Schalansky: </span>\"The landscape is barren, bare\r\n    and white. Like the map.\"</p>`\r\n  }\r\n]; // End of islandModel.\r\n\r\nexport default islandModel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/islands.js","/*!\n * Knockout JavaScript library v3.4.2\n * (c) The Knockout.js team - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function(){\nvar DEBUG=true;\n(function(undefined){\n    // (0, eval)('this') is a robust way of getting a reference to the global object\n    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023\n    var window = this || (0, eval)('this'),\n        document = window['document'],\n        navigator = window['navigator'],\n        jQueryInstance = window[\"jQuery\"],\n        JSON = window[\"JSON\"];\n(function(factory) {\n    // Support three module loading scenarios\n    if (typeof define === 'function' && define['amd']) {\n        // [1] AMD anonymous module\n        define(['exports', 'require'], factory);\n    } else if (typeof exports === 'object' && typeof module === 'object') {\n        // [2] CommonJS/Node.js\n        factory(module['exports'] || exports);  // module.exports is for Node.js\n    } else {\n        // [3] No module loader (plain <script> tag) - put directly in global namespace\n        factory(window['ko'] = {});\n    }\n}(function(koExports, amdRequire){\n// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).\n// In the future, the following \"ko\" variable may be made distinct from \"koExports\" so that private objects are not externally reachable.\nvar ko = typeof koExports !== 'undefined' ? koExports : {};\n// Google Closure Compiler helpers (used only to make the minified file smaller)\nko.exportSymbol = function(koPath, object) {\n    var tokens = koPath.split(\".\");\n\n    // In the future, \"ko\" may become distinct from \"koExports\" (so that non-exported objects are not reachable)\n    // At that point, \"target\" would be set to: (typeof koExports !== \"undefined\" ? koExports : ko)\n    var target = ko;\n\n    for (var i = 0; i < tokens.length - 1; i++)\n        target = target[tokens[i]];\n    target[tokens[tokens.length - 1]] = object;\n};\nko.exportProperty = function(owner, publicName, object) {\n    owner[publicName] = object;\n};\nko.version = \"3.4.2\";\n\nko.exportSymbol('version', ko.version);\n// For any options that may affect various areas of Knockout and aren't directly associated with data binding.\nko.options = {\n    'deferUpdates': false,\n    'useOnlyNativeEvents': false\n};\n\n//ko.exportSymbol('options', ko.options);   // 'options' isn't minified\nko.utils = (function () {\n    function objectForEach(obj, action) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                action(prop, obj[prop]);\n            }\n        }\n    }\n\n    function extend(target, source) {\n        if (source) {\n            for(var prop in source) {\n                if(source.hasOwnProperty(prop)) {\n                    target[prop] = source[prop];\n                }\n            }\n        }\n        return target;\n    }\n\n    function setPrototypeOf(obj, proto) {\n        obj.__proto__ = proto;\n        return obj;\n    }\n\n    var canSetPrototype = ({ __proto__: [] } instanceof Array);\n    var canUseSymbols = !DEBUG && typeof Symbol === 'function';\n\n    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)\n    var knownEvents = {}, knownEventTypesByEventName = {};\n    var keyEventTypeName = (navigator && /Firefox\\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';\n    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];\n    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];\n    objectForEach(knownEvents, function(eventType, knownEventsForType) {\n        if (knownEventsForType.length) {\n            for (var i = 0, j = knownEventsForType.length; i < j; i++)\n                knownEventTypesByEventName[knownEventsForType[i]] = eventType;\n        }\n    });\n    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406\n\n    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)\n    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.\n    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.\n    // If there is a future need to detect specific versions of IE10+, we will amend this.\n    var ieVersion = document && (function() {\n        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');\n\n        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment\n        while (\n            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',\n            iElems[0]\n        ) {}\n        return version > 4 ? version : undefined;\n    }());\n    var isIe6 = ieVersion === 6,\n        isIe7 = ieVersion === 7;\n\n    function isClickOnCheckableElement(element, eventType) {\n        if ((ko.utils.tagNameLower(element) !== \"input\") || !element.type) return false;\n        if (eventType.toLowerCase() != \"click\") return false;\n        var inputType = element.type;\n        return (inputType == \"checkbox\") || (inputType == \"radio\");\n    }\n\n    // For details on the pattern for changing node classes\n    // see: https://github.com/knockout/knockout/issues/1597\n    var cssClassNameRegex = /\\S+/g;\n\n    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {\n        var addOrRemoveFn;\n        if (classNames) {\n            if (typeof node.classList === 'object') {\n                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];\n                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n                    addOrRemoveFn.call(node.classList, className);\n                });\n            } else if (typeof node.className['baseVal'] === 'string') {\n                // SVG tag .classNames is an SVGAnimatedString instance\n                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);\n            } else {\n                // node.className ought to be a string.\n                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);\n            }\n        }\n    }\n\n    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {\n        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.\n        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];\n        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {\n            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);\n        });\n        obj[prop] = currentClassNames.join(\" \");\n    }\n\n    return {\n        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],\n\n        arrayForEach: function (array, action) {\n            for (var i = 0, j = array.length; i < j; i++)\n                action(array[i], i);\n        },\n\n        arrayIndexOf: function (array, item) {\n            if (typeof Array.prototype.indexOf == \"function\")\n                return Array.prototype.indexOf.call(array, item);\n            for (var i = 0, j = array.length; i < j; i++)\n                if (array[i] === item)\n                    return i;\n            return -1;\n        },\n\n        arrayFirst: function (array, predicate, predicateOwner) {\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate.call(predicateOwner, array[i], i))\n                    return array[i];\n            return null;\n        },\n\n        arrayRemoveItem: function (array, itemToRemove) {\n            var index = ko.utils.arrayIndexOf(array, itemToRemove);\n            if (index > 0) {\n                array.splice(index, 1);\n            }\n            else if (index === 0) {\n                array.shift();\n            }\n        },\n\n        arrayGetDistinctValues: function (array) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++) {\n                if (ko.utils.arrayIndexOf(result, array[i]) < 0)\n                    result.push(array[i]);\n            }\n            return result;\n        },\n\n        arrayMap: function (array, mapping) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                result.push(mapping(array[i], i));\n            return result;\n        },\n\n        arrayFilter: function (array, predicate) {\n            array = array || [];\n            var result = [];\n            for (var i = 0, j = array.length; i < j; i++)\n                if (predicate(array[i], i))\n                    result.push(array[i]);\n            return result;\n        },\n\n        arrayPushAll: function (array, valuesToPush) {\n            if (valuesToPush instanceof Array)\n                array.push.apply(array, valuesToPush);\n            else\n                for (var i = 0, j = valuesToPush.length; i < j; i++)\n                    array.push(valuesToPush[i]);\n            return array;\n        },\n\n        addOrRemoveItem: function(array, value, included) {\n            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);\n            if (existingEntryIndex < 0) {\n                if (included)\n                    array.push(value);\n            } else {\n                if (!included)\n                    array.splice(existingEntryIndex, 1);\n            }\n        },\n\n        canSetPrototype: canSetPrototype,\n\n        extend: extend,\n\n        setPrototypeOf: setPrototypeOf,\n\n        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,\n\n        objectForEach: objectForEach,\n\n        objectMap: function(source, mapping) {\n            if (!source)\n                return source;\n            var target = {};\n            for (var prop in source) {\n                if (source.hasOwnProperty(prop)) {\n                    target[prop] = mapping(source[prop], prop, source);\n                }\n            }\n            return target;\n        },\n\n        emptyDomNode: function (domNode) {\n            while (domNode.firstChild) {\n                ko.removeNode(domNode.firstChild);\n            }\n        },\n\n        moveCleanedNodesToContainerElement: function(nodes) {\n            // Ensure it's a real array, as we're about to reparent the nodes and\n            // we don't want the underlying collection to change while we're doing that.\n            var nodesArray = ko.utils.makeArray(nodes);\n            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;\n\n            var container = templateDocument.createElement('div');\n            for (var i = 0, j = nodesArray.length; i < j; i++) {\n                container.appendChild(ko.cleanNode(nodesArray[i]));\n            }\n            return container;\n        },\n\n        cloneNodes: function (nodesArray, shouldCleanNodes) {\n            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {\n                var clonedNode = nodesArray[i].cloneNode(true);\n                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);\n            }\n            return newNodesArray;\n        },\n\n        setDomNodeChildren: function (domNode, childNodes) {\n            ko.utils.emptyDomNode(domNode);\n            if (childNodes) {\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    domNode.appendChild(childNodes[i]);\n            }\n        },\n\n        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {\n            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;\n            if (nodesToReplaceArray.length > 0) {\n                var insertionPoint = nodesToReplaceArray[0];\n                var parent = insertionPoint.parentNode;\n                for (var i = 0, j = newNodesArray.length; i < j; i++)\n                    parent.insertBefore(newNodesArray[i], insertionPoint);\n                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {\n                    ko.removeNode(nodesToReplaceArray[i]);\n                }\n            }\n        },\n\n        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {\n            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile\n            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that\n            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been\n            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.\n            // So, this function translates the old \"map\" output array into its best guess of the set of current DOM nodes.\n            //\n            // Rules:\n            //   [A] Any leading nodes that have been removed should be ignored\n            //       These most likely correspond to memoization nodes that were already removed during binding\n            //       See https://github.com/knockout/knockout/pull/440\n            //   [B] Any trailing nodes that have been remove should be ignored\n            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]\n            //       See https://github.com/knockout/knockout/pull/1903\n            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,\n            //       and include any nodes that have been inserted among the previous collection\n\n            if (continuousNodeArray.length) {\n                // The parent node can be a virtual element; so get the real parent node\n                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;\n\n                // Rule [A]\n                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)\n                    continuousNodeArray.splice(0, 1);\n\n                // Rule [B]\n                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)\n                    continuousNodeArray.length--;\n\n                // Rule [C]\n                if (continuousNodeArray.length > 1) {\n                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];\n                    // Replace with the actual new continuous node set\n                    continuousNodeArray.length = 0;\n                    while (current !== last) {\n                        continuousNodeArray.push(current);\n                        current = current.nextSibling;\n                    }\n                    continuousNodeArray.push(last);\n                }\n            }\n            return continuousNodeArray;\n        },\n\n        setOptionNodeSelectionState: function (optionNode, isSelected) {\n            // IE6 sometimes throws \"unknown error\" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.\n            if (ieVersion < 7)\n                optionNode.setAttribute(\"selected\", isSelected);\n            else\n                optionNode.selected = isSelected;\n        },\n\n        stringTrim: function (string) {\n            return string === null || string === undefined ? '' :\n                string.trim ?\n                    string.trim() :\n                    string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n        },\n\n        stringStartsWith: function (string, startsWith) {\n            string = string || \"\";\n            if (startsWith.length > string.length)\n                return false;\n            return string.substring(0, startsWith.length) === startsWith;\n        },\n\n        domNodeIsContainedBy: function (node, containedByNode) {\n            if (node === containedByNode)\n                return true;\n            if (node.nodeType === 11)\n                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8\n            if (containedByNode.contains)\n                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);\n            if (containedByNode.compareDocumentPosition)\n                return (containedByNode.compareDocumentPosition(node) & 16) == 16;\n            while (node && node != containedByNode) {\n                node = node.parentNode;\n            }\n            return !!node;\n        },\n\n        domNodeIsAttachedToDocument: function (node) {\n            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);\n        },\n\n        anyDomNodeIsAttachedToDocument: function(nodes) {\n            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);\n        },\n\n        tagNameLower: function(element) {\n            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.\n            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),\n            // we don't need to do the .toLowerCase() as it will always be lower case anyway.\n            return element && element.tagName && element.tagName.toLowerCase();\n        },\n\n        catchFunctionErrors: function (delegate) {\n            return ko['onError'] ? function () {\n                try {\n                    return delegate.apply(this, arguments);\n                } catch (e) {\n                    ko['onError'] && ko['onError'](e);\n                    throw e;\n                }\n            } : delegate;\n        },\n\n        setTimeout: function (handler, timeout) {\n            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);\n        },\n\n        deferError: function (error) {\n            setTimeout(function () {\n                ko['onError'] && ko['onError'](error);\n                throw error;\n            }, 0);\n        },\n\n        registerEventHandler: function (element, eventType, handler) {\n            var wrappedHandler = ko.utils.catchFunctionErrors(handler);\n\n            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];\n            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {\n                jQueryInstance(element)['bind'](eventType, wrappedHandler);\n            } else if (!mustUseAttachEvent && typeof element.addEventListener == \"function\")\n                element.addEventListener(eventType, wrappedHandler, false);\n            else if (typeof element.attachEvent != \"undefined\") {\n                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },\n                    attachEventName = \"on\" + eventType;\n                element.attachEvent(attachEventName, attachEventHandler);\n\n                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)\n                // so to avoid leaks, we have to remove them manually. See bug #856\n                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n                    element.detachEvent(attachEventName, attachEventHandler);\n                });\n            } else\n                throw new Error(\"Browser doesn't support addEventListener or attachEvent\");\n        },\n\n        triggerEvent: function (element, eventType) {\n            if (!(element && element.nodeType))\n                throw new Error(\"element must be a DOM node when calling triggerEvent\");\n\n            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the\n            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)\n            // IE doesn't change the checked state when you trigger the click event using \"fireEvent\".\n            // In both cases, we'll use the click method instead.\n            var useClickWorkaround = isClickOnCheckableElement(element, eventType);\n\n            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {\n                jQueryInstance(element)['trigger'](eventType);\n            } else if (typeof document.createEvent == \"function\") {\n                if (typeof element.dispatchEvent == \"function\") {\n                    var eventCategory = knownEventTypesByEventName[eventType] || \"HTMLEvents\";\n                    var event = document.createEvent(eventCategory);\n                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);\n                    element.dispatchEvent(event);\n                }\n                else\n                    throw new Error(\"The supplied element doesn't support dispatchEvent\");\n            } else if (useClickWorkaround && element.click) {\n                element.click();\n            } else if (typeof element.fireEvent != \"undefined\") {\n                element.fireEvent(\"on\" + eventType);\n            } else {\n                throw new Error(\"Browser doesn't support triggering events\");\n            }\n        },\n\n        unwrapObservable: function (value) {\n            return ko.isObservable(value) ? value() : value;\n        },\n\n        peekObservable: function (value) {\n            return ko.isObservable(value) ? value.peek() : value;\n        },\n\n        toggleDomNodeCssClass: toggleDomNodeCssClass,\n\n        setTextContent: function(element, textContent) {\n            var value = ko.utils.unwrapObservable(textContent);\n            if ((value === null) || (value === undefined))\n                value = \"\";\n\n            // We need there to be exactly one child: a text node.\n            // If there are no children, more than one, or if it's not a text node,\n            // we'll clear everything and create a single text node.\n            var innerTextNode = ko.virtualElements.firstChild(element);\n            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {\n                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);\n            } else {\n                innerTextNode.data = value;\n            }\n\n            ko.utils.forceRefresh(element);\n        },\n\n        setElementName: function(element, name) {\n            element.name = name;\n\n            // Workaround IE 6/7 issue\n            // - https://github.com/SteveSanderson/knockout/issues/197\n            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/\n            if (ieVersion <= 7) {\n                try {\n                    element.mergeAttributes(document.createElement(\"<input name='\" + element.name + \"'/>\"), false);\n                }\n                catch(e) {} // For IE9 with doc mode \"IE9 Standards\" and browser mode \"IE9 Compatibility View\"\n            }\n        },\n\n        forceRefresh: function(node) {\n            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209\n            if (ieVersion >= 9) {\n                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container\n                var elem = node.nodeType == 1 ? node : node.parentNode;\n                if (elem.style)\n                    elem.style.zoom = elem.style.zoom;\n            }\n        },\n\n        ensureSelectElementIsRenderedCorrectly: function(selectElement) {\n            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.\n            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)\n            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)\n            if (ieVersion) {\n                var originalWidth = selectElement.style.width;\n                selectElement.style.width = 0;\n                selectElement.style.width = originalWidth;\n            }\n        },\n\n        range: function (min, max) {\n            min = ko.utils.unwrapObservable(min);\n            max = ko.utils.unwrapObservable(max);\n            var result = [];\n            for (var i = min; i <= max; i++)\n                result.push(i);\n            return result;\n        },\n\n        makeArray: function(arrayLikeObject) {\n            var result = [];\n            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {\n                result.push(arrayLikeObject[i]);\n            };\n            return result;\n        },\n\n        createSymbolOrString: function(identifier) {\n            return canUseSymbols ? Symbol(identifier) : identifier;\n        },\n\n        isIe6 : isIe6,\n        isIe7 : isIe7,\n        ieVersion : ieVersion,\n\n        getFormFields: function(form, fieldName) {\n            var fields = ko.utils.makeArray(form.getElementsByTagName(\"input\")).concat(ko.utils.makeArray(form.getElementsByTagName(\"textarea\")));\n            var isMatchingField = (typeof fieldName == 'string')\n                ? function(field) { return field.name === fieldName }\n                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate\n            var matches = [];\n            for (var i = fields.length - 1; i >= 0; i--) {\n                if (isMatchingField(fields[i]))\n                    matches.push(fields[i]);\n            };\n            return matches;\n        },\n\n        parseJson: function (jsonString) {\n            if (typeof jsonString == \"string\") {\n                jsonString = ko.utils.stringTrim(jsonString);\n                if (jsonString) {\n                    if (JSON && JSON.parse) // Use native parsing where available\n                        return JSON.parse(jsonString);\n                    return (new Function(\"return \" + jsonString))(); // Fallback on less safe parsing for older browsers\n                }\n            }\n            return null;\n        },\n\n        stringifyJson: function (data, replacer, space) {   // replacer and space are optional\n            if (!JSON || !JSON.stringify)\n                throw new Error(\"Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js\");\n            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);\n        },\n\n        postJson: function (urlOrForm, data, options) {\n            options = options || {};\n            var params = options['params'] || {};\n            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;\n            var url = urlOrForm;\n\n            // If we were given a form, use its 'action' URL and pick out any requested field values\n            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === \"form\")) {\n                var originalForm = urlOrForm;\n                url = originalForm.action;\n                for (var i = includeFields.length - 1; i >= 0; i--) {\n                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);\n                    for (var j = fields.length - 1; j >= 0; j--)\n                        params[fields[j].name] = fields[j].value;\n                }\n            }\n\n            data = ko.utils.unwrapObservable(data);\n            var form = document.createElement(\"form\");\n            form.style.display = \"none\";\n            form.action = url;\n            form.method = \"post\";\n            for (var key in data) {\n                // Since 'data' this is a model object, we include all properties including those inherited from its prototype\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));\n                form.appendChild(input);\n            }\n            objectForEach(params, function(key, value) {\n                var input = document.createElement(\"input\");\n                input.type = \"hidden\";\n                input.name = key;\n                input.value = value;\n                form.appendChild(input);\n            });\n            document.body.appendChild(form);\n            options['submitter'] ? options['submitter'](form) : form.submit();\n            setTimeout(function () { form.parentNode.removeChild(form); }, 0);\n        }\n    }\n}());\n\nko.exportSymbol('utils', ko.utils);\nko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);\nko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);\nko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);\nko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);\nko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);\nko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);\nko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);\nko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);\nko.exportSymbol('utils.extend', ko.utils.extend);\nko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);\nko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);\nko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);\nko.exportSymbol('utils.postJson', ko.utils.postJson);\nko.exportSymbol('utils.parseJson', ko.utils.parseJson);\nko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);\nko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);\nko.exportSymbol('utils.range', ko.utils.range);\nko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);\nko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);\nko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);\nko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);\nko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);\nko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);\nko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly\n\nif (!Function.prototype['bind']) {\n    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)\n    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js\n    Function.prototype['bind'] = function (object) {\n        var originalFunction = this;\n        if (arguments.length === 1) {\n            return function () {\n                return originalFunction.apply(object, arguments);\n            };\n        } else {\n            var partialArgs = Array.prototype.slice.call(arguments, 1);\n            return function () {\n                var args = partialArgs.slice(0);\n                args.push.apply(args, arguments);\n                return originalFunction.apply(object, args);\n            };\n        }\n    };\n}\n\nko.utils.domData = new (function () {\n    var uniqueId = 0;\n    var dataStoreKeyExpandoPropertyName = \"__ko__\" + (new Date).getTime();\n    var dataStore = {};\n\n    function getAll(node, createIfNotFound) {\n        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== \"null\") && dataStore[dataStoreKey];\n        if (!hasExistingDataStore) {\n            if (!createIfNotFound)\n                return undefined;\n            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = \"ko\" + uniqueId++;\n            dataStore[dataStoreKey] = {};\n        }\n        return dataStore[dataStoreKey];\n    }\n\n    return {\n        get: function (node, key) {\n            var allDataForNode = getAll(node, false);\n            return allDataForNode === undefined ? undefined : allDataForNode[key];\n        },\n        set: function (node, key, value) {\n            if (value === undefined) {\n                // Make sure we don't actually create a new domData key if we are actually deleting a value\n                if (getAll(node, false) === undefined)\n                    return;\n            }\n            var allDataForNode = getAll(node, true);\n            allDataForNode[key] = value;\n        },\n        clear: function (node) {\n            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];\n            if (dataStoreKey) {\n                delete dataStore[dataStoreKey];\n                node[dataStoreKeyExpandoPropertyName] = null;\n                return true; // Exposing \"did clean\" flag purely so specs can infer whether things have been cleaned up as intended\n            }\n            return false;\n        },\n\n        nextKey: function () {\n            return (uniqueId++) + dataStoreKeyExpandoPropertyName;\n        }\n    };\n})();\n\nko.exportSymbol('utils.domData', ko.utils.domData);\nko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully\n\nko.utils.domNodeDisposal = new (function () {\n    var domDataKey = ko.utils.domData.nextKey();\n    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document\n    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document\n\n    function getDisposeCallbacksCollection(node, createIfNotFound) {\n        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);\n        if ((allDisposeCallbacks === undefined) && createIfNotFound) {\n            allDisposeCallbacks = [];\n            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);\n        }\n        return allDisposeCallbacks;\n    }\n    function destroyCallbacksCollection(node) {\n        ko.utils.domData.set(node, domDataKey, undefined);\n    }\n\n    function cleanSingleNode(node) {\n        // Run all the dispose callbacks\n        var callbacks = getDisposeCallbacksCollection(node, false);\n        if (callbacks) {\n            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)\n            for (var i = 0; i < callbacks.length; i++)\n                callbacks[i](node);\n        }\n\n        // Erase the DOM data\n        ko.utils.domData.clear(node);\n\n        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)\n        ko.utils.domNodeDisposal[\"cleanExternalData\"](node);\n\n        // Clear any immediate-child comment nodes, as these wouldn't have been found by\n        // node.getElementsByTagName(\"*\") in cleanNode() (comment nodes aren't elements)\n        if (cleanableNodeTypesWithDescendants[node.nodeType])\n            cleanImmediateCommentTypeChildren(node);\n    }\n\n    function cleanImmediateCommentTypeChildren(nodeWithChildren) {\n        var child, nextChild = nodeWithChildren.firstChild;\n        while (child = nextChild) {\n            nextChild = child.nextSibling;\n            if (child.nodeType === 8)\n                cleanSingleNode(child);\n        }\n    }\n\n    return {\n        addDisposeCallback : function(node, callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"Callback must be a function\");\n            getDisposeCallbacksCollection(node, true).push(callback);\n        },\n\n        removeDisposeCallback : function(node, callback) {\n            var callbacksCollection = getDisposeCallbacksCollection(node, false);\n            if (callbacksCollection) {\n                ko.utils.arrayRemoveItem(callbacksCollection, callback);\n                if (callbacksCollection.length == 0)\n                    destroyCallbacksCollection(node);\n            }\n        },\n\n        cleanNode : function(node) {\n            // First clean this node, where applicable\n            if (cleanableNodeTypes[node.nodeType]) {\n                cleanSingleNode(node);\n\n                // ... then its descendants, where applicable\n                if (cleanableNodeTypesWithDescendants[node.nodeType]) {\n                    // Clone the descendants list in case it changes during iteration\n                    var descendants = [];\n                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName(\"*\"));\n                    for (var i = 0, j = descendants.length; i < j; i++)\n                        cleanSingleNode(descendants[i]);\n                }\n            }\n            return node;\n        },\n\n        removeNode : function(node) {\n            ko.cleanNode(node);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        },\n\n        \"cleanExternalData\" : function (node) {\n            // Special support for jQuery here because it's so commonly used.\n            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData\n            // so notify it to tear down any resources associated with the node & descendants here.\n            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == \"function\"))\n                jQueryInstance['cleanData']([node]);\n        }\n    };\n})();\nko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience\nko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience\nko.exportSymbol('cleanNode', ko.cleanNode);\nko.exportSymbol('removeNode', ko.removeNode);\nko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);\nko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);\nko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);\n(function () {\n    var none = [0, \"\", \"\"],\n        table = [1, \"<table>\", \"</table>\"],\n        tbody = [2, \"<table><tbody>\", \"</tbody></table>\"],\n        tr = [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n        select = [1, \"<select multiple='multiple'>\", \"</select>\"],\n        lookup = {\n            'thead': table,\n            'tbody': table,\n            'tfoot': table,\n            'tr': tbody,\n            'td': tr,\n            'th': tr,\n            'option': select,\n            'optgroup': select\n        },\n\n        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.\n        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;\n\n    function getWrap(tags) {\n        var m = tags.match(/^<([a-z]+)[ >]/);\n        return (m && lookup[m[1]]) || none;\n    }\n\n    function simpleHtmlParse(html, documentContext) {\n        documentContext || (documentContext = document);\n        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;\n\n        // Based on jQuery's \"clean\" function, but only accounting for table-related elements.\n        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's \"clean\" function directly\n\n        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of\n        // a descendant node. For example: \"<div><!-- mycomment -->abc</div>\" will get parsed as \"<div>abc</div>\"\n        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node\n        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.\n\n        // Trim whitespace, otherwise indexOf won't work as expected\n        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement(\"div\"),\n            wrap = getWrap(tags),\n            depth = wrap[0];\n\n        // Go to html and back, then peel off extra wrappers\n        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.\n        var markup = \"ignored<div>\" + wrap[1] + html + wrap[2] + \"</div>\";\n        if (typeof windowContext['innerShiv'] == \"function\") {\n            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding\n            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv\n            // somehow shims the native APIs so it just works anyway)\n            div.appendChild(windowContext['innerShiv'](markup));\n        } else {\n            if (mayRequireCreateElementHack) {\n                // The document.createElement('my-element') trick to enable custom elements in IE6-8\n                // only works if we assign innerHTML on an element associated with that document.\n                documentContext.appendChild(div);\n            }\n\n            div.innerHTML = markup;\n\n            if (mayRequireCreateElementHack) {\n                div.parentNode.removeChild(div);\n            }\n        }\n\n        // Move to the right depth\n        while (depth--)\n            div = div.lastChild;\n\n        return ko.utils.makeArray(div.lastChild.childNodes);\n    }\n\n    function jQueryHtmlParse(html, documentContext) {\n        // jQuery's \"parseHTML\" function was introduced in jQuery 1.8.0 and is a documented public API.\n        if (jQueryInstance['parseHTML']) {\n            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null\n        } else {\n            // For jQuery < 1.8.0, we fall back on the undocumented internal \"clean\" function.\n            var elems = jQueryInstance['clean']([html], documentContext);\n\n            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.\n            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.\n            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.\n            if (elems && elems[0]) {\n                // Find the top-most parent element that's a direct child of a document fragment\n                var elem = elems[0];\n                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)\n                    elem = elem.parentNode;\n                // ... then detach it\n                if (elem.parentNode)\n                    elem.parentNode.removeChild(elem);\n            }\n\n            return elems;\n        }\n    }\n\n    ko.utils.parseHtmlFragment = function(html, documentContext) {\n        return jQueryInstance ?\n            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible\n            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.\n    };\n\n    ko.utils.setHtml = function(node, html) {\n        ko.utils.emptyDomNode(node);\n\n        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it\n        html = ko.utils.unwrapObservable(html);\n\n        if ((html !== null) && (html !== undefined)) {\n            if (typeof html != 'string')\n                html = html.toString();\n\n            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,\n            // for example <tr> elements which are not normally allowed to exist on their own.\n            // If you've referenced jQuery we'll use that rather than duplicating its code.\n            if (jQueryInstance) {\n                jQueryInstance(node)['html'](html);\n            } else {\n                // ... otherwise, use KO's own parsing logic.\n                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);\n                for (var i = 0; i < parsedNodes.length; i++)\n                    node.appendChild(parsedNodes[i]);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);\nko.exportSymbol('utils.setHtml', ko.utils.setHtml);\n\nko.memoization = (function () {\n    var memos = {};\n\n    function randomMax8HexChars() {\n        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);\n    }\n    function generateRandomId() {\n        return randomMax8HexChars() + randomMax8HexChars();\n    }\n    function findMemoNodes(rootNode, appendToArray) {\n        if (!rootNode)\n            return;\n        if (rootNode.nodeType == 8) {\n            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);\n            if (memoId != null)\n                appendToArray.push({ domNode: rootNode, memoId: memoId });\n        } else if (rootNode.nodeType == 1) {\n            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)\n                findMemoNodes(childNodes[i], appendToArray);\n        }\n    }\n\n    return {\n        memoize: function (callback) {\n            if (typeof callback != \"function\")\n                throw new Error(\"You can only pass a function to ko.memoization.memoize()\");\n            var memoId = generateRandomId();\n            memos[memoId] = callback;\n            return \"<!--[ko_memo:\" + memoId + \"]-->\";\n        },\n\n        unmemoize: function (memoId, callbackParams) {\n            var callback = memos[memoId];\n            if (callback === undefined)\n                throw new Error(\"Couldn't find any memo with ID \" + memoId + \". Perhaps it's already been unmemoized.\");\n            try {\n                callback.apply(null, callbackParams || []);\n                return true;\n            }\n            finally { delete memos[memoId]; }\n        },\n\n        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {\n            var memos = [];\n            findMemoNodes(domNode, memos);\n            for (var i = 0, j = memos.length; i < j; i++) {\n                var node = memos[i].domNode;\n                var combinedParams = [node];\n                if (extraCallbackParamsArray)\n                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);\n                ko.memoization.unmemoize(memos[i].memoId, combinedParams);\n                node.nodeValue = \"\"; // Neuter this node so we don't try to unmemoize it again\n                if (node.parentNode)\n                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)\n            }\n        },\n\n        parseMemoText: function (memoText) {\n            var match = memoText.match(/^\\[ko_memo\\:(.*?)\\]$/);\n            return match ? match[1] : null;\n        }\n    };\n})();\n\nko.exportSymbol('memoization', ko.memoization);\nko.exportSymbol('memoization.memoize', ko.memoization.memoize);\nko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);\nko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);\nko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);\nko.tasks = (function () {\n    var scheduler,\n        taskQueue = [],\n        taskQueueLength = 0,\n        nextHandle = 1,\n        nextIndexToProcess = 0;\n\n    if (window['MutationObserver']) {\n        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+\n        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT\n        scheduler = (function (callback) {\n            var div = document.createElement(\"div\");\n            new MutationObserver(callback).observe(div, {attributes: true});\n            return function () { div.classList.toggle(\"foo\"); };\n        })(scheduledProcess);\n    } else if (document && \"onreadystatechange\" in document.createElement(\"script\")) {\n        // IE 6-10\n        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT\n        scheduler = function (callback) {\n            var script = document.createElement(\"script\");\n            script.onreadystatechange = function () {\n                script.onreadystatechange = null;\n                document.documentElement.removeChild(script);\n                script = null;\n                callback();\n            };\n            document.documentElement.appendChild(script);\n        };\n    } else {\n        scheduler = function (callback) {\n            setTimeout(callback, 0);\n        };\n    }\n\n    function processTasks() {\n        if (taskQueueLength) {\n            // Each mark represents the end of a logical group of tasks and the number of these groups is\n            // limited to prevent unchecked recursion.\n            var mark = taskQueueLength, countMarks = 0;\n\n            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue\n            for (var task; nextIndexToProcess < taskQueueLength; ) {\n                if (task = taskQueue[nextIndexToProcess++]) {\n                    if (nextIndexToProcess > mark) {\n                        if (++countMarks >= 5000) {\n                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion\n                            ko.utils.deferError(Error(\"'Too much recursion' after processing \" + countMarks + \" task groups.\"));\n                            break;\n                        }\n                        mark = taskQueueLength;\n                    }\n                    try {\n                        task();\n                    } catch (ex) {\n                        ko.utils.deferError(ex);\n                    }\n                }\n            }\n        }\n    }\n\n    function scheduledProcess() {\n        processTasks();\n\n        // Reset the queue\n        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n    }\n\n    function scheduleTaskProcessing() {\n        ko.tasks['scheduler'](scheduledProcess);\n    }\n\n    var tasks = {\n        'scheduler': scheduler,     // Allow overriding the scheduler\n\n        schedule: function (func) {\n            if (!taskQueueLength) {\n                scheduleTaskProcessing();\n            }\n\n            taskQueue[taskQueueLength++] = func;\n            return nextHandle++;\n        },\n\n        cancel: function (handle) {\n            var index = handle - (nextHandle - taskQueueLength);\n            if (index >= nextIndexToProcess && index < taskQueueLength) {\n                taskQueue[index] = null;\n            }\n        },\n\n        // For testing only: reset the queue and return the previous queue length\n        'resetForTesting': function () {\n            var length = taskQueueLength - nextIndexToProcess;\n            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;\n            return length;\n        },\n\n        runEarly: processTasks\n    };\n\n    return tasks;\n})();\n\nko.exportSymbol('tasks', ko.tasks);\nko.exportSymbol('tasks.schedule', ko.tasks.schedule);\n//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  \"cancel\" isn't minified\nko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);\nko.extenders = {\n    'throttle': function(target, timeout) {\n        // Throttling means two things:\n\n        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies\n        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate\n        target['throttleEvaluation'] = timeout;\n\n        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*\n        //     so the target cannot change value synchronously or faster than a certain rate\n        var writeTimeoutInstance = null;\n        return ko.dependentObservable({\n            'read': target,\n            'write': function(value) {\n                clearTimeout(writeTimeoutInstance);\n                writeTimeoutInstance = ko.utils.setTimeout(function() {\n                    target(value);\n                }, timeout);\n            }\n        });\n    },\n\n    'rateLimit': function(target, options) {\n        var timeout, method, limitFunction;\n\n        if (typeof options == 'number') {\n            timeout = options;\n        } else {\n            timeout = options['timeout'];\n            method = options['method'];\n        }\n\n        // rateLimit supersedes deferred updates\n        target._deferUpdates = false;\n\n        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;\n        target.limit(function(callback) {\n            return limitFunction(callback, timeout);\n        });\n    },\n\n    'deferred': function(target, options) {\n        if (options !== true) {\n            throw new Error('The \\'deferred\\' extender only accepts the value \\'true\\', because it is not supported to turn deferral off once enabled.')\n        }\n\n        if (!target._deferUpdates) {\n            target._deferUpdates = true;\n            target.limit(function (callback) {\n                var handle,\n                    ignoreUpdates = false;\n                return function () {\n                    if (!ignoreUpdates) {\n                        ko.tasks.cancel(handle);\n                        handle = ko.tasks.schedule(callback);\n\n                        try {\n                            ignoreUpdates = true;\n                            target['notifySubscribers'](undefined, 'dirty');\n                        } finally {\n                            ignoreUpdates = false;\n                        }\n                    }\n                };\n            });\n        }\n    },\n\n    'notify': function(target, notifyWhen) {\n        target[\"equalityComparer\"] = notifyWhen == \"always\" ?\n            null :  // null equalityComparer means to always notify\n            valuesArePrimitiveAndEqual;\n    }\n};\n\nvar primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };\nfunction valuesArePrimitiveAndEqual(a, b) {\n    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);\n    return oldValueIsPrimitive ? (a === b) : false;\n}\n\nfunction throttle(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            timeoutInstance = ko.utils.setTimeout(function () {\n                timeoutInstance = undefined;\n                callback();\n            }, timeout);\n        }\n    };\n}\n\nfunction debounce(callback, timeout) {\n    var timeoutInstance;\n    return function () {\n        clearTimeout(timeoutInstance);\n        timeoutInstance = ko.utils.setTimeout(callback, timeout);\n    };\n}\n\nfunction applyExtenders(requestedExtenders) {\n    var target = this;\n    if (requestedExtenders) {\n        ko.utils.objectForEach(requestedExtenders, function(key, value) {\n            var extenderHandler = ko.extenders[key];\n            if (typeof extenderHandler == 'function') {\n                target = extenderHandler(target, value) || target;\n            }\n        });\n    }\n    return target;\n}\n\nko.exportSymbol('extenders', ko.extenders);\n\nko.subscription = function (target, callback, disposeCallback) {\n    this._target = target;\n    this.callback = callback;\n    this.disposeCallback = disposeCallback;\n    this.isDisposed = false;\n    ko.exportProperty(this, 'dispose', this.dispose);\n};\nko.subscription.prototype.dispose = function () {\n    this.isDisposed = true;\n    this.disposeCallback();\n};\n\nko.subscribable = function () {\n    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);\n    ko_subscribable_fn.init(this);\n}\n\nvar defaultEvent = \"change\";\n\n// Moved out of \"limit\" to avoid the extra closure\nfunction limitNotifySubscribers(value, event) {\n    if (!event || event === defaultEvent) {\n        this._limitChange(value);\n    } else if (event === 'beforeChange') {\n        this._limitBeforeChange(value);\n    } else {\n        this._origNotifySubscribers(value, event);\n    }\n}\n\nvar ko_subscribable_fn = {\n    init: function(instance) {\n        instance._subscriptions = { \"change\": [] };\n        instance._versionNumber = 1;\n    },\n\n    subscribe: function (callback, callbackTarget, event) {\n        var self = this;\n\n        event = event || defaultEvent;\n        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;\n\n        var subscription = new ko.subscription(self, boundCallback, function () {\n            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);\n            if (self.afterSubscriptionRemove)\n                self.afterSubscriptionRemove(event);\n        });\n\n        if (self.beforeSubscriptionAdd)\n            self.beforeSubscriptionAdd(event);\n\n        if (!self._subscriptions[event])\n            self._subscriptions[event] = [];\n        self._subscriptions[event].push(subscription);\n\n        return subscription;\n    },\n\n    \"notifySubscribers\": function (valueToNotify, event) {\n        event = event || defaultEvent;\n        if (event === defaultEvent) {\n            this.updateVersion();\n        }\n        if (this.hasSubscriptionsForEvent(event)) {\n            var subs = event === defaultEvent && this._changeSubscriptions || this._subscriptions[event].slice(0);\n            try {\n                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)\n                for (var i = 0, subscription; subscription = subs[i]; ++i) {\n                    // In case a subscription was disposed during the arrayForEach cycle, check\n                    // for isDisposed on each subscription before invoking its callback\n                    if (!subscription.isDisposed)\n                        subscription.callback(valueToNotify);\n                }\n            } finally {\n                ko.dependencyDetection.end(); // End suppressing dependency detection\n            }\n        }\n    },\n\n    getVersion: function () {\n        return this._versionNumber;\n    },\n\n    hasChanged: function (versionToCheck) {\n        return this.getVersion() !== versionToCheck;\n    },\n\n    updateVersion: function () {\n        ++this._versionNumber;\n    },\n\n    limit: function(limitFunction) {\n        var self = this, selfIsObservable = ko.isObservable(self),\n            ignoreBeforeChange, notifyNextChange, previousValue, pendingValue, beforeChange = 'beforeChange';\n\n        if (!self._origNotifySubscribers) {\n            self._origNotifySubscribers = self[\"notifySubscribers\"];\n            self[\"notifySubscribers\"] = limitNotifySubscribers;\n        }\n\n        var finish = limitFunction(function() {\n            self._notificationIsPending = false;\n\n            // If an observable provided a reference to itself, access it to get the latest value.\n            // This allows computed observables to delay calculating their value until needed.\n            if (selfIsObservable && pendingValue === self) {\n                pendingValue = self._evalIfChanged ? self._evalIfChanged() : self();\n            }\n            var shouldNotify = notifyNextChange || self.isDifferent(previousValue, pendingValue);\n\n            notifyNextChange = ignoreBeforeChange = false;\n\n            if (shouldNotify) {\n                self._origNotifySubscribers(previousValue = pendingValue);\n            }\n        });\n\n        self._limitChange = function(value) {\n            self._changeSubscriptions = self._subscriptions[defaultEvent].slice(0);\n            self._notificationIsPending = ignoreBeforeChange = true;\n            pendingValue = value;\n            finish();\n        };\n        self._limitBeforeChange = function(value) {\n            if (!ignoreBeforeChange) {\n                previousValue = value;\n                self._origNotifySubscribers(value, beforeChange);\n            }\n        };\n        self._notifyNextChangeIfValueIsDifferent = function() {\n            if (self.isDifferent(previousValue, self.peek(true /*evaluate*/))) {\n                notifyNextChange = true;\n            }\n        };\n    },\n\n    hasSubscriptionsForEvent: function(event) {\n        return this._subscriptions[event] && this._subscriptions[event].length;\n    },\n\n    getSubscriptionsCount: function (event) {\n        if (event) {\n            return this._subscriptions[event] && this._subscriptions[event].length || 0;\n        } else {\n            var total = 0;\n            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {\n                if (eventName !== 'dirty')\n                    total += subscriptions.length;\n            });\n            return total;\n        }\n    },\n\n    isDifferent: function(oldValue, newValue) {\n        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);\n    },\n\n    extend: applyExtenders\n};\n\nko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);\nko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);\nko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);\n\n// For browsers that support proto assignment, we overwrite the prototype of each\n// observable instance. Since observables are functions, we need Function.prototype\n// to still be in the prototype chain.\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);\n}\n\nko.subscribable['fn'] = ko_subscribable_fn;\n\n\nko.isSubscribable = function (instance) {\n    return instance != null && typeof instance.subscribe == \"function\" && typeof instance[\"notifySubscribers\"] == \"function\";\n};\n\nko.exportSymbol('subscribable', ko.subscribable);\nko.exportSymbol('isSubscribable', ko.isSubscribable);\n\nko.computedContext = ko.dependencyDetection = (function () {\n    var outerFrames = [],\n        currentFrame,\n        lastId = 0;\n\n    // Return a unique ID that can be assigned to an observable for dependency tracking.\n    // Theoretically, you could eventually overflow the number storage size, resulting\n    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53\n    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would\n    // take over 285 years to reach that number.\n    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html\n    function getId() {\n        return ++lastId;\n    }\n\n    function begin(options) {\n        outerFrames.push(currentFrame);\n        currentFrame = options;\n    }\n\n    function end() {\n        currentFrame = outerFrames.pop();\n    }\n\n    return {\n        begin: begin,\n\n        end: end,\n\n        registerDependency: function (subscribable) {\n            if (currentFrame) {\n                if (!ko.isSubscribable(subscribable))\n                    throw new Error(\"Only subscribable things can act as dependencies\");\n                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));\n            }\n        },\n\n        ignore: function (callback, callbackTarget, callbackArgs) {\n            try {\n                begin();\n                return callback.apply(callbackTarget, callbackArgs || []);\n            } finally {\n                end();\n            }\n        },\n\n        getDependenciesCount: function () {\n            if (currentFrame)\n                return currentFrame.computed.getDependenciesCount();\n        },\n\n        isInitial: function() {\n            if (currentFrame)\n                return currentFrame.isInitial;\n        }\n    };\n})();\n\nko.exportSymbol('computedContext', ko.computedContext);\nko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);\nko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);\n\nko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);\nvar observableLatestValue = ko.utils.createSymbolOrString('_latestValue');\n\nko.observable = function (initialValue) {\n    function observable() {\n        if (arguments.length > 0) {\n            // Write\n\n            // Ignore writes if the value hasn't changed\n            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {\n                observable.valueWillMutate();\n                observable[observableLatestValue] = arguments[0];\n                observable.valueHasMutated();\n            }\n            return this; // Permits chained assignments\n        }\n        else {\n            // Read\n            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a \"read\" operation\n            return observable[observableLatestValue];\n        }\n    }\n\n    observable[observableLatestValue] = initialValue;\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(observable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(observable);\n\n    // Inherit from 'observable'\n    ko.utils.setPrototypeOfOrExtend(observable, observableFn);\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](observable, true);\n    }\n\n    return observable;\n}\n\n// Define prototype for observables\nvar observableFn = {\n    'equalityComparer': valuesArePrimitiveAndEqual,\n    peek: function() { return this[observableLatestValue]; },\n    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },\n    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observable constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);\n}\n\nvar protoProperty = ko.observable.protoProperty = '__ko_proto__';\nobservableFn[protoProperty] = ko.observable;\n\nko.hasPrototype = function(instance, prototype) {\n    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;\n    if (instance[protoProperty] === prototype) return true;\n    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain\n};\n\nko.isObservable = function (instance) {\n    return ko.hasPrototype(instance, ko.observable);\n}\nko.isWriteableObservable = function (instance) {\n    // Observable\n    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)\n        return true;\n    // Writeable dependent observable\n    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))\n        return true;\n    // Anything else\n    return false;\n}\n\nko.exportSymbol('observable', ko.observable);\nko.exportSymbol('isObservable', ko.isObservable);\nko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);\nko.exportSymbol('isWritableObservable', ko.isWriteableObservable);\nko.exportSymbol('observable.fn', observableFn);\nko.exportProperty(observableFn, 'peek', observableFn.peek);\nko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);\nko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);\nko.observableArray = function (initialValues) {\n    initialValues = initialValues || [];\n\n    if (typeof initialValues != 'object' || !('length' in initialValues))\n        throw new Error(\"The argument passed when initializing an observable array must be an array, or null, or undefined.\");\n\n    var result = ko.observable(initialValues);\n    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);\n    return result.extend({'trackArrayChanges':true});\n};\n\nko.observableArray['fn'] = {\n    'remove': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var removedValues = [];\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        for (var i = 0; i < underlyingArray.length; i++) {\n            var value = underlyingArray[i];\n            if (predicate(value)) {\n                if (removedValues.length === 0) {\n                    this.valueWillMutate();\n                }\n                removedValues.push(value);\n                underlyingArray.splice(i, 1);\n                i--;\n            }\n        }\n        if (removedValues.length) {\n            this.valueHasMutated();\n        }\n        return removedValues;\n    },\n\n    'removeAll': function (arrayOfValues) {\n        // If you passed zero args, we remove everything\n        if (arrayOfValues === undefined) {\n            var underlyingArray = this.peek();\n            var allValues = underlyingArray.slice(0);\n            this.valueWillMutate();\n            underlyingArray.splice(0, underlyingArray.length);\n            this.valueHasMutated();\n            return allValues;\n        }\n        // If you passed an arg, we interpret it as an array of entries to remove\n        if (!arrayOfValues)\n            return [];\n        return this['remove'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'destroy': function (valueOrPredicate) {\n        var underlyingArray = this.peek();\n        var predicate = typeof valueOrPredicate == \"function\" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };\n        this.valueWillMutate();\n        for (var i = underlyingArray.length - 1; i >= 0; i--) {\n            var value = underlyingArray[i];\n            if (predicate(value))\n                underlyingArray[i][\"_destroy\"] = true;\n        }\n        this.valueHasMutated();\n    },\n\n    'destroyAll': function (arrayOfValues) {\n        // If you passed zero args, we destroy everything\n        if (arrayOfValues === undefined)\n            return this['destroy'](function() { return true });\n\n        // If you passed an arg, we interpret it as an array of entries to destroy\n        if (!arrayOfValues)\n            return [];\n        return this['destroy'](function (value) {\n            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;\n        });\n    },\n\n    'indexOf': function (item) {\n        var underlyingArray = this();\n        return ko.utils.arrayIndexOf(underlyingArray, item);\n    },\n\n    'replace': function(oldItem, newItem) {\n        var index = this['indexOf'](oldItem);\n        if (index >= 0) {\n            this.valueWillMutate();\n            this.peek()[index] = newItem;\n            this.valueHasMutated();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.observableArray constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);\n}\n\n// Populate ko.observableArray.fn with read/write functions from native arrays\n// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array\n// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale\nko.utils.arrayForEach([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        // Use \"peek\" to avoid creating a subscription in any computed that we're executing in the context of\n        // (for consistency with mutating regular observables)\n        var underlyingArray = this.peek();\n        this.valueWillMutate();\n        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);\n        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);\n        this.valueHasMutated();\n        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.\n        return methodCallResult === underlyingArray ? this : methodCallResult;\n    };\n});\n\n// Populate ko.observableArray.fn with read-only functions from native arrays\nko.utils.arrayForEach([\"slice\"], function (methodName) {\n    ko.observableArray['fn'][methodName] = function () {\n        var underlyingArray = this();\n        return underlyingArray[methodName].apply(underlyingArray, arguments);\n    };\n});\n\nko.exportSymbol('observableArray', ko.observableArray);\nvar arrayChangeEventName = 'arrayChange';\nko.extenders['trackArrayChanges'] = function(target, options) {\n    // Use the provided options--each call to trackArrayChanges overwrites the previously set options\n    target.compareArrayOptions = {};\n    if (options && typeof options == \"object\") {\n        ko.utils.extend(target.compareArrayOptions, options);\n    }\n    target.compareArrayOptions['sparse'] = true;\n\n    // Only modify the target observable once\n    if (target.cacheDiffForKnownOperation) {\n        return;\n    }\n    var trackingChanges = false,\n        cachedDiff = null,\n        arrayChangeSubscription,\n        pendingNotifications = 0,\n        underlyingNotifySubscribersFunction,\n        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,\n        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;\n\n    // Watch \"subscribe\" calls, and for array change events, ensure change tracking is enabled\n    target.beforeSubscriptionAdd = function (event) {\n        if (underlyingBeforeSubscriptionAddFunction)\n            underlyingBeforeSubscriptionAddFunction.call(target, event);\n        if (event === arrayChangeEventName) {\n            trackChanges();\n        }\n    };\n    // Watch \"dispose\" calls, and for array change events, ensure change tracking is disabled when all are disposed\n    target.afterSubscriptionRemove = function (event) {\n        if (underlyingAfterSubscriptionRemoveFunction)\n            underlyingAfterSubscriptionRemoveFunction.call(target, event);\n        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n            if (underlyingNotifySubscribersFunction) {\n                target['notifySubscribers'] = underlyingNotifySubscribersFunction;\n                underlyingNotifySubscribersFunction = undefined;\n            }\n            arrayChangeSubscription.dispose();\n            trackingChanges = false;\n        }\n    };\n\n    function trackChanges() {\n        // Calling 'trackChanges' multiple times is the same as calling it once\n        if (trackingChanges) {\n            return;\n        }\n\n        trackingChanges = true;\n\n        // Intercept \"notifySubscribers\" to track how many times it was called.\n        underlyingNotifySubscribersFunction = target['notifySubscribers'];\n        target['notifySubscribers'] = function(valueToNotify, event) {\n            if (!event || event === defaultEvent) {\n                ++pendingNotifications;\n            }\n            return underlyingNotifySubscribersFunction.apply(this, arguments);\n        };\n\n        // Each time the array changes value, capture a clone so that on the next\n        // change it's possible to produce a diff\n        var previousContents = [].concat(target.peek() || []);\n        cachedDiff = null;\n        arrayChangeSubscription = target.subscribe(function(currentContents) {\n            // Make a copy of the current contents and ensure it's an array\n            currentContents = [].concat(currentContents || []);\n\n            // Compute the diff and issue notifications, but only if someone is listening\n            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {\n                var changes = getChanges(previousContents, currentContents);\n            }\n\n            // Eliminate references to the old, removed items, so they can be GCed\n            previousContents = currentContents;\n            cachedDiff = null;\n            pendingNotifications = 0;\n\n            if (changes && changes.length) {\n                target['notifySubscribers'](changes, arrayChangeEventName);\n            }\n        });\n    }\n\n    function getChanges(previousContents, currentContents) {\n        // We try to re-use cached diffs.\n        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates\n        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,\n        // notifications are issued immediately so we wouldn't be queueing up more than one.\n        if (!cachedDiff || pendingNotifications > 1) {\n            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);\n        }\n\n        return cachedDiff;\n    }\n\n    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {\n        // Only run if we're currently tracking changes for this observable array\n        // and there aren't any pending deferred notifications.\n        if (!trackingChanges || pendingNotifications) {\n            return;\n        }\n        var diff = [],\n            arrayLength = rawArray.length,\n            argsLength = args.length,\n            offset = 0;\n\n        function pushDiff(status, value, index) {\n            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };\n        }\n        switch (operationName) {\n            case 'push':\n                offset = arrayLength;\n            case 'unshift':\n                for (var index = 0; index < argsLength; index++) {\n                    pushDiff('added', args[index], offset + index);\n                }\n                break;\n\n            case 'pop':\n                offset = arrayLength - 1;\n            case 'shift':\n                if (arrayLength) {\n                    pushDiff('deleted', rawArray[offset], offset);\n                }\n                break;\n\n            case 'splice':\n                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),\n                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),\n                    endAddIndex = startIndex + argsLength - 2,\n                    endIndex = Math.max(endDeleteIndex, endAddIndex),\n                    additions = [], deletions = [];\n                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {\n                    if (index < endDeleteIndex)\n                        deletions.push(pushDiff('deleted', rawArray[index], index));\n                    if (index < endAddIndex)\n                        additions.push(pushDiff('added', args[argsIndex], index));\n                }\n                ko.utils.findMovesInArrayComparison(deletions, additions);\n                break;\n\n            default:\n                return;\n        }\n        cachedDiff = diff;\n    };\n};\nvar computedState = ko.utils.createSymbolOrString('_state');\n\nko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {\n    if (typeof evaluatorFunctionOrOptions === \"object\") {\n        // Single-parameter syntax - everything is on this \"options\" param\n        options = evaluatorFunctionOrOptions;\n    } else {\n        // Multi-parameter syntax - construct the options according to the params passed\n        options = options || {};\n        if (evaluatorFunctionOrOptions) {\n            options[\"read\"] = evaluatorFunctionOrOptions;\n        }\n    }\n    if (typeof options[\"read\"] != \"function\")\n        throw Error(\"Pass a function that returns the value of the ko.computed\");\n\n    var writeFunction = options[\"write\"];\n    var state = {\n        latestValue: undefined,\n        isStale: true,\n        isDirty: true,\n        isBeingEvaluated: false,\n        suppressDisposalUntilDisposeWhenReturnsFalse: false,\n        isDisposed: false,\n        pure: false,\n        isSleeping: false,\n        readFunction: options[\"read\"],\n        evaluatorFunctionTarget: evaluatorFunctionTarget || options[\"owner\"],\n        disposeWhenNodeIsRemoved: options[\"disposeWhenNodeIsRemoved\"] || options.disposeWhenNodeIsRemoved || null,\n        disposeWhen: options[\"disposeWhen\"] || options.disposeWhen,\n        domNodeDisposalCallback: null,\n        dependencyTracking: {},\n        dependenciesCount: 0,\n        evaluationTimeoutInstance: null\n    };\n\n    function computedObservable() {\n        if (arguments.length > 0) {\n            if (typeof writeFunction === \"function\") {\n                // Writing a value\n                writeFunction.apply(state.evaluatorFunctionTarget, arguments);\n            } else {\n                throw new Error(\"Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.\");\n            }\n            return this; // Permits chained assignments\n        } else {\n            // Reading the value\n            ko.dependencyDetection.registerDependency(computedObservable);\n            if (state.isDirty || (state.isSleeping && computedObservable.haveDependenciesChanged())) {\n                computedObservable.evaluateImmediate();\n            }\n            return state.latestValue;\n        }\n    }\n\n    computedObservable[computedState] = state;\n    computedObservable.hasWriteFunction = typeof writeFunction === \"function\";\n\n    // Inherit from 'subscribable'\n    if (!ko.utils.canSetPrototype) {\n        // 'subscribable' won't be on the prototype chain unless we put it there directly\n        ko.utils.extend(computedObservable, ko.subscribable['fn']);\n    }\n    ko.subscribable['fn'].init(computedObservable);\n\n    // Inherit from 'computed'\n    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);\n\n    if (options['pure']) {\n        state.pure = true;\n        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription\n        ko.utils.extend(computedObservable, pureComputedOverrides);\n    } else if (options['deferEvaluation']) {\n        ko.utils.extend(computedObservable, deferEvaluationOverrides);\n    }\n\n    if (ko.options['deferUpdates']) {\n        ko.extenders['deferred'](computedObservable, true);\n    }\n\n    if (DEBUG) {\n        // #1731 - Aid debugging by exposing the computed's options\n        computedObservable[\"_options\"] = options;\n    }\n\n    if (state.disposeWhenNodeIsRemoved) {\n        // Since this computed is associated with a DOM node, and we don't want to dispose the computed\n        // until the DOM node is *removed* from the document (as opposed to never having been in the document),\n        // we'll prevent disposal until \"disposeWhen\" first returns false.\n        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;\n\n        // disposeWhenNodeIsRemoved: true can be used to opt into the \"only dispose after first false result\"\n        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try\n        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't\n        // be documented or used by application code, as it's likely to change in a future version of KO.\n        if (!state.disposeWhenNodeIsRemoved.nodeType) {\n            state.disposeWhenNodeIsRemoved = null;\n        }\n    }\n\n    // Evaluate, unless sleeping or deferEvaluation is true\n    if (!state.isSleeping && !options['deferEvaluation']) {\n        computedObservable.evaluateImmediate();\n    }\n\n    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is\n    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).\n    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {\n        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {\n            computedObservable.dispose();\n        });\n    }\n\n    return computedObservable;\n};\n\n// Utility function that disposes a given dependencyTracking entry\nfunction computedDisposeDependencyCallback(id, entryToDispose) {\n    if (entryToDispose !== null && entryToDispose.dispose) {\n        entryToDispose.dispose();\n    }\n}\n\n// This function gets called each time a dependency is detected while evaluating a computed.\n// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.\nfunction computedBeginDependencyDetectionCallback(subscribable, id) {\n    var computedObservable = this.computedObservable,\n        state = computedObservable[computedState];\n    if (!state.isDisposed) {\n        if (this.disposalCount && this.disposalCandidates[id]) {\n            // Don't want to dispose this subscription, as it's still being used\n            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);\n            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway\n            --this.disposalCount;\n        } else if (!state.dependencyTracking[id]) {\n            // Brand new subscription - add it\n            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));\n        }\n        // If the observable we've accessed has a pending notification, ensure we get notified of the actual final value (bypass equality checks)\n        if (subscribable._notificationIsPending) {\n            subscribable._notifyNextChangeIfValueIsDifferent();\n        }\n    }\n}\n\nvar computedFn = {\n    \"equalityComparer\": valuesArePrimitiveAndEqual,\n    getDependenciesCount: function () {\n        return this[computedState].dependenciesCount;\n    },\n    addDependencyTracking: function (id, target, trackingObj) {\n        if (this[computedState].pure && target === this) {\n            throw Error(\"A 'pure' computed must not be called recursively\");\n        }\n\n        this[computedState].dependencyTracking[id] = trackingObj;\n        trackingObj._order = this[computedState].dependenciesCount++;\n        trackingObj._version = target.getVersion();\n    },\n    haveDependenciesChanged: function () {\n        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;\n        for (id in dependencyTracking) {\n            if (dependencyTracking.hasOwnProperty(id)) {\n                dependency = dependencyTracking[id];\n                if ((this._evalDelayed && dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version)) {\n                    return true;\n                }\n            }\n        }\n    },\n    markDirty: function () {\n        // Process \"dirty\" events if we can handle delayed notifications\n        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {\n            this._evalDelayed(false /*isChange*/);\n        }\n    },\n    isActive: function () {\n        var state = this[computedState];\n        return state.isDirty || state.dependenciesCount > 0;\n    },\n    respondToChange: function () {\n        // Ignore \"change\" events if we've already scheduled a delayed notification\n        if (!this._notificationIsPending) {\n            this.evaluatePossiblyAsync();\n        } else if (this[computedState].isDirty) {\n            this[computedState].isStale = true;\n        }\n    },\n    subscribeToDependency: function (target) {\n        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {\n            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),\n                changeSub = target.subscribe(this.respondToChange, this);\n            return {\n                _target: target,\n                dispose: function () {\n                    dirtySub.dispose();\n                    changeSub.dispose();\n                }\n            };\n        } else {\n            return target.subscribe(this.evaluatePossiblyAsync, this);\n        }\n    },\n    evaluatePossiblyAsync: function () {\n        var computedObservable = this,\n            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];\n        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {\n            clearTimeout(this[computedState].evaluationTimeoutInstance);\n            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {\n                computedObservable.evaluateImmediate(true /*notifyChange*/);\n            }, throttleEvaluationTimeout);\n        } else if (computedObservable._evalDelayed) {\n            computedObservable._evalDelayed(true /*isChange*/);\n        } else {\n            computedObservable.evaluateImmediate(true /*notifyChange*/);\n        }\n    },\n    evaluateImmediate: function (notifyChange) {\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            disposeWhen = state.disposeWhen,\n            changed = false;\n\n        if (state.isBeingEvaluated) {\n            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.\n            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost\n            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing\n            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387\n            return;\n        }\n\n        // Do not evaluate (and possibly capture new dependencies) if disposed\n        if (state.isDisposed) {\n            return;\n        }\n\n        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {\n            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse\n            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {\n                computedObservable.dispose();\n                return;\n            }\n        } else {\n            // It just did return false, so we can stop suppressing now\n            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;\n        }\n\n        state.isBeingEvaluated = true;\n        try {\n            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);\n        } finally {\n            state.isBeingEvaluated = false;\n        }\n\n        if (!state.dependenciesCount) {\n            computedObservable.dispose();\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {\n        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.\n        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,\n        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).\n\n        var computedObservable = this,\n            state = computedObservable[computedState],\n            changed = false;\n\n        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).\n        // Then, during evaluation, we cross off any that are in fact still being used.\n        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time\n            dependencyDetectionContext = {\n                computedObservable: computedObservable,\n                disposalCandidates: state.dependencyTracking,\n                disposalCount: state.dependenciesCount\n            };\n\n        ko.dependencyDetection.begin({\n            callbackTarget: dependencyDetectionContext,\n            callback: computedBeginDependencyDetectionCallback,\n            computed: computedObservable,\n            isInitial: isInitial\n        });\n\n        state.dependencyTracking = {};\n        state.dependenciesCount = 0;\n\n        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);\n\n        if (computedObservable.isDifferent(state.latestValue, newValue)) {\n            if (!state.isSleeping) {\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"beforeChange\");\n            }\n\n            state.latestValue = newValue;\n            if (DEBUG) computedObservable._latestValue = newValue;\n\n            if (state.isSleeping) {\n                computedObservable.updateVersion();\n            } else if (notifyChange) {\n                computedObservable[\"notifySubscribers\"](state.latestValue);\n            }\n\n            changed = true;\n        }\n\n        if (isInitial) {\n            computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n        }\n\n        return changed;\n    },\n    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {\n        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.\n        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection\n        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU\n        // overhead of computed evaluation (on V8 at least).\n\n        try {\n            var readFunction = state.readFunction;\n            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();\n        } finally {\n            ko.dependencyDetection.end();\n\n            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it\n            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {\n                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);\n            }\n\n            state.isStale = state.isDirty = false;\n        }\n    },\n    peek: function (evaluate) {\n        // By default, peek won't re-evaluate, except while the computed is sleeping or to get the initial value when \"deferEvaluation\" is set.\n        // Pass in true to evaluate if needed.\n        var state = this[computedState];\n        if ((state.isDirty && (evaluate || !state.dependenciesCount)) || (state.isSleeping && this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return state.latestValue;\n    },\n    limit: function (limitFunction) {\n        // Override the limit function with one that delays evaluation as well\n        ko.subscribable['fn'].limit.call(this, limitFunction);\n        this._evalIfChanged = function () {\n            if (this[computedState].isStale) {\n                this.evaluateImmediate();\n            } else {\n                this[computedState].isDirty = false;\n            }\n            return this[computedState].latestValue;\n        };\n        this._evalDelayed = function (isChange) {\n            this._limitBeforeChange(this[computedState].latestValue);\n\n            // Mark as dirty\n            this[computedState].isDirty = true;\n            if (isChange) {\n                this[computedState].isStale = true;\n            }\n\n            // Pass the observable to the \"limit\" code, which will evaluate it when\n            // it's time to do the notification.\n            this._limitChange(this);\n        };\n    },\n    dispose: function () {\n        var state = this[computedState];\n        if (!state.isSleeping && state.dependencyTracking) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose)\n                    dependency.dispose();\n            });\n        }\n        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {\n            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);\n        }\n        state.dependencyTracking = null;\n        state.dependenciesCount = 0;\n        state.isDisposed = true;\n        state.isStale = false;\n        state.isDirty = false;\n        state.isSleeping = false;\n        state.disposeWhenNodeIsRemoved = null;\n    }\n};\n\nvar pureComputedOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // If asleep, wake up the computed by subscribing to any dependencies.\n        var computedObservable = this,\n            state = computedObservable[computedState];\n        if (!state.isDisposed && state.isSleeping && event == 'change') {\n            state.isSleeping = false;\n            if (state.isStale || computedObservable.haveDependenciesChanged()) {\n                state.dependencyTracking = null;\n                state.dependenciesCount = 0;\n                if (computedObservable.evaluateImmediate()) {\n                    computedObservable.updateVersion();\n                }\n            } else {\n                // First put the dependencies in order\n                var dependeciesOrder = [];\n                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                    dependeciesOrder[dependency._order] = id;\n                });\n                // Next, subscribe to each one\n                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {\n                    var dependency = state.dependencyTracking[id],\n                        subscription = computedObservable.subscribeToDependency(dependency._target);\n                    subscription._order = order;\n                    subscription._version = dependency._version;\n                    state.dependencyTracking[id] = subscription;\n                });\n            }\n            if (!state.isDisposed) {     // test since evaluating could trigger disposal\n                computedObservable[\"notifySubscribers\"](state.latestValue, \"awake\");\n            }\n        }\n    },\n    afterSubscriptionRemove: function (event) {\n        var state = this[computedState];\n        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {\n            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {\n                if (dependency.dispose) {\n                    state.dependencyTracking[id] = {\n                        _target: dependency._target,\n                        _order: dependency._order,\n                        _version: dependency._version\n                    };\n                    dependency.dispose();\n                }\n            });\n            state.isSleeping = true;\n            this[\"notifySubscribers\"](undefined, \"asleep\");\n        }\n    },\n    getVersion: function () {\n        // Because a pure computed is not automatically updated while it is sleeping, we can't\n        // simply return the version number. Instead, we check if any of the dependencies have\n        // changed and conditionally re-evaluate the computed observable.\n        var state = this[computedState];\n        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {\n            this.evaluateImmediate();\n        }\n        return ko.subscribable['fn'].getVersion.call(this);\n    }\n};\n\nvar deferEvaluationOverrides = {\n    beforeSubscriptionAdd: function (event) {\n        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.\n        if (event == 'change' || event == 'beforeChange') {\n            this.peek();\n        }\n    }\n};\n\n// Note that for browsers that don't support proto assignment, the\n// inheritance chain is created manually in the ko.computed constructor\nif (ko.utils.canSetPrototype) {\n    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);\n}\n\n// Set the proto chain values for ko.hasPrototype\nvar protoProp = ko.observable.protoProperty; // == \"__ko_proto__\"\nko.computed[protoProp] = ko.observable;\ncomputedFn[protoProp] = ko.computed;\n\nko.isComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed);\n};\n\nko.isPureComputed = function (instance) {\n    return ko.hasPrototype(instance, ko.computed)\n        && instance[computedState] && instance[computedState].pure;\n};\n\nko.exportSymbol('computed', ko.computed);\nko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)\nko.exportSymbol('isComputed', ko.isComputed);\nko.exportSymbol('isPureComputed', ko.isPureComputed);\nko.exportSymbol('computed.fn', computedFn);\nko.exportProperty(computedFn, 'peek', computedFn.peek);\nko.exportProperty(computedFn, 'dispose', computedFn.dispose);\nko.exportProperty(computedFn, 'isActive', computedFn.isActive);\nko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);\n\nko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {\n    if (typeof evaluatorFunctionOrOptions === 'function') {\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});\n    } else {\n        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object\n        evaluatorFunctionOrOptions['pure'] = true;\n        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);\n    }\n}\nko.exportSymbol('pureComputed', ko.pureComputed);\n\n(function() {\n    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)\n\n    ko.toJS = function(rootObject) {\n        if (arguments.length == 0)\n            throw new Error(\"When calling ko.toJS, pass the object you want to convert.\");\n\n        // We just unwrap everything at every level in the object graph\n        return mapJsObjectGraph(rootObject, function(valueToMap) {\n            // Loop because an observable's value might in turn be another observable wrapper\n            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)\n                valueToMap = valueToMap();\n            return valueToMap;\n        });\n    };\n\n    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional\n        var plainJavaScriptObject = ko.toJS(rootObject);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {\n        visitedObjects = visitedObjects || new objectLookup();\n\n        rootObject = mapInputCallback(rootObject);\n        var canHaveProperties = (typeof rootObject == \"object\") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));\n        if (!canHaveProperties)\n            return rootObject;\n\n        var outputProperties = rootObject instanceof Array ? [] : {};\n        visitedObjects.save(rootObject, outputProperties);\n\n        visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n            var propertyValue = mapInputCallback(rootObject[indexer]);\n\n            switch (typeof propertyValue) {\n                case \"boolean\":\n                case \"number\":\n                case \"string\":\n                case \"function\":\n                    outputProperties[indexer] = propertyValue;\n                    break;\n                case \"object\":\n                case \"undefined\":\n                    var previouslyMappedValue = visitedObjects.get(propertyValue);\n                    outputProperties[indexer] = (previouslyMappedValue !== undefined)\n                        ? previouslyMappedValue\n                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);\n                    break;\n            }\n        });\n\n        return outputProperties;\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (rootObject instanceof Array) {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n\n            // For arrays, also respect toJSON property for custom mappings (fixes #278)\n            if (typeof rootObject['toJSON'] == 'function')\n                visitorCallback('toJSON');\n        } else {\n            for (var propertyName in rootObject) {\n                visitorCallback(propertyName);\n            }\n        }\n    };\n\n    function objectLookup() {\n        this.keys = [];\n        this.values = [];\n    };\n\n    objectLookup.prototype = {\n        constructor: objectLookup,\n        save: function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            if (existingIndex >= 0)\n                this.values[existingIndex] = value;\n            else {\n                this.keys.push(key);\n                this.values.push(value);\n            }\n        },\n        get: function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);\n            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;\n        }\n    };\n})();\n\nko.exportSymbol('toJS', ko.toJS);\nko.exportSymbol('toJSON', ko.toJSON);\n(function () {\n    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';\n\n    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values\n    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values\n    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.\n    ko.selectExtensions = {\n        readValue : function(element) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    if (element[hasDomDataExpandoProperty] === true)\n                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);\n                    return ko.utils.ieVersion <= 7\n                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)\n                        : element.value;\n                case 'select':\n                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;\n                default:\n                    return element.value;\n            }\n        },\n\n        writeValue: function(element, value, allowUnset) {\n            switch (ko.utils.tagNameLower(element)) {\n                case 'option':\n                    switch(typeof value) {\n                        case \"string\":\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);\n                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node\n                                delete element[hasDomDataExpandoProperty];\n                            }\n                            element.value = value;\n                            break;\n                        default:\n                            // Store arbitrary object using DomData\n                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);\n                            element[hasDomDataExpandoProperty] = true;\n\n                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.\n                            element.value = typeof value === \"number\" ? value : \"\";\n                            break;\n                    }\n                    break;\n                case 'select':\n                    if (value === \"\" || value === null)       // A blank string or null value will select the caption\n                        value = undefined;\n                    var selection = -1;\n                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {\n                        optionValue = ko.selectExtensions.readValue(element.options[i]);\n                        // Include special check to handle selecting a caption with a blank string value\n                        if (optionValue == value || (optionValue == \"\" && value === undefined)) {\n                            selection = i;\n                            break;\n                        }\n                    }\n                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {\n                        element.selectedIndex = selection;\n                    }\n                    break;\n                default:\n                    if ((value === null) || (value === undefined))\n                        value = \"\";\n                    element.value = value;\n                    break;\n            }\n        }\n    };\n})();\n\nko.exportSymbol('selectExtensions', ko.selectExtensions);\nko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);\nko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);\nko.expressionRewriting = (function () {\n    var javaScriptReservedWords = [\"true\", \"false\", \"null\", \"undefined\"];\n\n    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor\n    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).\n    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).\n    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i;\n\n    function getWriteableValue(expression) {\n        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)\n            return false;\n        var match = expression.match(javaScriptAssignmentTarget);\n        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;\n    }\n\n    // The following regular expressions will be used to split an object-literal string into tokens\n\n        // These two match strings, either with double quotes or single quotes\n    var stringDouble = '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"',\n        stringSingle = \"'(?:[^'\\\\\\\\]|\\\\\\\\.)*'\",\n        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions\n        // as a regular expression (this is handled by the parsing loop below).\n        stringRegexp = '/(?:[^/\\\\\\\\]|\\\\\\\\.)*/\\w*',\n        // These characters have special meaning to the parser and must not appear in the middle of a\n        // token, except as part of a string.\n        specials = ',\"\\'{}()/:[\\\\]',\n        // Match text (at least two characters) that does not contain any of the above special characters,\n        // although some of the special characters are allowed to start it (all but the colon and comma).\n        // The text can contain spaces, but leading or trailing spaces are skipped.\n        everyThingElse = '[^\\\\s:,/][^' + specials + ']*[^\\\\s' + specials + ']',\n        // Match any non-space character not matched already. This will match colons and commas, since they're\n        // not matched by \"everyThingElse\", but will also match any other single character that wasn't already\n        // matched (for example: in \"a: 1, b: 2\", each of the non-space characters will be matched by oneNotSpace).\n        oneNotSpace = '[^\\\\s]',\n\n        // Create the actual regular expression by or-ing the above strings. The order is important.\n        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),\n\n        // Match end of previous token to determine whether a slash is a division or regex.\n        divisionLookBehind = /[\\])\"'A-Za-z0-9_$]+$/,\n        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};\n\n    function parseObjectLiteral(objectLiteralString) {\n        // Trim leading and trailing spaces from the string\n        var str = ko.utils.stringTrim(objectLiteralString);\n\n        // Trim braces '{' surrounding the whole object literal\n        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);\n\n        // Split into tokens\n        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;\n\n        if (toks) {\n            // Append a comma so that we don't need a separate code block to deal with the last item\n            toks.push(',');\n\n            for (var i = 0, tok; tok = toks[i]; ++i) {\n                var c = tok.charCodeAt(0);\n                // A comma signals the end of a key/value pair if depth is zero\n                if (c === 44) { // \",\"\n                    if (depth <= 0) {\n                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});\n                        key = depth = 0;\n                        values = [];\n                        continue;\n                    }\n                // Simply skip the colon that separates the name and value\n                } else if (c === 58) { // \":\"\n                    if (!depth && !key && values.length === 1) {\n                        key = values.pop();\n                        continue;\n                    }\n                // A set of slashes is initially matched as a regular expression, but could be division\n                } else if (c === 47 && i && tok.length > 1) {  // \"/\"\n                    // Look at the end of the previous token to determine if the slash is actually division\n                    var match = toks[i-1].match(divisionLookBehind);\n                    if (match && !keywordRegexLookBehind[match[0]]) {\n                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)\n                        str = str.substr(str.indexOf(tok) + 1);\n                        toks = str.match(bindingToken);\n                        toks.push(',');\n                        i = -1;\n                        // Continue with just the slash\n                        tok = '/';\n                    }\n                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored\n                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['\n                    ++depth;\n                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'\n                    --depth;\n                // The key will be the first token; if it's a string, trim the quotes\n                } else if (!key && !values.length && (c === 34 || c === 39)) { // '\"', \"'\"\n                    tok = tok.slice(1, -1);\n                }\n                values.push(tok);\n            }\n        }\n        return result;\n    }\n\n    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.\n    var twoWayBindings = {};\n\n    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {\n        bindingOptions = bindingOptions || {};\n\n        function processKeyValue(key, val) {\n            var writableVal;\n            function callPreprocessHook(obj) {\n                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;\n            }\n            if (!bindingParams) {\n                if (!callPreprocessHook(ko['getBindingHandler'](key)))\n                    return;\n\n                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {\n                    // For two-way bindings, provide a write method in case the value\n                    // isn't a writable observable.\n                    propertyAccessorResultStrings.push(\"'\" + key + \"':function(_z){\" + writableVal + \"=_z}\");\n                }\n            }\n            // Values are wrapped in a function so that each value can be accessed independently\n            if (makeValueAccessors) {\n                val = 'function(){return ' + val + ' }';\n            }\n            resultStrings.push(\"'\" + key + \"':\" + val);\n        }\n\n        var resultStrings = [],\n            propertyAccessorResultStrings = [],\n            makeValueAccessors = bindingOptions['valueAccessors'],\n            bindingParams = bindingOptions['bindingParams'],\n            keyValueArray = typeof bindingsStringOrKeyValueArray === \"string\" ?\n                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;\n\n        ko.utils.arrayForEach(keyValueArray, function(keyValue) {\n            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);\n        });\n\n        if (propertyAccessorResultStrings.length)\n            processKeyValue('_ko_property_writers', \"{\" + propertyAccessorResultStrings.join(\",\") + \" }\");\n\n        return resultStrings.join(\",\");\n    }\n\n    return {\n        bindingRewriteValidators: [],\n\n        twoWayBindings: twoWayBindings,\n\n        parseObjectLiteral: parseObjectLiteral,\n\n        preProcessBindings: preProcessBindings,\n\n        keyValueArrayContainsKey: function(keyValueArray, key) {\n            for (var i = 0; i < keyValueArray.length; i++)\n                if (keyValueArray[i]['key'] == key)\n                    return true;\n            return false;\n        },\n\n        // Internal, private KO utility for updating model properties from within bindings\n        // property:            If the property being updated is (or might be) an observable, pass it here\n        //                      If it turns out to be a writable observable, it will be written to directly\n        // allBindings:         An object with a get method to retrieve bindings in the current execution context.\n        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable\n        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'\n        // value:               The value to be written\n        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if\n        //                      it is !== existing value on that writable observable\n        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {\n            if (!property || !ko.isObservable(property)) {\n                var propWriters = allBindings.get('_ko_property_writers');\n                if (propWriters && propWriters[key])\n                    propWriters[key](value);\n            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {\n                property(value);\n            }\n        }\n    };\n})();\n\nko.exportSymbol('expressionRewriting', ko.expressionRewriting);\nko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);\nko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);\nko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);\n\n// Making bindings explicitly declare themselves as \"two way\" isn't ideal in the long term (it would be better if\n// all bindings could use an official 'property writer' API without needing to declare that they might). However,\n// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable\n// as an internal implementation detail in the short term.\n// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an\n// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official\n// public API, and we reserve the right to remove it at any time if we create a real public property writers API.\nko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);\n\n// For backward compatibility, define the following aliases. (Previously, these function names were misleading because\n// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)\nko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);\nko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);\n(function() {\n    // \"Virtual elements\" is an abstraction on top of the usual DOM API which understands the notion that comment nodes\n    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).\n    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state\n    // of that virtual hierarchy\n    //\n    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)\n    // without having to scatter special cases all over the binding and templating code.\n\n    // IE 9 cannot reliably read the \"nodeValue\" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)\n    // but it does give them a nonstandard alternative property called \"text\" that it can read reliably. Other browsers don't have that property.\n    // So, use node.text where available, and node.nodeValue elsewhere\n    var commentNodesHaveTextProperty = document && document.createComment(\"test\").text === \"<!--test-->\";\n\n    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*-->$/ : /^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/;\n    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\\s*\\/ko\\s*-->$/ : /^\\s*\\/ko\\s*$/;\n    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };\n\n    function isStartComment(node) {\n        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function isEndComment(node) {\n        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);\n    }\n\n    function getVirtualChildren(startComment, allowUnbalanced) {\n        var currentNode = startComment;\n        var depth = 1;\n        var children = [];\n        while (currentNode = currentNode.nextSibling) {\n            if (isEndComment(currentNode)) {\n                depth--;\n                if (depth === 0)\n                    return children;\n            }\n\n            children.push(currentNode);\n\n            if (isStartComment(currentNode))\n                depth++;\n        }\n        if (!allowUnbalanced)\n            throw new Error(\"Cannot find closing comment tag to match: \" + startComment.nodeValue);\n        return null;\n    }\n\n    function getMatchingEndComment(startComment, allowUnbalanced) {\n        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);\n        if (allVirtualChildren) {\n            if (allVirtualChildren.length > 0)\n                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;\n            return startComment.nextSibling;\n        } else\n            return null; // Must have no matching end comment, and allowUnbalanced is true\n    }\n\n    function getUnbalancedChildTags(node) {\n        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>\n        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->\n        var childNode = node.firstChild, captureRemaining = null;\n        if (childNode) {\n            do {\n                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes\n                    captureRemaining.push(childNode);\n                else if (isStartComment(childNode)) {\n                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);\n                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set\n                        childNode = matchingEndComment;\n                    else\n                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point\n                } else if (isEndComment(childNode)) {\n                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing\n                }\n            } while (childNode = childNode.nextSibling);\n        }\n        return captureRemaining;\n    }\n\n    ko.virtualElements = {\n        allowedBindings: {},\n\n        childNodes: function(node) {\n            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;\n        },\n\n        emptyNode: function(node) {\n            if (!isStartComment(node))\n                ko.utils.emptyDomNode(node);\n            else {\n                var virtualChildren = ko.virtualElements.childNodes(node);\n                for (var i = 0, j = virtualChildren.length; i < j; i++)\n                    ko.removeNode(virtualChildren[i]);\n            }\n        },\n\n        setDomNodeChildren: function(node, childNodes) {\n            if (!isStartComment(node))\n                ko.utils.setDomNodeChildren(node, childNodes);\n            else {\n                ko.virtualElements.emptyNode(node);\n                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children\n                for (var i = 0, j = childNodes.length; i < j; i++)\n                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);\n            }\n        },\n\n        prepend: function(containerNode, nodeToPrepend) {\n            if (!isStartComment(containerNode)) {\n                if (containerNode.firstChild)\n                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);\n                else\n                    containerNode.appendChild(nodeToPrepend);\n            } else {\n                // Start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);\n            }\n        },\n\n        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {\n            if (!insertAfterNode) {\n                ko.virtualElements.prepend(containerNode, nodeToInsert);\n            } else if (!isStartComment(containerNode)) {\n                // Insert after insertion point\n                if (insertAfterNode.nextSibling)\n                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n                else\n                    containerNode.appendChild(nodeToInsert);\n            } else {\n                // Children of start comments must always have a parent and at least one following sibling (the end comment)\n                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);\n            }\n        },\n\n        firstChild: function(node) {\n            if (!isStartComment(node))\n                return node.firstChild;\n            if (!node.nextSibling || isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        nextSibling: function(node) {\n            if (isStartComment(node))\n                node = getMatchingEndComment(node);\n            if (node.nextSibling && isEndComment(node.nextSibling))\n                return null;\n            return node.nextSibling;\n        },\n\n        hasBindingValue: isStartComment,\n\n        virtualNodeBindingValue: function(node) {\n            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);\n            return regexMatch ? regexMatch[1] : null;\n        },\n\n        normaliseVirtualElementDomStructure: function(elementVerified) {\n            // Workaround for https://github.com/SteveSanderson/knockout/issues/155\n            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes\n            // that are direct descendants of <ul> into the preceding <li>)\n            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])\n                return;\n\n            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags\n            // must be intended to appear *after* that child, so move them there.\n            var childNode = elementVerified.firstChild;\n            if (childNode) {\n                do {\n                    if (childNode.nodeType === 1) {\n                        var unbalancedTags = getUnbalancedChildTags(childNode);\n                        if (unbalancedTags) {\n                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child\n                            var nodeToInsertBefore = childNode.nextSibling;\n                            for (var i = 0; i < unbalancedTags.length; i++) {\n                                if (nodeToInsertBefore)\n                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);\n                                else\n                                    elementVerified.appendChild(unbalancedTags[i]);\n                            }\n                        }\n                    }\n                } while (childNode = childNode.nextSibling);\n            }\n        }\n    };\n})();\nko.exportSymbol('virtualElements', ko.virtualElements);\nko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);\nko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);\n//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified\nko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);\n//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified\nko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);\nko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);\n(function() {\n    var defaultBindingAttributeName = \"data-bind\";\n\n    ko.bindingProvider = function() {\n        this.bindingCache = {};\n    };\n\n    ko.utils.extend(ko.bindingProvider.prototype, {\n        'nodeHasBindings': function(node) {\n            switch (node.nodeType) {\n                case 1: // Element\n                    return node.getAttribute(defaultBindingAttributeName) != null\n                        || ko.components['getComponentNameForNode'](node);\n                case 8: // Comment node\n                    return ko.virtualElements.hasBindingValue(node);\n                default: return false;\n            }\n        },\n\n        'getBindings': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);\n        },\n\n        'getBindingAccessors': function(node, bindingContext) {\n            var bindingsString = this['getBindingsString'](node, bindingContext),\n                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;\n            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'getBindingsString': function(node, bindingContext) {\n            switch (node.nodeType) {\n                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element\n                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node\n                default: return null;\n            }\n        },\n\n        // The following function is only used internally by this default provider.\n        // It's not part of the interface definition for a general binding provider.\n        'parseBindingsString': function(bindingsString, bindingContext, node, options) {\n            try {\n                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);\n                return bindingFunction(bindingContext, node);\n            } catch (ex) {\n                ex.message = \"Unable to parse bindings.\\nBindings value: \" + bindingsString + \"\\nMessage: \" + ex.message;\n                throw ex;\n            }\n        }\n    });\n\n    ko.bindingProvider['instance'] = new ko.bindingProvider();\n\n    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {\n        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');\n        return cache[cacheKey]\n            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));\n    }\n\n    function createBindingsStringEvaluator(bindingsString, options) {\n        // Build the source for a function that evaluates \"expression\"\n        // For each scope variable, add an extra level of \"with\" nesting\n        // Example result: with(sc1) { with(sc0) { return (expression) } }\n        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),\n            functionBody = \"with($context){with($data||{}){return{\" + rewrittenBindings + \"}}}\";\n        return new Function(\"$context\", \"$element\", functionBody);\n    }\n})();\n\nko.exportSymbol('bindingProvider', ko.bindingProvider);\n(function () {\n    ko.bindingHandlers = {};\n\n    // The following element types will not be recursed into during binding.\n    var bindingDoesNotRecurseIntoElementTypes = {\n        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,\n        // because it's unexpected and a potential XSS issue.\n        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer\n        // and because such elements' contents are always intended to be bound in a different context\n        // from where they appear in the document.\n        'script': true,\n        'textarea': true,\n        'template': true\n    };\n\n    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers\n    ko['getBindingHandler'] = function(bindingKey) {\n        return ko.bindingHandlers[bindingKey];\n    };\n\n    // The ko.bindingContext constructor is only called directly to create the root context. For child\n    // contexts, use bindingContext.createChildContext or bindingContext.extend.\n    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {\n\n        // The binding context object includes static properties for the current, parent, and root view models.\n        // If a view model is actually stored in an observable, the corresponding binding context object, and\n        // any child contexts, must be updated when the view model is changed.\n        function updateContext() {\n            // Most of the time, the context will directly get a view model object, but if a function is given,\n            // we call the function to retrieve the view model. If the function accesses any observables or returns\n            // an observable, the dependency is tracked, and those observables can later cause the binding\n            // context to be updated.\n            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,\n                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);\n\n            if (parentContext) {\n                // When a \"parent\" context is given, register a dependency on the parent context. Thus whenever the\n                // parent context is updated, this context will also be updated.\n                if (parentContext._subscribable)\n                    parentContext._subscribable();\n\n                // Copy $root and any custom properties from the parent context\n                ko.utils.extend(self, parentContext);\n\n                // Because the above copy overwrites our own properties, we need to reset them.\n                self._subscribable = subscribable;\n            } else {\n                self['$parents'] = [];\n                self['$root'] = dataItem;\n\n                // Export 'ko' in the binding context so it will be available in bindings and templates\n                // even if 'ko' isn't exported as a global, such as when using an AMD loader.\n                // See https://github.com/SteveSanderson/knockout/issues/490\n                self['ko'] = ko;\n            }\n            self['$rawData'] = dataItemOrObservable;\n            self['$data'] = dataItem;\n            if (dataItemAlias)\n                self[dataItemAlias] = dataItem;\n\n            // The extendCallback function is provided when creating a child context or extending a context.\n            // It handles the specific actions needed to finish setting up the binding context. Actions in this\n            // function could also add dependencies to this binding context.\n            if (extendCallback)\n                extendCallback(self, parentContext, dataItem);\n\n            return self['$data'];\n        }\n        function disposeWhen() {\n            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);\n        }\n\n        var self = this,\n            isFunc = typeof(dataItemOrAccessor) == \"function\" && !ko.isObservable(dataItemOrAccessor),\n            nodes,\n            subscribable;\n\n        if (options && options['exportDependencies']) {\n            // The \"exportDependencies\" option means that the calling code will track any dependencies and re-create\n            // the binding context when they change.\n            updateContext();\n        } else {\n            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });\n\n            // At this point, the binding context has been initialized, and the \"subscribable\" computed observable is\n            // subscribed to any observables that were accessed in the process. If there is nothing to track, the\n            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in\n            // the context object.\n            if (subscribable.isActive()) {\n                self._subscribable = subscribable;\n\n                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed\n                subscribable['equalityComparer'] = null;\n\n                // We need to be able to dispose of this computed observable when it's no longer needed. This would be\n                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and\n                // we cannot assume that those nodes have any relation to each other. So instead we track any node that\n                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.\n\n                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates\n                nodes = [];\n                subscribable._addNode = function(node) {\n                    nodes.push(node);\n                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {\n                        ko.utils.arrayRemoveItem(nodes, node);\n                        if (!nodes.length) {\n                            subscribable.dispose();\n                            self._subscribable = subscribable = undefined;\n                        }\n                    });\n                };\n            }\n        }\n    }\n\n    // Extend the binding context hierarchy with a new view model object. If the parent context is watching\n    // any observables, the new child context will automatically get a dependency on the parent context.\n    // But this does not mean that the $data value of the child context will also get updated. If the child\n    // view model also depends on the parent view model, you must provide a function that returns the correct\n    // view model on each update.\n    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {\n        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {\n            // Extend the context hierarchy by setting the appropriate pointers\n            self['$parentContext'] = parentContext;\n            self['$parent'] = parentContext['$data'];\n            self['$parents'] = (parentContext['$parents'] || []).slice(0);\n            self['$parents'].unshift(self['$parent']);\n            if (extendCallback)\n                extendCallback(self);\n        }, options);\n    };\n\n    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.\n    // Similarly to \"child\" contexts, provide a function here to make sure that the correct values are set\n    // when an observable view model is updated.\n    ko.bindingContext.prototype['extend'] = function(properties) {\n        // If the parent context references an observable view model, \"_subscribable\" will always be the\n        // latest view model object. If not, \"_subscribable\" isn't set, and we can use the static \"$data\" value.\n        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {\n            // This \"child\" context doesn't directly track a parent observable view model,\n            // so we need to manually set the $rawData value to match the parent.\n            self['$rawData'] = parentContext['$rawData'];\n            ko.utils.extend(self, typeof(properties) == \"function\" ? properties() : properties);\n        });\n    };\n\n    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {\n        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { \"exportDependencies\": true });\n    };\n\n    // Returns the valueAccesor function for a binding value\n    function makeValueAccessor(value) {\n        return function() {\n            return value;\n        };\n    }\n\n    // Returns the value of a valueAccessor function\n    function evaluateValueAccessor(valueAccessor) {\n        return valueAccessor();\n    }\n\n    // Given a function that returns bindings, create and return a new object that contains\n    // binding value-accessors functions. Each accessor function calls the original function\n    // so that it always gets the latest value and all dependencies are captured. This is used\n    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.\n    function makeAccessorsFromFunction(callback) {\n        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {\n            return function() {\n                return callback()[key];\n            };\n        });\n    }\n\n    // Given a bindings function or object, create and return a new object that contains\n    // binding value-accessors functions. This is used by ko.applyBindingsToNode.\n    function makeBindingAccessors(bindings, context, node) {\n        if (typeof bindings === 'function') {\n            return makeAccessorsFromFunction(bindings.bind(null, context, node));\n        } else {\n            return ko.utils.objectMap(bindings, makeValueAccessor);\n        }\n    }\n\n    // This function is used if the binding provider doesn't include a getBindingAccessors function.\n    // It must be called with 'this' set to the provider instance.\n    function getBindingsAndMakeAccessors(node, context) {\n        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));\n    }\n\n    function validateThatBindingIsAllowedForVirtualElements(bindingName) {\n        var validator = ko.virtualElements.allowedBindings[bindingName];\n        if (!validator)\n            throw new Error(\"The binding '\" + bindingName + \"' cannot be used with virtual elements\")\n    }\n\n    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {\n        var currentChild,\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),\n            provider = ko.bindingProvider['instance'],\n            preprocessNode = provider['preprocessNode'];\n\n        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's\n        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to\n        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that\n        // trigger insertion of <template> contents at that point in the document.\n        if (preprocessNode) {\n            while (currentChild = nextInQueue) {\n                nextInQueue = ko.virtualElements.nextSibling(currentChild);\n                preprocessNode.call(provider, currentChild);\n            }\n            // Reset nextInQueue for the next loop\n            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);\n        }\n\n        while (currentChild = nextInQueue) {\n            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position\n            nextInQueue = ko.virtualElements.nextSibling(currentChild);\n            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);\n        }\n    }\n\n    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {\n        var shouldBindDescendants = true;\n\n        // Perf optimisation: Apply bindings only if...\n        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)\n        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those\n        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)\n        var isElement = (nodeVerified.nodeType === 1);\n        if (isElement) // Workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);\n\n        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)\n                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)\n        if (shouldApplyBindings)\n            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];\n\n        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {\n            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,\n            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,\n            //    hence bindingContextsMayDifferFromDomParentElement is false\n            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may\n            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,\n            //    hence bindingContextsMayDifferFromDomParentElement is true\n            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);\n        }\n    }\n\n    var boundElementDomDataKey = ko.utils.domData.nextKey();\n\n\n    function topologicalSortBindings(bindings) {\n        // Depth-first sort\n        var result = [],                // The list of key/handler pairs that we will return\n            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'\n            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it\n        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {\n            if (!bindingsConsidered[bindingKey]) {\n                var binding = ko['getBindingHandler'](bindingKey);\n                if (binding) {\n                    // First add dependencies (if any) of the current binding\n                    if (binding['after']) {\n                        cyclicDependencyStack.push(bindingKey);\n                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {\n                            if (bindings[bindingDependencyKey]) {\n                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {\n                                    throw Error(\"Cannot combine the following bindings, because they have a cyclic dependency: \" + cyclicDependencyStack.join(\", \"));\n                                } else {\n                                    pushBinding(bindingDependencyKey);\n                                }\n                            }\n                        });\n                        cyclicDependencyStack.length--;\n                    }\n                    // Next add the current binding\n                    result.push({ key: bindingKey, handler: binding });\n                }\n                bindingsConsidered[bindingKey] = true;\n            }\n        });\n\n        return result;\n    }\n\n    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {\n        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified\n        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);\n        if (!sourceBindings) {\n            if (alreadyBound) {\n                throw Error(\"You cannot apply bindings multiple times to the same element.\");\n            }\n            ko.utils.domData.set(node, boundElementDomDataKey, true);\n        }\n\n        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because\n        // we can easily recover it just by scanning up the node's ancestors in the DOM\n        // (note: here, parent node means \"real DOM parent\" not \"virtual parent\", as there's no O(1) way to find the virtual parent)\n        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)\n            ko.storedBindingContextForNode(node, bindingContext);\n\n        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings\n        var bindings;\n        if (sourceBindings && typeof sourceBindings !== 'function') {\n            bindings = sourceBindings;\n        } else {\n            var provider = ko.bindingProvider['instance'],\n                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;\n\n            // Get the binding from the provider within a computed observable so that we can update the bindings whenever\n            // the binding context is updated or if the binding provider accesses observables.\n            var bindingsUpdater = ko.dependentObservable(\n                function() {\n                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);\n                    // Register a dependency on the binding context to support observable view models.\n                    if (bindings && bindingContext._subscribable)\n                        bindingContext._subscribable();\n                    return bindings;\n                },\n                null, { disposeWhenNodeIsRemoved: node }\n            );\n\n            if (!bindings || !bindingsUpdater.isActive())\n                bindingsUpdater = null;\n        }\n\n        var bindingHandlerThatControlsDescendantBindings;\n        if (bindings) {\n            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding\n            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets\n            // the latest binding value and registers a dependency on the binding updater.\n            var getValueAccessor = bindingsUpdater\n                ? function(bindingKey) {\n                    return function() {\n                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);\n                    };\n                } : function(bindingKey) {\n                    return bindings[bindingKey];\n                };\n\n            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated\n            function allBindings() {\n                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);\n            }\n            // The following is the 3.x allBindings API\n            allBindings['get'] = function(key) {\n                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));\n            };\n            allBindings['has'] = function(key) {\n                return key in bindings;\n            };\n\n            // First put the bindings into the right order\n            var orderedBindings = topologicalSortBindings(bindings);\n\n            // Go through the sorted bindings, calling init and update for each\n            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {\n                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,\n                // so bindingKeyAndHandler.handler will always be nonnull.\n                var handlerInitFn = bindingKeyAndHandler.handler[\"init\"],\n                    handlerUpdateFn = bindingKeyAndHandler.handler[\"update\"],\n                    bindingKey = bindingKeyAndHandler.key;\n\n                if (node.nodeType === 8) {\n                    validateThatBindingIsAllowedForVirtualElements(bindingKey);\n                }\n\n                try {\n                    // Run init, ignoring any dependencies\n                    if (typeof handlerInitFn == \"function\") {\n                        ko.dependencyDetection.ignore(function() {\n                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n\n                            // If this binding handler claims to control descendant bindings, make a note of this\n                            if (initResult && initResult['controlsDescendantBindings']) {\n                                if (bindingHandlerThatControlsDescendantBindings !== undefined)\n                                    throw new Error(\"Multiple bindings (\" + bindingHandlerThatControlsDescendantBindings + \" and \" + bindingKey + \") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.\");\n                                bindingHandlerThatControlsDescendantBindings = bindingKey;\n                            }\n                        });\n                    }\n\n                    // Run update in its own computed wrapper\n                    if (typeof handlerUpdateFn == \"function\") {\n                        ko.dependentObservable(\n                            function() {\n                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);\n                            },\n                            null,\n                            { disposeWhenNodeIsRemoved: node }\n                        );\n                    }\n                } catch (ex) {\n                    ex.message = \"Unable to process binding \\\"\" + bindingKey + \": \" + bindings[bindingKey] + \"\\\"\\nMessage: \" + ex.message;\n                    throw ex;\n                }\n            });\n        }\n\n        return {\n            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined\n        };\n    };\n\n    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();\n    ko.storedBindingContextForNode = function (node, bindingContext) {\n        if (arguments.length == 2) {\n            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);\n            if (bindingContext._subscribable)\n                bindingContext._subscribable._addNode(node);\n        } else {\n            return ko.utils.domData.get(node, storedBindingContextDomDataKey);\n        }\n    }\n\n    function getBindingContext(viewModelOrBindingContext) {\n        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)\n            ? viewModelOrBindingContext\n            : new ko.bindingContext(viewModelOrBindingContext);\n    }\n\n    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {\n        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness\n            ko.virtualElements.normaliseVirtualElementDomStructure(node);\n        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);\n    };\n\n    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {\n        var context = getBindingContext(viewModelOrBindingContext);\n        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);\n    };\n\n    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {\n        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)\n            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {\n        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.\n        if (!jQueryInstance && window['jQuery']) {\n            jQueryInstance = window['jQuery'];\n        }\n\n        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))\n            throw new Error(\"ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node\");\n        rootNode = rootNode || window.document.body; // Make \"rootNode\" parameter optional\n\n        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);\n    };\n\n    // Retrieving binding context from arbitrary nodes\n    ko.contextFor = function(node) {\n        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)\n        switch (node.nodeType) {\n            case 1:\n            case 8:\n                var context = ko.storedBindingContextForNode(node);\n                if (context) return context;\n                if (node.parentNode) return ko.contextFor(node.parentNode);\n                break;\n        }\n        return undefined;\n    };\n    ko.dataFor = function(node) {\n        var context = ko.contextFor(node);\n        return context ? context['$data'] : undefined;\n    };\n\n    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);\n    ko.exportSymbol('applyBindings', ko.applyBindings);\n    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);\n    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);\n    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);\n    ko.exportSymbol('contextFor', ko.contextFor);\n    ko.exportSymbol('dataFor', ko.dataFor);\n})();\n(function(undefined) {\n    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight\n        loadedDefinitionsCache = {};    // Tracks component loads that have already completed\n\n    ko.components = {\n        get: function(componentName, callback) {\n            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);\n            if (cachedDefinition) {\n                // It's already loaded and cached. Reuse the same definition object.\n                // Note that for API consistency, even cache hits complete asynchronously by default.\n                // You can bypass this by putting synchronous:true on your component config.\n                if (cachedDefinition.isSynchronousComponent) {\n                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning\n                        callback(cachedDefinition.definition);\n                    });\n                } else {\n                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });\n                }\n            } else {\n                // Join the loading process that is already underway, or start a new one.\n                loadComponentAndNotify(componentName, callback);\n            }\n        },\n\n        clearCachedDefinition: function(componentName) {\n            delete loadedDefinitionsCache[componentName];\n        },\n\n        _getFirstResultFromLoaders: getFirstResultFromLoaders\n    };\n\n    function getObjectOwnProperty(obj, propName) {\n        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;\n    }\n\n    function loadComponentAndNotify(componentName, callback) {\n        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),\n            completedAsync;\n        if (!subscribable) {\n            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.\n            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();\n            subscribable.subscribe(callback);\n\n            beginLoadingComponent(componentName, function(definition, config) {\n                var isSynchronousComponent = !!(config && config['synchronous']);\n                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };\n                delete loadingSubscribablesCache[componentName];\n\n                // For API consistency, all loads complete asynchronously. However we want to avoid\n                // adding an extra task schedule if it's unnecessary (i.e., the completion is already\n                // async).\n                //\n                // You can bypass the 'always asynchronous' feature by putting the synchronous:true\n                // flag on your component configuration when you register it.\n                if (completedAsync || isSynchronousComponent) {\n                    // Note that notifySubscribers ignores any dependencies read within the callback.\n                    // See comment in loaderRegistryBehaviors.js for reasoning\n                    subscribable['notifySubscribers'](definition);\n                } else {\n                    ko.tasks.schedule(function() {\n                        subscribable['notifySubscribers'](definition);\n                    });\n                }\n            });\n            completedAsync = true;\n        } else {\n            subscribable.subscribe(callback);\n        }\n    }\n\n    function beginLoadingComponent(componentName, callback) {\n        getFirstResultFromLoaders('getConfig', [componentName], function(config) {\n            if (config) {\n                // We have a config, so now load its definition\n                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {\n                    callback(definition, config);\n                });\n            } else {\n                // The component has no config - it's unknown to all the loaders.\n                // Note that this is not an error (e.g., a module loading error) - that would abort the\n                // process and this callback would not run. For this callback to run, all loaders must\n                // have confirmed they don't know about this component.\n                callback(null, null);\n            }\n        });\n    }\n\n    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {\n        // On the first call in the stack, start with the full set of loaders\n        if (!candidateLoaders) {\n            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array\n        }\n\n        // Try the next candidate\n        var currentCandidateLoader = candidateLoaders.shift();\n        if (currentCandidateLoader) {\n            var methodInstance = currentCandidateLoader[methodName];\n            if (methodInstance) {\n                var wasAborted = false,\n                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {\n                        if (wasAborted) {\n                            callback(null);\n                        } else if (result !== null) {\n                            // This candidate returned a value. Use it.\n                            callback(result);\n                        } else {\n                            // Try the next candidate\n                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n                        }\n                    }));\n\n                // Currently, loaders may not return anything synchronously. This leaves open the possibility\n                // that we'll extend the API to support synchronous return values in the future. It won't be\n                // a breaking change, because currently no loader is allowed to return anything except undefined.\n                if (synchronousReturnValue !== undefined) {\n                    wasAborted = true;\n\n                    // Method to suppress exceptions will remain undocumented. This is only to keep\n                    // KO's specs running tidily, since we can observe the loading got aborted without\n                    // having exceptions cluttering up the console too.\n                    if (!currentCandidateLoader['suppressLoaderExceptions']) {\n                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');\n                    }\n                }\n            } else {\n                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.\n                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);\n            }\n        } else {\n            // No candidates returned a value\n            callback(null);\n        }\n    }\n\n    // Reference the loaders via string name so it's possible for developers\n    // to replace the whole array by assigning to ko.components.loaders\n    ko.components['loaders'] = [];\n\n    ko.exportSymbol('components', ko.components);\n    ko.exportSymbol('components.get', ko.components.get);\n    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);\n})();\n(function(undefined) {\n\n    // The default loader is responsible for two things:\n    // 1. Maintaining the default in-memory registry of component configuration objects\n    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))\n    // 2. Answering requests for components by fetching configuration objects\n    //    from that default in-memory registry and resolving them into standard\n    //    component definition objects (of the form { createViewModel: ..., template: ... })\n    // Custom loaders may override either of these facilities, i.e.,\n    // 1. To supply configuration objects from some other source (e.g., conventions)\n    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.\n\n    var defaultConfigRegistry = {};\n\n    ko.components.register = function(componentName, config) {\n        if (!config) {\n            throw new Error('Invalid configuration for ' + componentName);\n        }\n\n        if (ko.components.isRegistered(componentName)) {\n            throw new Error('Component ' + componentName + ' is already registered');\n        }\n\n        defaultConfigRegistry[componentName] = config;\n    };\n\n    ko.components.isRegistered = function(componentName) {\n        return defaultConfigRegistry.hasOwnProperty(componentName);\n    };\n\n    ko.components.unregister = function(componentName) {\n        delete defaultConfigRegistry[componentName];\n        ko.components.clearCachedDefinition(componentName);\n    };\n\n    ko.components.defaultLoader = {\n        'getConfig': function(componentName, callback) {\n            var result = defaultConfigRegistry.hasOwnProperty(componentName)\n                ? defaultConfigRegistry[componentName]\n                : null;\n            callback(result);\n        },\n\n        'loadComponent': function(componentName, config, callback) {\n            var errorCallback = makeErrorCallback(componentName);\n            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {\n                resolveConfig(componentName, errorCallback, loadedConfig, callback);\n            });\n        },\n\n        'loadTemplate': function(componentName, templateConfig, callback) {\n            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);\n        },\n\n        'loadViewModel': function(componentName, viewModelConfig, callback) {\n            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);\n        }\n    };\n\n    var createViewModelKey = 'createViewModel';\n\n    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it\n    // into the standard component definition format:\n    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.\n    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed\n    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,\n    // so this is implemented manually below.\n    function resolveConfig(componentName, errorCallback, config, callback) {\n        var result = {},\n            makeCallBackWhenZero = 2,\n            tryIssueCallback = function() {\n                if (--makeCallBackWhenZero === 0) {\n                    callback(result);\n                }\n            },\n            templateConfig = config['template'],\n            viewModelConfig = config['viewModel'];\n\n        if (templateConfig) {\n            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {\n                    result['template'] = resolvedTemplate;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n\n        if (viewModelConfig) {\n            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {\n                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {\n                    result[createViewModelKey] = resolvedViewModel;\n                    tryIssueCallback();\n                });\n            });\n        } else {\n            tryIssueCallback();\n        }\n    }\n\n    function resolveTemplate(errorCallback, templateConfig, callback) {\n        if (typeof templateConfig === 'string') {\n            // Markup - parse it\n            callback(ko.utils.parseHtmlFragment(templateConfig));\n        } else if (templateConfig instanceof Array) {\n            // Assume already an array of DOM nodes - pass through unchanged\n            callback(templateConfig);\n        } else if (isDocumentFragment(templateConfig)) {\n            // Document fragment - use its child nodes\n            callback(ko.utils.makeArray(templateConfig.childNodes));\n        } else if (templateConfig['element']) {\n            var element = templateConfig['element'];\n            if (isDomElement(element)) {\n                // Element instance - copy its child nodes\n                callback(cloneNodesFromTemplateSourceElement(element));\n            } else if (typeof element === 'string') {\n                // Element ID - find it, then copy its child nodes\n                var elemInstance = document.getElementById(element);\n                if (elemInstance) {\n                    callback(cloneNodesFromTemplateSourceElement(elemInstance));\n                } else {\n                    errorCallback('Cannot find element with ID ' + element);\n                }\n            } else {\n                errorCallback('Unknown element type: ' + element);\n            }\n        } else {\n            errorCallback('Unknown template value: ' + templateConfig);\n        }\n    }\n\n    function resolveViewModel(errorCallback, viewModelConfig, callback) {\n        if (typeof viewModelConfig === 'function') {\n            // Constructor - convert to standard factory function format\n            // By design, this does *not* supply componentInfo to the constructor, as the intent is that\n            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only\n            // be used in factory functions, not viewmodel constructors.\n            callback(function (params /*, componentInfo */) {\n                return new viewModelConfig(params);\n            });\n        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {\n            // Already a factory function - use it as-is\n            callback(viewModelConfig[createViewModelKey]);\n        } else if ('instance' in viewModelConfig) {\n            // Fixed object instance - promote to createViewModel format for API consistency\n            var fixedInstance = viewModelConfig['instance'];\n            callback(function (params, componentInfo) {\n                return fixedInstance;\n            });\n        } else if ('viewModel' in viewModelConfig) {\n            // Resolved AMD module whose value is of the form { viewModel: ... }\n            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);\n        } else {\n            errorCallback('Unknown viewModel value: ' + viewModelConfig);\n        }\n    }\n\n    function cloneNodesFromTemplateSourceElement(elemInstance) {\n        switch (ko.utils.tagNameLower(elemInstance)) {\n            case 'script':\n                return ko.utils.parseHtmlFragment(elemInstance.text);\n            case 'textarea':\n                return ko.utils.parseHtmlFragment(elemInstance.value);\n            case 'template':\n                // For browsers with proper <template> element support (i.e., where the .content property\n                // gives a document fragment), use that document fragment.\n                if (isDocumentFragment(elemInstance.content)) {\n                    return ko.utils.cloneNodes(elemInstance.content.childNodes);\n                }\n        }\n\n        // Regular elements such as <div>, and <template> elements on old browsers that don't really\n        // understand <template> and just treat it as a regular container\n        return ko.utils.cloneNodes(elemInstance.childNodes);\n    }\n\n    function isDomElement(obj) {\n        if (window['HTMLElement']) {\n            return obj instanceof HTMLElement;\n        } else {\n            return obj && obj.tagName && obj.nodeType === 1;\n        }\n    }\n\n    function isDocumentFragment(obj) {\n        if (window['DocumentFragment']) {\n            return obj instanceof DocumentFragment;\n        } else {\n            return obj && obj.nodeType === 11;\n        }\n    }\n\n    function possiblyGetConfigFromAmd(errorCallback, config, callback) {\n        if (typeof config['require'] === 'string') {\n            // The config is the value of an AMD module\n            if (amdRequire || window['require']) {\n                (amdRequire || window['require'])([config['require']], callback);\n            } else {\n                errorCallback('Uses require, but no AMD loader is present');\n            }\n        } else {\n            callback(config);\n        }\n    }\n\n    function makeErrorCallback(componentName) {\n        return function (message) {\n            throw new Error('Component \\'' + componentName + '\\': ' + message);\n        };\n    }\n\n    ko.exportSymbol('components.register', ko.components.register);\n    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);\n    ko.exportSymbol('components.unregister', ko.components.unregister);\n\n    // Expose the default loader so that developers can directly ask it for configuration\n    // or to resolve configuration\n    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);\n\n    // By default, the default loader is the only registered component loader\n    ko.components['loaders'].push(ko.components.defaultLoader);\n\n    // Privately expose the underlying config registry for use in old-IE shim\n    ko.components._allRegisteredComponents = defaultConfigRegistry;\n})();\n(function (undefined) {\n    // Overridable API for determining which component name applies to a given node. By overriding this,\n    // you can for example map specific tagNames to components that are not preregistered.\n    ko.components['getComponentNameForNode'] = function(node) {\n        var tagNameLower = ko.utils.tagNameLower(node);\n        if (ko.components.isRegistered(tagNameLower)) {\n            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603\n            if (tagNameLower.indexOf('-') != -1 || ('' + node) == \"[object HTMLUnknownElement]\" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {\n                return tagNameLower;\n            }\n        }\n    };\n\n    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {\n        // Determine if it's really a custom element matching a component\n        if (node.nodeType === 1) {\n            var componentName = ko.components['getComponentNameForNode'](node);\n            if (componentName) {\n                // It does represent a component, so add a component binding for it\n                allBindings = allBindings || {};\n\n                if (allBindings['component']) {\n                    // Avoid silently overwriting some other 'component' binding that may already be on the element\n                    throw new Error('Cannot use the \"component\" binding on a custom element matching a component');\n                }\n\n                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };\n\n                allBindings['component'] = valueAccessors\n                    ? function() { return componentBindingValue; }\n                    : componentBindingValue;\n            }\n        }\n\n        return allBindings;\n    }\n\n    var nativeBindingProviderInstance = new ko.bindingProvider();\n\n    function getComponentParamsFromCustomElement(elem, bindingContext) {\n        var paramsAttribute = elem.getAttribute('params');\n\n        if (paramsAttribute) {\n            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),\n                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {\n                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });\n                }),\n                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {\n                    var paramValue = paramValueComputed.peek();\n                    // Does the evaluation of the parameter value unwrap any observables?\n                    if (!paramValueComputed.isActive()) {\n                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.\n                        // Example: \"someVal: firstName, age: 123\" (whether or not firstName is an observable/computed)\n                        return paramValue;\n                    } else {\n                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)\n                        // level of observability, and any inner (resulting model value) level of observability.\n                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a\n                        // writable observable, the computed will also be writable and pass the value on to the observable.\n                        return ko.computed({\n                            'read': function() {\n                                return ko.utils.unwrapObservable(paramValueComputed());\n                            },\n                            'write': ko.isWriteableObservable(paramValue) && function(value) {\n                                paramValueComputed()(value);\n                            },\n                            disposeWhenNodeIsRemoved: elem\n                        });\n                    }\n                });\n\n            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'\n            // This is in case the developer wants to react to outer (binding) observability separately from inner\n            // (model value) observability, or in case the model value observable has subobservables.\n            if (!result.hasOwnProperty('$raw')) {\n                result['$raw'] = rawParamComputedValues;\n            }\n\n            return result;\n        } else {\n            // For consistency, absence of a \"params\" attribute is treated the same as the presence of\n            // any empty one. Otherwise component viewmodels need special code to check whether or not\n            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.\n            return { '$raw': {} };\n        }\n    }\n\n    // --------------------------------------------------------------------------------\n    // Compatibility code for older (pre-HTML5) IE browsers\n\n    if (ko.utils.ieVersion < 9) {\n        // Whenever you preregister a component, enable it as a custom element in the current document\n        ko.components['register'] = (function(originalFunction) {\n            return function(componentName) {\n                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element\n                return originalFunction.apply(this, arguments);\n            }\n        })(ko.components['register']);\n\n        // Whenever you create a document fragment, enable all preregistered component names as custom elements\n        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements\n        document.createDocumentFragment = (function(originalFunction) {\n            return function() {\n                var newDocFrag = originalFunction(),\n                    allComponents = ko.components._allRegisteredComponents;\n                for (var componentName in allComponents) {\n                    if (allComponents.hasOwnProperty(componentName)) {\n                        newDocFrag.createElement(componentName);\n                    }\n                }\n                return newDocFrag;\n            };\n        })(document.createDocumentFragment);\n    }\n})();(function(undefined) {\n\n    var componentLoadingOperationUniqueId = 0;\n\n    ko.bindingHandlers['component'] = {\n        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {\n            var currentViewModel,\n                currentLoadingOperationId,\n                disposeAssociatedComponentViewModel = function () {\n                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];\n                    if (typeof currentViewModelDispose === 'function') {\n                        currentViewModelDispose.call(currentViewModel);\n                    }\n                    currentViewModel = null;\n                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion\n                    currentLoadingOperationId = null;\n                },\n                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));\n\n            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);\n\n            ko.computed(function () {\n                var value = ko.utils.unwrapObservable(valueAccessor()),\n                    componentName, componentParams;\n\n                if (typeof value === 'string') {\n                    componentName = value;\n                } else {\n                    componentName = ko.utils.unwrapObservable(value['name']);\n                    componentParams = ko.utils.unwrapObservable(value['params']);\n                }\n\n                if (!componentName) {\n                    throw new Error('No component name specified');\n                }\n\n                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;\n                ko.components.get(componentName, function(componentDefinition) {\n                    // If this is not the current load operation for this element, ignore it.\n                    if (currentLoadingOperationId !== loadingOperationId) {\n                        return;\n                    }\n\n                    // Clean up previous state\n                    disposeAssociatedComponentViewModel();\n\n                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.\n                    if (!componentDefinition) {\n                        throw new Error('Unknown component \\'' + componentName + '\\'');\n                    }\n                    cloneTemplateIntoElement(componentName, componentDefinition, element);\n                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),\n                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {\n                            ctx['$component'] = componentViewModel;\n                            ctx['$componentTemplateNodes'] = originalChildNodes;\n                        });\n                    currentViewModel = componentViewModel;\n                    ko.applyBindingsToDescendants(childBindingContext, element);\n                });\n            }, null, { disposeWhenNodeIsRemoved: element });\n\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n\n    ko.virtualElements.allowedBindings['component'] = true;\n\n    function cloneTemplateIntoElement(componentName, componentDefinition, element) {\n        var template = componentDefinition['template'];\n        if (!template) {\n            throw new Error('Component \\'' + componentName + '\\' has no template');\n        }\n\n        var clonedNodesArray = ko.utils.cloneNodes(template);\n        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);\n    }\n\n    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {\n        var componentViewModelFactory = componentDefinition['createViewModel'];\n        return componentViewModelFactory\n            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })\n            : componentParams; // Template-only component\n    }\n\n})();\nvar attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };\nko.bindingHandlers['attr'] = {\n    'update': function(element, valueAccessor, allBindings) {\n        var value = ko.utils.unwrapObservable(valueAccessor()) || {};\n        ko.utils.objectForEach(value, function(attrName, attrValue) {\n            attrValue = ko.utils.unwrapObservable(attrValue);\n\n            // To cover cases like \"attr: { checked:someProp }\", we want to remove the attribute entirely\n            // when someProp is a \"no value\"-like value (strictly null, false, or undefined)\n            // (because the absence of the \"checked\" attr is how to mark an element as not checked, etc.)\n            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);\n            if (toRemove)\n                element.removeAttribute(attrName);\n\n            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the\n            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,\n            // but instead of figuring out the mode, we'll just set the attribute through the Javascript\n            // property for IE <= 8.\n            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {\n                attrName = attrHtmlToJavascriptMap[attrName];\n                if (toRemove)\n                    element.removeAttribute(attrName);\n                else\n                    element[attrName] = attrValue;\n            } else if (!toRemove) {\n                element.setAttribute(attrName, attrValue.toString());\n            }\n\n            // Treat \"name\" specially - although you can think of it as an attribute, it also needs\n            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)\n            // Deliberately being case-sensitive here because XHTML would regard \"Name\" as a different thing\n            // entirely, and there's no strong reason to allow for such casing in HTML.\n            if (attrName === \"name\") {\n                ko.utils.setElementName(element, toRemove ? \"\" : attrValue.toString());\n            }\n        });\n    }\n};\n(function() {\n\nko.bindingHandlers['checked'] = {\n    'after': ['value', 'attr'],\n    'init': function (element, valueAccessor, allBindings) {\n        var checkedValue = ko.pureComputed(function() {\n            // Treat \"value\" like \"checkedValue\" when it is included with \"checked\" binding\n            if (allBindings['has']('checkedValue')) {\n                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));\n            } else if (allBindings['has']('value')) {\n                return ko.utils.unwrapObservable(allBindings.get('value'));\n            }\n\n            return element.value;\n        });\n\n        function updateModel() {\n            // This updates the model value from the view value.\n            // It runs in response to DOM events (click) and changes in checkedValue.\n            var isChecked = element.checked,\n                elemValue = useCheckedValue ? checkedValue() : isChecked;\n\n            // When we're first setting up this computed, don't change any model state.\n            if (ko.computedContext.isInitial()) {\n                return;\n            }\n\n            // We can ignore unchecked radio buttons, because some other radio\n            // button will be getting checked, and that one can take care of updating state.\n            if (isRadio && !isChecked) {\n                return;\n            }\n\n            var modelValue = ko.dependencyDetection.ignore(valueAccessor);\n            if (valueIsArray) {\n                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;\n                if (oldElemValue !== elemValue) {\n                    // When we're responding to the checkedValue changing, and the element is\n                    // currently checked, replace the old elem value with the new elem value\n                    // in the model array.\n                    if (isChecked) {\n                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);\n                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);\n                    }\n\n                    oldElemValue = elemValue;\n                } else {\n                    // When we're responding to the user having checked/unchecked a checkbox,\n                    // add/remove the element value to the model array.\n                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);\n                }\n                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {\n                    modelValue(writableValue);\n                }\n            } else {\n                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);\n            }\n        };\n\n        function updateView() {\n            // This updates the view value from the model value.\n            // It runs in response to changes in the bound (checked) value.\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (valueIsArray) {\n                // When a checkbox is bound to an array, being checked represents its value being present in that array\n                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;\n            } else if (isCheckbox) {\n                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish\n                element.checked = modelValue;\n            } else {\n                // For radio buttons, being checked means that the radio button's value corresponds to the model value\n                element.checked = (checkedValue() === modelValue);\n            }\n        };\n\n        var isCheckbox = element.type == \"checkbox\",\n            isRadio = element.type == \"radio\";\n\n        // Only bind to check boxes and radio buttons\n        if (!isCheckbox && !isRadio) {\n            return;\n        }\n\n        var rawValue = valueAccessor(),\n            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),\n            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),\n            oldElemValue = valueIsArray ? checkedValue() : undefined,\n            useCheckedValue = isRadio || valueIsArray;\n\n        // IE 6 won't allow radio buttons to be selected unless they have a name\n        if (isRadio && !element.name)\n            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });\n\n        // Set up two computeds to update the binding:\n\n        // The first responds to changes in the checkedValue value and to element clicks\n        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });\n        ko.utils.registerEventHandler(element, \"click\", updateModel);\n\n        // The second responds to changes in the model value (the one associated with the checked binding)\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n\n        rawValue = undefined;\n    }\n};\nko.expressionRewriting.twoWayBindings['checked'] = true;\n\nko.bindingHandlers['checkedValue'] = {\n    'update': function (element, valueAccessor) {\n        element.value = ko.utils.unwrapObservable(valueAccessor());\n    }\n};\n\n})();var classesWrittenByBindingKey = '__ko__cssValue';\nko.bindingHandlers['css'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value !== null && typeof value == \"object\") {\n            ko.utils.objectForEach(value, function(className, shouldHaveClass) {\n                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);\n                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);\n            });\n        } else {\n            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value\n            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);\n            element[classesWrittenByBindingKey] = value;\n            ko.utils.toggleDomNodeCssClass(element, value, true);\n        }\n    }\n};\nko.bindingHandlers['enable'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        if (value && element.disabled)\n            element.removeAttribute(\"disabled\");\n        else if ((!value) && (!element.disabled))\n            element.disabled = true;\n    }\n};\n\nko.bindingHandlers['disable'] = {\n    'update': function (element, valueAccessor) {\n        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });\n    }\n};\n// For certain common events (currently just 'click'), allow a simplified data-binding syntax\n// e.g. click:handler instead of the usual full-length event:{click:handler}\nfunction makeEventHandlerShortcut(eventName) {\n    ko.bindingHandlers[eventName] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var newValueAccessor = function () {\n                var result = {};\n                result[eventName] = valueAccessor();\n                return result;\n            };\n            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);\n        }\n    }\n}\n\nko.bindingHandlers['event'] = {\n    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var eventsToHandle = valueAccessor() || {};\n        ko.utils.objectForEach(eventsToHandle, function(eventName) {\n            if (typeof eventName == \"string\") {\n                ko.utils.registerEventHandler(element, eventName, function (event) {\n                    var handlerReturnValue;\n                    var handlerFunction = valueAccessor()[eventName];\n                    if (!handlerFunction)\n                        return;\n\n                    try {\n                        // Take all the event args, and prefix with the viewmodel\n                        var argsForHandler = ko.utils.makeArray(arguments);\n                        viewModel = bindingContext['$data'];\n                        argsForHandler.unshift(viewModel);\n                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);\n                    } finally {\n                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                            if (event.preventDefault)\n                                event.preventDefault();\n                            else\n                                event.returnValue = false;\n                        }\n                    }\n\n                    var bubble = allBindings.get(eventName + 'Bubble') !== false;\n                    if (!bubble) {\n                        event.cancelBubble = true;\n                        if (event.stopPropagation)\n                            event.stopPropagation();\n                    }\n                });\n            }\n        });\n    }\n};\n// \"foreach: someExpression\" is equivalent to \"template: { foreach: someExpression }\"\n// \"foreach: { data: someExpression, afterAdd: myfn }\" is equivalent to \"template: { foreach: someExpression, afterAdd: myfn }\"\nko.bindingHandlers['foreach'] = {\n    makeTemplateValueAccessor: function(valueAccessor) {\n        return function() {\n            var modelValue = valueAccessor(),\n                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here\n\n            // If unwrappedValue is the array, pass in the wrapped value on its own\n            // The value will be unwrapped and tracked within the template binding\n            // (See https://github.com/SteveSanderson/knockout/issues/523)\n            if ((!unwrappedValue) || typeof unwrappedValue.length == \"number\")\n                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };\n\n            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates\n            ko.utils.unwrapObservable(modelValue);\n            return {\n                'foreach': unwrappedValue['data'],\n                'as': unwrappedValue['as'],\n                'includeDestroyed': unwrappedValue['includeDestroyed'],\n                'afterAdd': unwrappedValue['afterAdd'],\n                'beforeRemove': unwrappedValue['beforeRemove'],\n                'afterRender': unwrappedValue['afterRender'],\n                'beforeMove': unwrappedValue['beforeMove'],\n                'afterMove': unwrappedValue['afterMove'],\n                'templateEngine': ko.nativeTemplateEngine.instance\n            };\n        };\n    },\n    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));\n    },\n    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);\n    }\n};\nko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings\nko.virtualElements.allowedBindings['foreach'] = true;\nvar hasfocusUpdatingProperty = '__ko_hasfocusUpdating';\nvar hasfocusLastValue = '__ko_hasfocusLastValue';\nko.bindingHandlers['hasfocus'] = {\n    'init': function(element, valueAccessor, allBindings) {\n        var handleElementFocusChange = function(isFocused) {\n            // Where possible, ignore which event was raised and determine focus state using activeElement,\n            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.\n            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,\n            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus\n            // from calling 'blur()' on the element when it loses focus.\n            // Discussion at https://github.com/SteveSanderson/knockout/pull/352\n            element[hasfocusUpdatingProperty] = true;\n            var ownerDoc = element.ownerDocument;\n            if (\"activeElement\" in ownerDoc) {\n                var active;\n                try {\n                    active = ownerDoc.activeElement;\n                } catch(e) {\n                    // IE9 throws if you access activeElement during page load (see issue #703)\n                    active = ownerDoc.body;\n                }\n                isFocused = (active === element);\n            }\n            var modelValue = valueAccessor();\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);\n\n            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function\n            element[hasfocusLastValue] = isFocused;\n            element[hasfocusUpdatingProperty] = false;\n        };\n        var handleElementFocusIn = handleElementFocusChange.bind(null, true);\n        var handleElementFocusOut = handleElementFocusChange.bind(null, false);\n\n        ko.utils.registerEventHandler(element, \"focus\", handleElementFocusIn);\n        ko.utils.registerEventHandler(element, \"focusin\", handleElementFocusIn); // For IE\n        ko.utils.registerEventHandler(element, \"blur\",  handleElementFocusOut);\n        ko.utils.registerEventHandler(element, \"focusout\",  handleElementFocusOut); // For IE\n    },\n    'update': function(element, valueAccessor) {\n        var value = !!ko.utils.unwrapObservable(valueAccessor());\n\n        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {\n            value ? element.focus() : element.blur();\n\n            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).\n            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current\n            // element was focused already.\n            if (!value && element[hasfocusLastValue]) {\n                element.ownerDocument.body.focus();\n            }\n\n            // For IE, which doesn't reliably fire \"focus\" or \"blur\" events synchronously\n            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? \"focusin\" : \"focusout\"]);\n        }\n    }\n};\nko.expressionRewriting.twoWayBindings['hasfocus'] = true;\n\nko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make \"hasFocus\" an alias\nko.expressionRewriting.twoWayBindings['hasFocus'] = true;\nko.bindingHandlers['html'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        // setHtml will unwrap the value if needed\n        ko.utils.setHtml(element, valueAccessor());\n    }\n};\n// Makes a binding like with or if\nfunction makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {\n    ko.bindingHandlers[bindingKey] = {\n        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var didDisplayOnLastUpdate,\n                savedNodes;\n            ko.computed(function() {\n                var rawValue = valueAccessor(),\n                    dataValue = ko.utils.unwrapObservable(rawValue),\n                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue\n                    isFirstRender = !savedNodes,\n                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);\n\n                if (needsRefresh) {\n                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.\n                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {\n                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);\n                    }\n\n                    if (shouldDisplay) {\n                        if (!isFirstRender) {\n                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));\n                        }\n                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);\n                    } else {\n                        ko.virtualElements.emptyNode(element);\n                    }\n\n                    didDisplayOnLastUpdate = shouldDisplay;\n                }\n            }, null, { disposeWhenNodeIsRemoved: element });\n            return { 'controlsDescendantBindings': true };\n        }\n    };\n    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings\n    ko.virtualElements.allowedBindings[bindingKey] = true;\n}\n\n// Construct the actual binding handlers\nmakeWithIfBinding('if');\nmakeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);\nmakeWithIfBinding('with', true /* isWith */, false /* isNot */,\n    function(bindingContext, dataValue) {\n        return bindingContext.createStaticChildContext(dataValue);\n    }\n);\nvar captionPlaceholder = {};\nko.bindingHandlers['options'] = {\n    'init': function(element) {\n        if (ko.utils.tagNameLower(element) !== \"select\")\n            throw new Error(\"options binding applies only to SELECT elements\");\n\n        // Remove all existing <option>s.\n        while (element.length > 0) {\n            element.remove(0);\n        }\n\n        // Ensures that the binding processor doesn't try to bind the options\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor, allBindings) {\n        function selectedOptions() {\n            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });\n        }\n\n        var selectWasPreviouslyEmpty = element.length == 0,\n            multiple = element.multiple,\n            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,\n            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),\n            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),\n            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),\n            arrayToDomNodeChildrenOptions = {},\n            captionValue,\n            filteredArray,\n            previousSelectedValues = [];\n\n        if (!valueAllowUnset) {\n            if (multiple) {\n                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);\n            } else if (element.selectedIndex >= 0) {\n                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));\n            }\n        }\n\n        if (unwrappedArray) {\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // If caption is included, add it to the array\n            if (allBindings['has']('optionsCaption')) {\n                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));\n                // If caption value is null or undefined, don't show a caption\n                if (captionValue !== null && captionValue !== undefined) {\n                    filteredArray.unshift(captionPlaceholder);\n                }\n            }\n        } else {\n            // If a falsy value is provided (e.g. null), we'll simply empty the select element\n        }\n\n        function applyToObject(object, predicate, defaultValue) {\n            var predicateType = typeof predicate;\n            if (predicateType == \"function\")    // Given a function; run it against the data value\n                return predicate(object);\n            else if (predicateType == \"string\") // Given a string; treat it as a property name on the data value\n                return object[predicate];\n            else                                // Given no optionsText arg; use the data value itself\n                return defaultValue;\n        }\n\n        // The following functions can run at two different times:\n        // The first is when the whole array is being updated directly from this binding handler.\n        // The second is when an observable value for a specific array entry is updated.\n        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.\n        var itemUpdate = false;\n        function optionForArrayItem(arrayEntry, index, oldOptions) {\n            if (oldOptions.length) {\n                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];\n                itemUpdate = true;\n            }\n            var option = element.ownerDocument.createElement(\"option\");\n            if (arrayEntry === captionPlaceholder) {\n                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));\n                ko.selectExtensions.writeValue(option, undefined);\n            } else {\n                // Apply a value to the option element\n                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);\n                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));\n\n                // Apply some text to the option element\n                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);\n                ko.utils.setTextContent(option, optionText);\n            }\n            return [option];\n        }\n\n        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection\n        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208\n        arrayToDomNodeChildrenOptions['beforeRemove'] =\n            function (option) {\n                element.removeChild(option);\n            };\n\n        function setSelectionCallback(arrayEntry, newOptions) {\n            if (itemUpdate && valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else if (previousSelectedValues.length) {\n                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.\n                // That's why we first added them without selection. Now it's time to set the selection.\n                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;\n                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);\n\n                // If this option was changed from being selected during a single-item update, notify the change\n                if (itemUpdate && !isSelected) {\n                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                }\n            }\n        }\n\n        var callback = setSelectionCallback;\n        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == \"function\") {\n            callback = function(arrayEntry, newOptions) {\n                setSelectionCallback(arrayEntry, newOptions);\n                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);\n            }\n        }\n\n        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);\n\n        ko.dependencyDetection.ignore(function () {\n            if (valueAllowUnset) {\n                // The model value is authoritative, so make sure its value is the one selected\n                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);\n            } else {\n                // Determine if the selection has changed as a result of updating the options list\n                var selectionChanged;\n                if (multiple) {\n                    // For a multiple-select box, compare the new selection count to the previous one\n                    // But if nothing was selected before, the selection can't have changed\n                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;\n                } else {\n                    // For a single-select box, compare the current value to the previous value\n                    // But if nothing was selected before or nothing is selected now, just look for a change in selection\n                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)\n                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])\n                        : (previousSelectedValues.length || element.selectedIndex >= 0);\n                }\n\n                // Ensure consistency between model value and selected option.\n                // If the dropdown was changed so that selection is no longer the same,\n                // notify the value or selectedOptions binding.\n                if (selectionChanged) {\n                    ko.utils.triggerEvent(element, \"change\");\n                }\n            }\n        });\n\n        // Workaround for IE bug\n        ko.utils.ensureSelectElementIsRenderedCorrectly(element);\n\n        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)\n            element.scrollTop = previousScrollTop;\n    }\n};\nko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();\nko.bindingHandlers['selectedOptions'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        ko.utils.registerEventHandler(element, \"change\", function () {\n            var value = valueAccessor(), valueToWrite = [];\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                if (node.selected)\n                    valueToWrite.push(ko.selectExtensions.readValue(node));\n            });\n            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);\n        });\n    },\n    'update': function (element, valueAccessor) {\n        if (ko.utils.tagNameLower(element) != \"select\")\n            throw new Error(\"values binding applies only to SELECT elements\");\n\n        var newValue = ko.utils.unwrapObservable(valueAccessor()),\n            previousScrollTop = element.scrollTop;\n\n        if (newValue && typeof newValue.length == \"number\") {\n            ko.utils.arrayForEach(element.getElementsByTagName(\"option\"), function(node) {\n                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;\n                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE\n                    ko.utils.setOptionNodeSelectionState(node, isSelected);\n                }\n            });\n        }\n\n        element.scrollTop = previousScrollTop;\n    }\n};\nko.expressionRewriting.twoWayBindings['selectedOptions'] = true;\nko.bindingHandlers['style'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor() || {});\n        ko.utils.objectForEach(value, function(styleName, styleValue) {\n            styleValue = ko.utils.unwrapObservable(styleValue);\n\n            if (styleValue === null || styleValue === undefined || styleValue === false) {\n                // Empty string removes the value, whereas null/undefined have no effect\n                styleValue = \"\";\n            }\n\n            element.style[styleName] = styleValue;\n        });\n    }\n};\nko.bindingHandlers['submit'] = {\n    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n        if (typeof valueAccessor() != \"function\")\n            throw new Error(\"The value for a submit binding must be a function\");\n        ko.utils.registerEventHandler(element, \"submit\", function (event) {\n            var handlerReturnValue;\n            var value = valueAccessor();\n            try { handlerReturnValue = value.call(bindingContext['$data'], element); }\n            finally {\n                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.\n                    if (event.preventDefault)\n                        event.preventDefault();\n                    else\n                        event.returnValue = false;\n                }\n            }\n        });\n    }\n};\nko.bindingHandlers['text'] = {\n    'init': function() {\n        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).\n        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.\n        return { 'controlsDescendantBindings': true };\n    },\n    'update': function (element, valueAccessor) {\n        ko.utils.setTextContent(element, valueAccessor());\n    }\n};\nko.virtualElements.allowedBindings['text'] = true;\n(function () {\n\nif (window && window.navigator) {\n    var parseVersion = function (matches) {\n        if (matches) {\n            return parseFloat(matches[1]);\n        }\n    };\n\n    // Detect various browser versions because some old versions don't fully support the 'input' event\n    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),\n        userAgent = window.navigator.userAgent,\n        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\\/([^ ]*) safari/i)),\n        firefoxVersion = parseVersion(userAgent.match(/Firefox\\/([^ ]*)/));\n}\n\n// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.\n// But it does fire the 'selectionchange' event on many of those, presumably because the\n// cursor is moving and that counts as the selection changing. The 'selectionchange' event is\n// fired at the document level only and doesn't directly indicate which element changed. We\n// set up just one event handler for the document and use 'activeElement' to determine which\n// element was changed.\nif (ko.utils.ieVersion < 10) {\n    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),\n        selectionChangeHandlerName = ko.utils.domData.nextKey();\n    var selectionChangeHandler = function(event) {\n        var target = this.activeElement,\n            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);\n        if (handler) {\n            handler(event);\n        }\n    };\n    var registerForSelectionChangeEvent = function (element, handler) {\n        var ownerDoc = element.ownerDocument;\n        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {\n            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);\n            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);\n        }\n        ko.utils.domData.set(element, selectionChangeHandlerName, handler);\n    };\n}\n\nko.bindingHandlers['textInput'] = {\n    'init': function (element, valueAccessor, allBindings) {\n\n        var previousElementValue = element.value,\n            timeoutHandle,\n            elementValueBeforeEvent;\n\n        var updateModel = function (event) {\n            clearTimeout(timeoutHandle);\n            elementValueBeforeEvent = timeoutHandle = undefined;\n\n            var elementValue = element.value;\n            if (previousElementValue !== elementValue) {\n                // Provide a way for tests to know exactly which event was processed\n                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;\n                previousElementValue = elementValue;\n                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);\n            }\n        };\n\n        var deferUpdateModel = function (event) {\n            if (!timeoutHandle) {\n                // The elementValueBeforeEvent variable is set *only* during the brief gap between an\n                // event firing and the updateModel function running. This allows us to ignore model\n                // updates that are from the previous state of the element, usually due to techniques\n                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.\n                elementValueBeforeEvent = element.value;\n                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;\n                timeoutHandle = ko.utils.setTimeout(handler, 4);\n            }\n        };\n\n        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);\n        // so we'll make sure all updates are asynchronous\n        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;\n\n        var updateView = function () {\n            var modelValue = ko.utils.unwrapObservable(valueAccessor());\n\n            if (modelValue === null || modelValue === undefined) {\n                modelValue = '';\n            }\n\n            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateView, 4);\n                return;\n            }\n\n            // Update the element only if the element and model are different. On some browsers, updating the value\n            // will move the cursor to the end of the input, which would be bad while the user is typing.\n            if (element.value !== modelValue) {\n                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value\n                element.value = modelValue;\n            }\n        };\n\n        var onEvent = function (event, handler) {\n            ko.utils.registerEventHandler(element, event, handler);\n        };\n\n        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {\n            // Provide a way for tests to specify exactly which events are bound\n            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {\n                if (eventName.slice(0,5) == 'after') {\n                    onEvent(eventName.slice(5), deferUpdateModel);\n                } else {\n                    onEvent(eventName, updateModel);\n                }\n            });\n        } else {\n            if (ko.utils.ieVersion < 10) {\n                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever\n                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,\n                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it\n                // when using autocomplete, we'll use 'propertychange' for it also.\n                onEvent('propertychange', function(event) {\n                    if (event.propertyName === 'value') {\n                        ieUpdateModel(event);\n                    }\n                });\n\n                if (ko.utils.ieVersion == 8) {\n                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from\n                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following\n                    // events too.\n                    onEvent('keyup', updateModel);      // A single keystoke\n                    onEvent('keydown', updateModel);    // The first character when a key is held down\n                }\n                if (ko.utils.ieVersion >= 8) {\n                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using\n                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text\n                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'\n                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.\n                    // These are also needed in IE8 because of the bug described above.\n                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.\n                    onEvent('dragend', deferUpdateModel);\n                }\n            } else {\n                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed\n                // through the user interface.\n                onEvent('input', updateModel);\n\n                if (safariVersion < 5 && ko.utils.tagNameLower(element) === \"textarea\") {\n                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'\n                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.\n                    onEvent('keydown', deferUpdateModel);\n                    onEvent('paste', deferUpdateModel);\n                    onEvent('cut', deferUpdateModel);\n                } else if (operaVersion < 11) {\n                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.\n                    // We can try to catch some of those using 'keydown'.\n                    onEvent('keydown', deferUpdateModel);\n                } else if (firefoxVersion < 4.0) {\n                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete\n                    onEvent('DOMAutoComplete', updateModel);\n\n                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.\n                    onEvent('dragdrop', updateModel);       // <3.5\n                    onEvent('drop', updateModel);           // 3.5\n                }\n            }\n        }\n\n        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.\n        onEvent('change', updateModel);\n\n        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });\n    }\n};\nko.expressionRewriting.twoWayBindings['textInput'] = true;\n\n// textinput is an alias for textInput\nko.bindingHandlers['textinput'] = {\n    // preprocess is the only way to set up a full alias\n    'preprocess': function (value, name, addBinding) {\n        addBinding('textInput', value);\n    }\n};\n\n})();ko.bindingHandlers['uniqueName'] = {\n    'init': function (element, valueAccessor) {\n        if (valueAccessor()) {\n            var name = \"ko_unique_\" + (++ko.bindingHandlers['uniqueName'].currentIndex);\n            ko.utils.setElementName(element, name);\n        }\n    }\n};\nko.bindingHandlers['uniqueName'].currentIndex = 0;\nko.bindingHandlers['value'] = {\n    'after': ['options', 'foreach'],\n    'init': function (element, valueAccessor, allBindings) {\n        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit\n        if (element.tagName.toLowerCase() == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });\n            return;\n        }\n\n        // Always catch \"change\" event; possibly other events too if asked\n        var eventsToCatch = [\"change\"];\n        var requestedEventsToCatch = allBindings.get(\"valueUpdate\");\n        var propertyChangedFired = false;\n        var elementValueBeforeEvent = null;\n\n        if (requestedEventsToCatch) {\n            if (typeof requestedEventsToCatch == \"string\") // Allow both individual event names, and arrays of event names\n                requestedEventsToCatch = [requestedEventsToCatch];\n            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);\n            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);\n        }\n\n        var valueUpdateHandler = function() {\n            elementValueBeforeEvent = null;\n            propertyChangedFired = false;\n            var modelValue = valueAccessor();\n            var elementValue = ko.selectExtensions.readValue(element);\n            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);\n        }\n\n        // Workaround for https://github.com/SteveSanderson/knockout/issues/122\n        // IE doesn't fire \"change\" events on textboxes if the user selects a value from its autocomplete list\n        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == \"input\" && element.type == \"text\"\n                                       && element.autocomplete != \"off\" && (!element.form || element.form.autocomplete != \"off\");\n        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, \"propertychange\") == -1) {\n            ko.utils.registerEventHandler(element, \"propertychange\", function () { propertyChangedFired = true });\n            ko.utils.registerEventHandler(element, \"focus\", function () { propertyChangedFired = false });\n            ko.utils.registerEventHandler(element, \"blur\", function() {\n                if (propertyChangedFired) {\n                    valueUpdateHandler();\n                }\n            });\n        }\n\n        ko.utils.arrayForEach(eventsToCatch, function(eventName) {\n            // The syntax \"after<eventname>\" means \"run the handler asynchronously after the event\"\n            // This is useful, for example, to catch \"keydown\" events after the browser has updated the control\n            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)\n            var handler = valueUpdateHandler;\n            if (ko.utils.stringStartsWith(eventName, \"after\")) {\n                handler = function() {\n                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between\n                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen\n                    // at the earliest asynchronous opportunity. We store this temporary information so that\n                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,\n                    // we can overwrite that model value change with the value the user just typed. Otherwise,\n                    // techniques like rateLimit can trigger model changes at critical moments that will\n                    // override the user's inputs, causing keystrokes to be lost.\n                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);\n                    ko.utils.setTimeout(valueUpdateHandler, 0);\n                };\n                eventName = eventName.substring(\"after\".length);\n            }\n            ko.utils.registerEventHandler(element, eventName, handler);\n        });\n\n        var updateFromModel = function () {\n            var newValue = ko.utils.unwrapObservable(valueAccessor());\n            var elementValue = ko.selectExtensions.readValue(element);\n\n            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {\n                ko.utils.setTimeout(updateFromModel, 0);\n                return;\n            }\n\n            var valueHasChanged = (newValue !== elementValue);\n\n            if (valueHasChanged) {\n                if (ko.utils.tagNameLower(element) === \"select\") {\n                    var allowUnset = allBindings.get('valueAllowUnset');\n                    var applyValueAction = function () {\n                        ko.selectExtensions.writeValue(element, newValue, allowUnset);\n                    };\n                    applyValueAction();\n\n                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {\n                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,\n                        // because you're not allowed to have a model value that disagrees with a visible UI selection.\n                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, \"change\"]);\n                    } else {\n                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread\n                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread\n                        // to apply the value as well.\n                        ko.utils.setTimeout(applyValueAction, 0);\n                    }\n                } else {\n                    ko.selectExtensions.writeValue(element, newValue);\n                }\n            }\n        };\n\n        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });\n    },\n    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding\n};\nko.expressionRewriting.twoWayBindings['value'] = true;\nko.bindingHandlers['visible'] = {\n    'update': function (element, valueAccessor) {\n        var value = ko.utils.unwrapObservable(valueAccessor());\n        var isCurrentlyVisible = !(element.style.display == \"none\");\n        if (value && !isCurrentlyVisible)\n            element.style.display = \"\";\n        else if ((!value) && isCurrentlyVisible)\n            element.style.display = \"none\";\n    }\n};\n// 'click' is just a shorthand for the usual full-length event:{click:handler}\nmakeEventHandlerShortcut('click');\n// If you want to make a custom template engine,\n//\n// [1] Inherit from this class (like ko.nativeTemplateEngine does)\n// [2] Override 'renderTemplateSource', supplying a function with this signature:\n//\n//        function (templateSource, bindingContext, options) {\n//            // - templateSource.text() is the text of the template you should render\n//            // - bindingContext.$data is the data you should pass into the template\n//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,\n//            //     and bindingContext.$root available in the template too\n//            // - options gives you access to any other properties set on \"data-bind: { template: options }\"\n//            // - templateDocument is the document object of the template\n//            //\n//            // Return value: an array of DOM nodes\n//        }\n//\n// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:\n//\n//        function (script) {\n//            // Return value: Whatever syntax means \"Evaluate the JavaScript statement 'script' and output the result\"\n//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'\n//        }\n//\n//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.\n//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)\n//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.\n\nko.templateEngine = function () { };\n\nko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    throw new Error(\"Override renderTemplateSource\");\n};\n\nko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {\n    throw new Error(\"Override createJavaScriptEvaluatorBlock\");\n};\n\nko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {\n    // Named template\n    if (typeof template == \"string\") {\n        templateDocument = templateDocument || document;\n        var elem = templateDocument.getElementById(template);\n        if (!elem)\n            throw new Error(\"Cannot find template with ID \" + template);\n        return new ko.templateSources.domElement(elem);\n    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {\n        // Anonymous template\n        return new ko.templateSources.anonymousTemplate(template);\n    } else\n        throw new Error(\"Unknown template type: \" + template);\n};\n\nko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);\n};\n\nko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {\n    // Skip rewriting if requested\n    if (this['allowTemplateRewriting'] === false)\n        return true;\n    return this['makeTemplateSource'](template, templateDocument)['data'](\"isRewritten\");\n};\n\nko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {\n    var templateSource = this['makeTemplateSource'](template, templateDocument);\n    var rewritten = rewriterCallback(templateSource['text']());\n    templateSource['text'](rewritten);\n    templateSource['data'](\"isRewritten\", true);\n};\n\nko.exportSymbol('templateEngine', ko.templateEngine);\n\nko.templateRewriting = (function () {\n    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\\"[^\\\"]*\\\"|\\'[^\\']*\\'|[^>]*))?)*\\s+)data-bind\\s*=\\s*([\"'])([\\s\\S]*?)\\3/gi;\n    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*-->/g;\n\n    function validateDataBindValuesForRewriting(keyValueArray) {\n        var allValidators = ko.expressionRewriting.bindingRewriteValidators;\n        for (var i = 0; i < keyValueArray.length; i++) {\n            var key = keyValueArray[i]['key'];\n            if (allValidators.hasOwnProperty(key)) {\n                var validator = allValidators[key];\n\n                if (typeof validator === \"function\") {\n                    var possibleErrorMessage = validator(keyValueArray[i]['value']);\n                    if (possibleErrorMessage)\n                        throw new Error(possibleErrorMessage);\n                } else if (!validator) {\n                    throw new Error(\"This template engine does not support the '\" + key + \"' binding within its templates\");\n                }\n            }\n        }\n    }\n\n    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {\n        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);\n        validateDataBindValuesForRewriting(dataBindKeyValueArray);\n        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});\n\n        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional\n        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this\n        // extra indirection.\n        var applyBindingsToNextSiblingScript =\n            \"ko.__tr_ambtns(function($context,$element){return(function(){return{ \" + rewrittenDataBindAttributeValue + \" } })()},'\" + nodeName.toLowerCase() + \"')\";\n        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;\n    }\n\n    return {\n        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {\n            if (!templateEngine['isTemplateRewritten'](template, templateDocument))\n                templateEngine['rewriteTemplate'](template, function (htmlString) {\n                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);\n                }, templateDocument);\n        },\n\n        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {\n            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);\n            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {\n                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ \"<!-- ko -->\", /* nodeName: */ \"#comment\", templateEngine);\n            });\n        },\n\n        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {\n            return ko.memoization.memoize(function (domNode, bindingContext) {\n                var nodeToBind = domNode.nextSibling;\n                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {\n                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);\n                }\n            });\n        }\n    }\n})();\n\n\n// Exported only because it has to be referenced by string lookup from within rewritten template\nko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);\n(function() {\n    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving\n    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)\n    //\n    // Two are provided by default:\n    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element\n    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but\n    //                                           without reading/writing the actual element text content, since it will be overwritten\n    //                                           with the rendered template output.\n    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.\n    // Template sources need to have the following functions:\n    //   text() \t\t\t- returns the template text from your storage location\n    //   text(value)\t\t- writes the supplied template text to your storage location\n    //   data(key)\t\t\t- reads values stored using data(key, value) - see below\n    //   data(key, value)\t- associates \"value\" with this template and the key \"key\". Is used to store information like \"isRewritten\".\n    //\n    // Optionally, template sources can also have the following functions:\n    //   nodes()            - returns a DOM element containing the nodes of this template, where available\n    //   nodes(value)       - writes the given DOM element to your storage location\n    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()\n    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().\n    //\n    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were\n    // using and overriding \"makeTemplateSource\" to return an instance of your custom template source.\n\n    ko.templateSources = {};\n\n    // ---- ko.templateSources.domElement -----\n\n    // template types\n    var templateScript = 1,\n        templateTextArea = 2,\n        templateTemplate = 3,\n        templateElement = 4;\n\n    ko.templateSources.domElement = function(element) {\n        this.domElement = element;\n\n        if (element) {\n            var tagNameLower = ko.utils.tagNameLower(element);\n            this.templateType =\n                tagNameLower === \"script\" ? templateScript :\n                tagNameLower === \"textarea\" ? templateTextArea :\n                    // For browsers with proper <template> element support, where the .content property gives a document fragment\n                tagNameLower == \"template\" && element.content && element.content.nodeType === 11 ? templateTemplate :\n                templateElement;\n        }\n    }\n\n    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {\n        var elemContentsProperty = this.templateType === templateScript ? \"text\"\n                                 : this.templateType === templateTextArea ? \"value\"\n                                 : \"innerHTML\";\n\n        if (arguments.length == 0) {\n            return this.domElement[elemContentsProperty];\n        } else {\n            var valueToWrite = arguments[0];\n            if (elemContentsProperty === \"innerHTML\")\n                ko.utils.setHtml(this.domElement, valueToWrite);\n            else\n                this.domElement[elemContentsProperty] = valueToWrite;\n        }\n    };\n\n    var dataDomDataPrefix = ko.utils.domData.nextKey() + \"_\";\n    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {\n        if (arguments.length === 1) {\n            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);\n        } else {\n            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);\n        }\n    };\n\n    var templatesDomDataKey = ko.utils.domData.nextKey();\n    function getTemplateDomData(element) {\n        return ko.utils.domData.get(element, templatesDomDataKey) || {};\n    }\n    function setTemplateDomData(element, data) {\n        ko.utils.domData.set(element, templatesDomDataKey, data);\n    }\n\n    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {\n        var element = this.domElement;\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(element),\n                containerData = templateData.containerData;\n            return containerData || (\n                this.templateType === templateTemplate ? element.content :\n                this.templateType === templateElement ? element :\n                undefined);\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(element, {containerData: valueToWrite});\n        }\n    };\n\n    // ---- ko.templateSources.anonymousTemplate -----\n    // Anonymous templates are normally saved/retrieved as DOM nodes through \"nodes\".\n    // For compatibility, you can also read \"text\"; it will be serialized from the nodes on demand.\n    // Writing to \"text\" is still supported, but then the template data will not be available as DOM nodes.\n\n    ko.templateSources.anonymousTemplate = function(element) {\n        this.domElement = element;\n    }\n    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();\n    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;\n    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {\n        if (arguments.length == 0) {\n            var templateData = getTemplateDomData(this.domElement);\n            if (templateData.textData === undefined && templateData.containerData)\n                templateData.textData = templateData.containerData.innerHTML;\n            return templateData.textData;\n        } else {\n            var valueToWrite = arguments[0];\n            setTemplateDomData(this.domElement, {textData: valueToWrite});\n        }\n    };\n\n    ko.exportSymbol('templateSources', ko.templateSources);\n    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);\n    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);\n})();\n(function () {\n    var _templateEngine;\n    ko.setTemplateEngine = function (templateEngine) {\n        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))\n            throw new Error(\"templateEngine must inherit from ko.templateEngine\");\n        _templateEngine = templateEngine;\n    }\n\n    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {\n        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);\n        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {\n            nextInQueue = ko.virtualElements.nextSibling(node);\n            action(node, nextInQueue);\n        }\n    }\n\n    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {\n        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element\n        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because\n        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,\n        // (1) Does a regular \"applyBindings\" to associate bindingContext with this node and to activate any non-memoized bindings\n        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)\n\n        if (continuousNodeArray.length) {\n            var firstNode = continuousNodeArray[0],\n                lastNode = continuousNodeArray[continuousNodeArray.length - 1],\n                parentNode = firstNode.parentNode,\n                provider = ko.bindingProvider['instance'],\n                preprocessNode = provider['preprocessNode'];\n\n            if (preprocessNode) {\n                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {\n                    var nodePreviousSibling = node.previousSibling;\n                    var newNodes = preprocessNode.call(provider, node);\n                    if (newNodes) {\n                        if (node === firstNode)\n                            firstNode = newNodes[0] || nextNodeInRange;\n                        if (node === lastNode)\n                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;\n                    }\n                });\n\n                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.\n                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real\n                // first node needs to be in the array).\n                continuousNodeArray.length = 0;\n                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do\n                    return;\n                }\n                if (firstNode === lastNode) {\n                    continuousNodeArray.push(firstNode);\n                } else {\n                    continuousNodeArray.push(firstNode, lastNode);\n                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n                }\n            }\n\n            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)\n            // whereas a regular applyBindings won't introduce new memoized nodes\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.applyBindings(bindingContext, node);\n            });\n            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {\n                if (node.nodeType === 1 || node.nodeType === 8)\n                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);\n            });\n\n            // Make sure any changes done by applyBindings or unmemoize are reflected in the array\n            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);\n        }\n    }\n\n    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {\n        return nodeOrNodeArray.nodeType ? nodeOrNodeArray\n                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]\n                                        : null;\n    }\n\n    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {\n        options = options || {};\n        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n        var templateDocument = (firstTargetNode || template || {}).ownerDocument;\n        var templateEngineToUse = (options['templateEngine'] || _templateEngine);\n        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);\n        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);\n\n        // Loosely check result is an array of DOM nodes\n        if ((typeof renderedNodesArray.length != \"number\") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != \"number\"))\n            throw new Error(\"Template engine must return an array of DOM nodes\");\n\n        var haveAddedNodesToParent = false;\n        switch (renderMode) {\n            case \"replaceChildren\":\n                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"replaceNode\":\n                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);\n                haveAddedNodesToParent = true;\n                break;\n            case \"ignoreTargetNode\": break;\n            default:\n                throw new Error(\"Unknown renderMode: \" + renderMode);\n        }\n\n        if (haveAddedNodesToParent) {\n            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);\n            if (options['afterRender'])\n                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);\n        }\n\n        return renderedNodesArray;\n    }\n\n    function resolveTemplateName(template, data, context) {\n        // The template can be specified as:\n        if (ko.isObservable(template)) {\n            // 1. An observable, with string value\n            return template();\n        } else if (typeof template === 'function') {\n            // 2. A function of (data, context) returning a string\n            return template(data, context);\n        } else {\n            // 3. A string\n            return template;\n        }\n    }\n\n    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {\n        options = options || {};\n        if ((options['templateEngine'] || _templateEngine) == undefined)\n            throw new Error(\"Set a template engine before calling renderTemplate\");\n        renderMode = renderMode || \"replaceChildren\";\n\n        if (targetNodeOrNodeArray) {\n            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n\n            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)\n            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == \"replaceNode\") ? firstTargetNode.parentNode : firstTargetNode;\n\n            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes\n                function () {\n                    // Ensure we've got a proper binding context to work with\n                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))\n                        ? dataOrBindingContext\n                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { \"exportDependencies\": true });\n\n                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),\n                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n\n                    if (renderMode == \"replaceNode\") {\n                        targetNodeOrNodeArray = renderedNodesArray;\n                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n                    }\n                },\n                null,\n                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }\n            );\n        } else {\n            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node\n            return ko.memoization.memoize(function (domNode) {\n                ko.renderTemplate(template, dataOrBindingContext, options, domNode, \"replaceNode\");\n            });\n        }\n    };\n\n    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {\n        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then\n        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.\n        var arrayItemContext;\n\n        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode\n        var executeTemplateForArrayItem = function (arrayValue, index) {\n            // Support selecting template as a function of the data being rendered\n            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {\n                context['$index'] = index;\n            });\n\n            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);\n            return executeTemplate(null, \"ignoreTargetNode\", templateName, arrayItemContext, options);\n        }\n\n        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode\n        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {\n            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);\n            if (options['afterRender'])\n                options['afterRender'](addedNodesArray, arrayValue);\n\n            // release the \"cache\" variable, so that it can be collected by\n            // the GC when its value isn't used from within the bindings anymore.\n            arrayItemContext = null;\n        };\n\n        return ko.dependentObservable(function () {\n            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];\n            if (typeof unwrappedArray.length == \"undefined\") // Coerce single value into array\n                unwrappedArray = [unwrappedArray];\n\n            // Filter out any entries marked as destroyed\n            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {\n                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);\n            });\n\n            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).\n            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.\n            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);\n\n        }, null, { disposeWhenNodeIsRemoved: targetNode });\n    };\n\n    var templateComputedDomDataKey = ko.utils.domData.nextKey();\n    function disposeOldComputedAndStoreNewOne(element, newComputed) {\n        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);\n        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))\n            oldComputed.dispose();\n        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);\n    }\n\n    ko.bindingHandlers['template'] = {\n        'init': function(element, valueAccessor) {\n            // Support anonymous templates\n            var bindingValue = ko.utils.unwrapObservable(valueAccessor());\n            if (typeof bindingValue == \"string\" || bindingValue['name']) {\n                // It's a named template - clear the element\n                ko.virtualElements.emptyNode(element);\n            } else if ('nodes' in bindingValue) {\n                // We've been given an array of DOM nodes. Save them as the template source.\n                // There is no known use case for the node array being an observable array (if the output\n                // varies, put that behavior *into* your template - that's what templates are for), and\n                // the implementation would be a mess, so assert that it's not observable.\n                var nodes = bindingValue['nodes'] || [];\n                if (ko.isObservable(nodes)) {\n                    throw new Error('The \"nodes\" option must be a plain, non-observable array.');\n                }\n                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            } else {\n                // It's an anonymous template - store the element contents, then clear the element\n                var templateNodes = ko.virtualElements.childNodes(element),\n                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent\n                new ko.templateSources.anonymousTemplate(element)['nodes'](container);\n            }\n            return { 'controlsDescendantBindings': true };\n        },\n        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {\n            var value = valueAccessor(),\n                options = ko.utils.unwrapObservable(value),\n                shouldDisplay = true,\n                templateComputed = null,\n                templateName;\n\n            if (typeof options == \"string\") {\n                templateName = value;\n                options = {};\n            } else {\n                templateName = options['name'];\n\n                // Support \"if\"/\"ifnot\" conditions\n                if ('if' in options)\n                    shouldDisplay = ko.utils.unwrapObservable(options['if']);\n                if (shouldDisplay && 'ifnot' in options)\n                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);\n            }\n\n            if ('foreach' in options) {\n                // Render once for each data point (treating data set as empty if shouldDisplay==false)\n                var dataArray = (shouldDisplay && options['foreach']) || [];\n                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);\n            } else if (!shouldDisplay) {\n                ko.virtualElements.emptyNode(element);\n            } else {\n                // Render once for this single data point (or use the viewModel if no data was provided)\n                var innerBindingContext = ('data' in options) ?\n                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it\n                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context\n                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);\n            }\n\n            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)\n            disposeOldComputedAndStoreNewOne(element, templateComputed);\n        }\n    };\n\n    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.\n    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {\n        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);\n\n        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])\n            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)\n\n        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, \"name\"))\n            return null; // Named templates can be rewritten, so return \"no error\"\n        return \"This template engine does not support anonymous templates nested within its templates\";\n    };\n\n    ko.virtualElements.allowedBindings['template'] = true;\n})();\n\nko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);\nko.exportSymbol('renderTemplate', ko.renderTemplate);\n// Go through the items that have been added and deleted and try to find matches between them.\nko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {\n    if (left.length && right.length) {\n        var failedCompares, l, r, leftItem, rightItem;\n        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {\n            for (r = 0; rightItem = right[r]; ++r) {\n                if (leftItem['value'] === rightItem['value']) {\n                    leftItem['moved'] = rightItem['index'];\n                    rightItem['moved'] = leftItem['index'];\n                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list\n                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures\n                    break;\n                }\n            }\n            failedCompares += r;\n        }\n    }\n};\n\nko.utils.compareArrays = (function () {\n    var statusNotInOld = 'added', statusNotInNew = 'deleted';\n\n    // Simple calculation based on Levenshtein distance.\n    function compareArrays(oldArray, newArray, options) {\n        // For backward compatibility, if the third arg is actually a bool, interpret\n        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.\n        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});\n        oldArray = oldArray || [];\n        newArray = newArray || [];\n\n        if (oldArray.length < newArray.length)\n            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);\n        else\n            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);\n    }\n\n    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {\n        var myMin = Math.min,\n            myMax = Math.max,\n            editDistanceMatrix = [],\n            smlIndex, smlIndexMax = smlArray.length,\n            bigIndex, bigIndexMax = bigArray.length,\n            compareRange = (bigIndexMax - smlIndexMax) || 1,\n            maxDistance = smlIndexMax + bigIndexMax + 1,\n            thisRow, lastRow,\n            bigIndexMaxForRow, bigIndexMinForRow;\n\n        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {\n            lastRow = thisRow;\n            editDistanceMatrix.push(thisRow = []);\n            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);\n            bigIndexMinForRow = myMax(0, smlIndex - 1);\n            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {\n                if (!bigIndex)\n                    thisRow[bigIndex] = smlIndex + 1;\n                else if (!smlIndex)  // Top row - transform empty array into new array via additions\n                    thisRow[bigIndex] = bigIndex + 1;\n                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])\n                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)\n                else {\n                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)\n                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)\n                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;\n                }\n            }\n        }\n\n        var editScript = [], meMinusOne, notInSml = [], notInBig = [];\n        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {\n            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;\n            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {\n                notInSml.push(editScript[editScript.length] = {     // added\n                    'status': statusNotInSml,\n                    'value': bigArray[--bigIndex],\n                    'index': bigIndex });\n            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {\n                notInBig.push(editScript[editScript.length] = {     // deleted\n                    'status': statusNotInBig,\n                    'value': smlArray[--smlIndex],\n                    'index': smlIndex });\n            } else {\n                --bigIndex;\n                --smlIndex;\n                if (!options['sparse']) {\n                    editScript.push({\n                        'status': \"retained\",\n                        'value': bigArray[bigIndex] });\n                }\n            }\n        }\n\n        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of\n        // smlIndexMax keeps the time complexity of this algorithm linear.\n        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);\n\n        return editScript.reverse();\n    }\n\n    return compareArrays;\n})();\n\nko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);\n(function () {\n    // Objective:\n    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,\n    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node\n    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node\n    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we\n    //   previously mapped - retain those nodes, and just insert/delete other ones\n\n    // \"callbackAfterAddingNodes\" will be invoked after any \"mapping\"-generated nodes are inserted into the container node\n    // You can use this, for example, to activate bindings on those nodes.\n\n    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {\n        // Map this array value inside a dependentObservable so we re-map when any dependency changes\n        var mappedNodes = [];\n        var dependentObservable = ko.dependentObservable(function() {\n            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];\n\n            // On subsequent evaluations, just replace the previously-inserted DOM nodes\n            if (mappedNodes.length > 0) {\n                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);\n                if (callbackAfterAddingNodes)\n                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);\n            }\n\n            // Replace the contents of the mappedNodes array, thereby updating the record\n            // of which nodes would be deleted if valueToMap was itself later removed\n            mappedNodes.length = 0;\n            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);\n        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });\n        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };\n    }\n\n    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),\n        deletedItemDummyValue = ko.utils.domData.nextKey();\n\n    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {\n        // Compare the provided array against the previous one\n        array = array || [];\n        options = options || {};\n        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;\n        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];\n        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });\n        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);\n\n        // Build the new mapping result\n        var newMappingResult = [];\n        var lastMappingResultIndex = 0;\n        var newMappingResultIndex = 0;\n\n        var nodesToDelete = [];\n        var itemsToProcess = [];\n        var itemsForBeforeRemoveCallbacks = [];\n        var itemsForMoveCallbacks = [];\n        var itemsForAfterAddCallbacks = [];\n        var mapData;\n\n        function itemMovedOrRetained(editScriptIndex, oldPosition) {\n            mapData = lastMappingResult[oldPosition];\n            if (newMappingResultIndex !== oldPosition)\n                itemsForMoveCallbacks[editScriptIndex] = mapData;\n            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray\n            mapData.indexObservable(newMappingResultIndex++);\n            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);\n            newMappingResult.push(mapData);\n            itemsToProcess.push(mapData);\n        }\n\n        function callCallback(callback, items) {\n            if (callback) {\n                for (var i = 0, n = items.length; i < n; i++) {\n                    if (items[i]) {\n                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {\n                            callback(node, i, items[i].arrayEntry);\n                        });\n                    }\n                }\n            }\n        }\n\n        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {\n            movedIndex = editScriptItem['moved'];\n            switch (editScriptItem['status']) {\n                case \"deleted\":\n                    if (movedIndex === undefined) {\n                        mapData = lastMappingResult[lastMappingResultIndex];\n\n                        // Stop tracking changes to the mapping for these nodes\n                        if (mapData.dependentObservable) {\n                            mapData.dependentObservable.dispose();\n                            mapData.dependentObservable = undefined;\n                        }\n\n                        // Queue these nodes for later removal\n                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {\n                            if (options['beforeRemove']) {\n                                newMappingResult.push(mapData);\n                                itemsToProcess.push(mapData);\n                                if (mapData.arrayEntry === deletedItemDummyValue) {\n                                    mapData = null;\n                                } else {\n                                    itemsForBeforeRemoveCallbacks[i] = mapData;\n                                }\n                            }\n                            if (mapData) {\n                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);\n                            }\n                        }\n                    }\n                    lastMappingResultIndex++;\n                    break;\n\n                case \"retained\":\n                    itemMovedOrRetained(i, lastMappingResultIndex++);\n                    break;\n\n                case \"added\":\n                    if (movedIndex !== undefined) {\n                        itemMovedOrRetained(i, movedIndex);\n                    } else {\n                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };\n                        newMappingResult.push(mapData);\n                        itemsToProcess.push(mapData);\n                        if (!isFirstExecution)\n                            itemsForAfterAddCallbacks[i] = mapData;\n                    }\n                    break;\n            }\n        }\n\n        // Store a copy of the array items we just considered so we can difference it next time\n        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);\n\n        // Call beforeMove first before any changes have been made to the DOM\n        callCallback(options['beforeMove'], itemsForMoveCallbacks);\n\n        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)\n        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);\n\n        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)\n        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {\n            // Get nodes for newly added items\n            if (!mapData.mappedNodes)\n                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));\n\n            // Put nodes in the right place if they aren't there already\n            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {\n                if (node !== nextNode)\n                    ko.virtualElements.insertAfter(domNode, node, lastNode);\n            }\n\n            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)\n            if (!mapData.initialized && callbackAfterAddingNodes) {\n                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);\n                mapData.initialized = true;\n            }\n        }\n\n        // If there's a beforeRemove callback, call it after reordering.\n        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using\n        // some sort of animation, which is why we first reorder the nodes that will be removed. If the\n        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.\n        // Perhaps we'll make that change in the future if this scenario becomes more common.\n        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);\n\n        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item\n        // as already \"removed\" so we won't call beforeRemove for it again, and it ensures that the item won't match up\n        // with an actual item in the array and appear as \"retained\" or \"moved\".\n        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {\n            if (itemsForBeforeRemoveCallbacks[i]) {\n                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;\n            }\n        }\n\n        // Finally call afterMove and afterAdd callbacks\n        callCallback(options['afterMove'], itemsForMoveCallbacks);\n        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);\n    }\n})();\n\nko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);\nko.nativeTemplateEngine = function () {\n    this['allowTemplateRewriting'] = false;\n}\n\nko.nativeTemplateEngine.prototype = new ko.templateEngine();\nko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;\nko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {\n    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly\n        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,\n        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;\n\n    if (templateNodes) {\n        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);\n    } else {\n        var templateText = templateSource['text']();\n        return ko.utils.parseHtmlFragment(templateText, templateDocument);\n    }\n};\n\nko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();\nko.setTemplateEngine(ko.nativeTemplateEngine.instance);\n\nko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);\n(function() {\n    ko.jqueryTmplTemplateEngine = function () {\n        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl\n        // doesn't expose a version number, so we have to infer it.\n        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,\n        // which KO internally refers to as version \"2\", so older versions are no longer detected.\n        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {\n            if (!jQueryInstance || !(jQueryInstance['tmpl']))\n                return 0;\n            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.\n            try {\n                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {\n                    // Since 1.0.0pre, custom tags should append markup to an array called \"__\"\n                    return 2; // Final version of jquery.tmpl\n                }\n            } catch(ex) { /* Apparently not the version we were looking for */ }\n\n            return 1; // Any older version that we don't support\n        })();\n\n        function ensureHasReferencedJQueryTemplates() {\n            if (jQueryTmplVersion < 2)\n                throw new Error(\"Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.\");\n        }\n\n        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {\n            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);\n        }\n\n        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {\n            templateDocument = templateDocument || document;\n            options = options || {};\n            ensureHasReferencedJQueryTemplates();\n\n            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)\n            var precompiled = templateSource['data']('precompiled');\n            if (!precompiled) {\n                var templateText = templateSource['text']() || \"\";\n                // Wrap in \"with($whatever.koBindingContext) { ... }\"\n                templateText = \"{{ko_with $item.koBindingContext}}\" + templateText + \"{{/ko_with}}\";\n\n                precompiled = jQueryInstance['template'](null, templateText);\n                templateSource['data']('precompiled', precompiled);\n            }\n\n            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays\n            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);\n\n            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);\n            resultNodes['appendTo'](templateDocument.createElement(\"div\")); // Using \"appendTo\" forces jQuery/jQuery.tmpl to perform necessary cleanup work\n\n            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders\n            return resultNodes;\n        };\n\n        this['createJavaScriptEvaluatorBlock'] = function(script) {\n            return \"{{ko_code ((function() { return \" + script + \" })()) }}\";\n        };\n\n        this['addTemplate'] = function(templateName, templateMarkup) {\n            document.write(\"<script type='text/html' id='\" + templateName + \"'>\" + templateMarkup + \"<\" + \"/script>\");\n        };\n\n        if (jQueryTmplVersion > 0) {\n            jQueryInstance['tmpl']['tag']['ko_code'] = {\n                open: \"__.push($1 || '');\"\n            };\n            jQueryInstance['tmpl']['tag']['ko_with'] = {\n                open: \"with($1) {\",\n                close: \"} \"\n            };\n        }\n    };\n\n    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();\n    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;\n\n    // Use this one by default *only if jquery.tmpl is referenced*\n    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();\n    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)\n        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);\n\n    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);\n})();\n}));\n}());\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/knockout/build/output/knockout-latest.debug.js\n// module id = 5\n// module chunks = 2","// Returns the widest zoom level that can be displayed without showing the grey div background\r\n// above and below the map. Just makes things look nicer than using 'fitBounds(bounds)', which\r\n// can often show the grey areas.\r\nfunction calculateInitZoomLevel() {\r\n  const mapHeight = document.getElementsByClassName('map')[0].clientHeight;\r\n  if (mapHeight <= 295) {\r\n    return 0;\r\n  } else if (mapHeight <= 534) {\r\n    return 1;\r\n  } else if (mapHeight <= 1122) {\r\n    return 2;\r\n  } else if (mapHeight <= 2120) {\r\n    return 3;\r\n  }\r\n  return 4;\r\n}\r\n\r\nexport default calculateInitZoomLevel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/calculateInitZoomLevel.js","function calculateResponsiveLatLng() {\r\n  const windowWidth = document.body.clientWidth;\r\n  const latLng = {};\r\n\r\n  if (windowWidth > 1366) {\r\n    latLng.lat = -2;\r\n    latLng.lng = 12;\r\n  } else if (windowWidth > 1226) {\r\n    latLng.lat = 17;\r\n    latLng.lng = 3;\r\n  } else if (windowWidth > 1020) {\r\n    latLng.lat = 20;\r\n    latLng.lng = 2;\r\n  } else if (windowWidth > 840) {\r\n    latLng.lat = 24;\r\n    latLng.lng = 9;\r\n  } else if (windowWidth > 775) {\r\n    latLng.lat = 27;\r\n    latLng.lng = 7;\r\n  } else if (windowWidth > 751) {\r\n    latLng.lat = 21;\r\n    latLng.lng = 7;\r\n  } else if (windowWidth > 660) {\r\n    latLng.lat = 9;\r\n    latLng.lng = 10;\r\n  } else if (windowWidth > 616) {\r\n    latLng.lat = 11;\r\n    latLng.lng = 0;\r\n  } else if (windowWidth > 563) {\r\n    latLng.lat = 9;\r\n    latLng.lng = 7;\r\n  } else if (windowWidth > 413) {\r\n    latLng.lat = 14;\r\n    latLng.lng = 4;\r\n  } else if (windowWidth > 374) {\r\n    latLng.lat = 9;\r\n    latLng.lng = 6;\r\n  } else {\r\n    latLng.lat = 14;\r\n    latLng.lng = 0;\r\n  }\r\n\r\n  return latLng;\r\n} // End of calculateResponsiveLatLng().\r\n\r\nexport default calculateResponsiveLatLng;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/calculateResponsiveLatLng.js","module.exports = \"data:image/gif;base64,R0lGODlhgACAAIABAFGvvP///yH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEFEQkNEMUM1Q0NEMTFFNzkyRkZGQTZDQzIwNkJBQTIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEFEQkNEMUQ1Q0NEMTFFNzkyRkZGQTZDQzIwNkJBQTIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0QURCQ0QxQTVDQ0QxMUU3OTJGRkZBNkNDMjA2QkFBMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0QURCQ0QxQjVDQ0QxMUU3OTJGRkZBNkNDMjA2QkFBMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769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\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/misc/loading.gif\n// module id = 8\n// module chunks = 2","module.exports = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/misc/tinygif.gif\n// module id = 9\n// module chunks = 2","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 10\n// module chunks = 2","import generateMap from './modules/generateMap';\r\nimport '../css/styles.css';\r\nimport initLoadingScreen from './modules/initLoadingScreen';\r\nimport * as audio from './modules/audio';\r\n\r\n(function appInit() {\r\n  // Enables Webpack's hot module replacement for index.html if in development mode.\r\n  if (DEVELOPMENT) {\r\n    require('../index.html'); // eslint-disable-line global-require\r\n  }\r\n\r\n  // This event handler solves an issue with the menu animation firing on initial page load.\r\n  // See here for more details... https://css-tricks.com/transitions-only-after-page-load\r\n  window.onanimationstart = () => {\r\n    const body = document.getElementsByClassName('disable-init-animations')[0];\r\n    body.classList.remove('disable-init-animations');\r\n    window.onanimationstart = null;\r\n  };\r\n\r\n  generateMap();\r\n\r\n  initLoadingScreen().then(() => {\r\n    // Fades in the map area after all neccessary files are loaded for initial page render.\r\n    const initMapContainerLoadingScreen = document.getElementsByClassName('init-map-container-loading-screen')[0];\r\n    initMapContainerLoadingScreen.classList.add('init-map-container-loading-screen--fade');\r\n\r\n    // Now that the map has faded into view we'll animate the clouds.\r\n    // I'm using the ES6 spread operator here to spread the HTMLCollection object into an array.\r\n    const cloudArray = [...document.getElementsByClassName('clouds')];\r\n    cloudArray.forEach((cloud, index) => {\r\n      cloud.classList.add(`clouds__cloud-${index + 1}--animate`);\r\n    });\r\n\r\n    audio.ocean.start(0);\r\n    setTimeout(map.dropMarkers, 1100);\r\n  });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.js","import ko from 'knockout';\r\nimport islands from './islands';\r\nimport ViewModel from './ViewModel';\r\nimport calculateInitZoomLevel from './calculateInitZoomLevel';\r\nimport calculateResponsiveLatLng from './calculateResponsiveLatLng';\r\nimport getNumberToDivideTextboxHeightBy from './getNumberToDivideTextboxHeightBy';\r\nimport makeMarker from './makeMarker';\r\nimport setMinAndMaxZoomLevels from './setMinAndMaxZoomLevels';\r\nimport getOverlayTileURL from './getOverlayTileURL';\r\nimport mapStyles from './mapStyles';\r\n\r\nfunction generateMap() {\r\n  // Google Maps API key.\r\n  const key = 'AIzaSyDvNMjcb6i4p55qJpL3vzSiCp9KRwW4QQ0';\r\n\r\n  // 'google-maps-api' npm package by 'Jam3'.\r\n  // For more details, visit https://github.com/Jam3/google-maps-api\r\n  const googleMapsAPIModule = require('google-maps-api')(key); // eslint-disable-line global-require\r\n\r\n  googleMapsAPIModule().then(mapObject => {\r\n    const { lat, lng } = calculateResponsiveLatLng();\r\n    const map = new mapObject.Map(document.getElementsByClassName('map')[0], {\r\n      center: {\r\n        lat,\r\n        lng\r\n      },\r\n      disableDefaultUI: true,\r\n      styles: mapStyles,\r\n      scrollwheel: window.innerWidth <= 768\r\n    });\r\n\r\n    // Changes the default grey map background. While page loads we'll set the background to\r\n    // white, so that the map seems to fade in from white nicely. Then after a 100ms timeout we\r\n    // change the background to a top-to-bottom blue/white gradient, so that the ocean blends\r\n    // nicely with the blue at the top of the map, and the Antarctic blends nicely with the white\r\n    // at the bottom.\r\n    map.background = document.getElementsByClassName('map')[0].children[0];\r\n    map.background.style.background = 'rgb(255, 255, 255)';\r\n    setTimeout(() => {\r\n      map.background.style.background =\r\n        'linear-gradient(rgb(81, 175, 188) 41%, rgb(233, 240, 244) 59%)';\r\n    }, 100);\r\n\r\n    global.map = map;\r\n\r\n    // Helpful later for when we want to filter the markers.\r\n    map.markers = [];\r\n\r\n    // This tracks if the map is displaying its initial global view or not, i.e. is the viewport\r\n    // showing all the islands or has a user selected an island from the menu and thus zoomed in\r\n    // on that island. This boolean will determine if the viewport pans to a marker when it is\r\n    // selected. In global view the viewport will pan, but when zoomed in on an island the\r\n    // viewport won't pan to the marker when clicked.\r\n    map.globalView = true;\r\n\r\n    const infoWindow = new mapObject.InfoWindow();\r\n\r\n    map.dropMarkers = () => {\r\n      // 'index * 300' is passed into the makeMarker function so that it receives a longer timeout\r\n      // value each time it is called. This results in a 'falling rain' effect when the markers\r\n      // drop into view on page load.\r\n      islands.forEach((item, index) =>\r\n        makeMarker(index, index * 300, map, mapObject, infoWindow)\r\n      );\r\n    };\r\n\r\n    map.bounceMarker = (island, iteration = 1) => {\r\n      for (let i = 0; i < map.markers.length; i++) {\r\n        if (island.name === map.markers[i].title) {\r\n          map.markers[i].setAnimation(null);\r\n          map.markers[i].setAnimation(mapObject.Animation.BOUNCE);\r\n          stopBounce(i);\r\n        }\r\n      }\r\n\r\n      function stopBounce(index) {\r\n        setTimeout(() => {\r\n          map.markers[index].setAnimation(null);\r\n        }, 710 * iteration);\r\n      }\r\n    };\r\n\r\n    map.getIslandBounds = island => {\r\n      const [southWestCoordinates, northEastCoordinates] = island.latLngBounds;\r\n      const islandBounds = new mapObject.LatLngBounds(southWestCoordinates, northEastCoordinates);\r\n      return islandBounds;\r\n    };\r\n\r\n    map.showOverlayTiles = (islandName, islandBounds, currentZoomLevel, minZoomLevel,\r\n      maxZoomLevel) => {\r\n      const overlayMinZoom = minZoomLevel;\r\n      const overlayMaxZoom = maxZoomLevel;\r\n      const tileURL = getOverlayTileURL(map, mapObject, islandName, islandBounds,\r\n        currentZoomLevel, overlayMinZoom, overlayMaxZoom);\r\n      map.overlayMapTypes.insertAt(0, tileURL);\r\n    };\r\n\r\n    map.goToSelectedIsland = island => {\r\n      // Empties cache of any previously loaded overlays. This ensures overlay fonts are correctly\r\n      // rendered if the previous island is ever selected again - the tyopgraphy won't be doubled\r\n      // up and thickened each time the overlay tiles are loaded.\r\n      map.overlayMapTypes.removeAt(0);\r\n\r\n      mapObject.event.trigger(map, 'resize');\r\n\r\n      const islandBounds = map.getIslandBounds(island);\r\n      map.fitBounds(islandBounds);\r\n\r\n      const islandName = island.name;\r\n      const currentZoomLevel = map.getZoom();\r\n      const [minZoomLevel, maxZoomLevel] = setMinAndMaxZoomLevels(islandName);\r\n\r\n      // Caps the maximum zoom level so that each island is seen at its most appropriate zoom\r\n      // level without overflowing the browser window.\r\n      if (currentZoomLevel > maxZoomLevel) {\r\n        map.setZoom(maxZoomLevel);\r\n      }\r\n\r\n      // This conditional adjusts the 'y' position of the map to account for the\r\n      // <section class='textbox'> being absolutely positioned over the map in desktop view.\r\n      if (document.body.clientWidth >= 1366) {\r\n        const textboxHeight = document.getElementsByClassName('textbox')[0].clientHeight;\r\n        const numberToDivideTextboxHeightBy = getNumberToDivideTextboxHeightBy(islandName);\r\n        const textboxCompensation = textboxHeight / numberToDivideTextboxHeightBy;\r\n        map.panBy(0, textboxCompensation);\r\n      }\r\n\r\n      // Finally, we'll get and set the appropriate overlay tiles for the selected island.\r\n      map.showOverlayTiles(islandName, islandBounds, currentZoomLevel, minZoomLevel,\r\n        maxZoomLevel);\r\n    }; // End of goToSelectedIsland().\r\n\r\n    return map;\r\n  }).then(map => {\r\n    ko.applyBindings(new ViewModel(map));\r\n\r\n    const zoomLevel = calculateInitZoomLevel();\r\n    map.setZoom(zoomLevel);\r\n\r\n    // Updates the height of '.textbox-underlayer' with the value obtained by querying the height\r\n    // of '.textbox' after it's been loaded with new data. By blending the opacity of the\r\n    // background colours of each div we get a very subtle but pleasing effect.\r\n    setTimeout(() => {\r\n      const textbox = document.getElementsByClassName('textbox')[0];\r\n      const textboxUnderlayer = document.getElementsByClassName('textbox-underlayer')[0];\r\n      textboxUnderlayer.style.height = `${textbox.clientHeight}px`;\r\n    }, 50);\r\n  }).catch(err => {\r\n    console.warn(err);\r\n    alert(\r\n      'Google Maps was unable to load. Please check your network connection or try again later.'\r\n    );\r\n  }); // End of googleMapsAPIModule().\r\n} // End of googleMapView().\r\n\r\nexport default generateMap;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/generateMap.js","import ko from 'knockout';\r\nimport islands from './islands';\r\nimport IslandConstructor from './IslandConstructor';\r\nimport calculateInitZoomLevel from './calculateInitZoomLevel';\r\nimport calculateResponsiveLatLng from './calculateResponsiveLatLng';\r\nimport homeScreenLinkActive from '../../img/misc/home-screen-link-active.png';\r\nimport homeScreenLinkInactive from '../../img/misc/home-screen-link-inactive.png';\r\nimport * as audio from './audio';\r\n\r\nfunction ViewModel(map) {\r\n  // An array containing which islands should be shown in the menu.\r\n  // Contents depend on whether a filter is currently selected or not.\r\n  this.islandsToList = ko.observableArray();\r\n\r\n  this.currentlySelectedIsland = ko.observable(null);\r\n\r\n  // Updates the height of '.textbox-underlayer' with the value obtained by querying the height of\r\n  // '.textbox' after it's been loaded with new data. By blending the opacity of the background\r\n  // colours of each div we get a very subtle but pleasing glazed glass-like effect when the app is\r\n  // viewed on desktop. Effect is disabled on mobile/tablet as the map doesn't pass beneath the\r\n  // textbox when viewed on such devices.\r\n  this.currentlySelectedIsland.subscribe(() => {\r\n    setTimeout(() => {\r\n      const textbox = document.getElementsByClassName('textbox')[0];\r\n      const textboxUnderlayer = document.getElementsByClassName('textbox-underlayer')[0];\r\n      textboxUnderlayer.style.height = `${textbox.clientHeight}px`;\r\n    }, 0);\r\n  });\r\n\r\n  this.currentlySelectedOcean = ko.observable(null);\r\n\r\n  // When true the 'filter' background colour flashes yellow.\r\n  this.filterChanged = ko.observable(false);\r\n\r\n  // See above.\r\n  this.currentlySelectedOcean.subscribe(() => {\r\n    this.filterChanged(true);\r\n    map.globalView ? audio.filterChange.volume(0.3) : audio.filterChange.volume(0.8);\r\n    audio.filterChange.play();\r\n    setTimeout(() => {\r\n      this.filterChanged(false);\r\n    }, 170);\r\n  });\r\n\r\n  this.playMouseClick = () => {\r\n    map.globalView ? audio.mouseClick.volume(0.25) : audio.mouseClick.volume(0.35);\r\n    audio.mouseClick.play();\r\n  };\r\n\r\n  // When true the 'menu--visible' class is applied to the menu, causing it to animate into view.\r\n  this.menuVisible = ko.observable(false);\r\n\r\n  this.numberOfTimesUserHasOpenedMenu = ko.observable(0);\r\n\r\n  this.userHasSeenMenuButton = ko.observable(false);\r\n\r\n  // This observable makes sure the menu border colours only change when\r\n  // the menu is toggled and not also when a filter is selected/unselected.\r\n  this.menuHasBeenToggled = ko.observable(false);\r\n\r\n  // Triggered each time the arrow button is clicked. Clicking outside the menu also closes the menu\r\n  // due to '.fade-map-container' also having the below binding. CSS 'pointer-events' are\r\n  // appropriately used on '.fade-map-container' to enable this behaviour without resorting to\r\n  // jQuery.\r\n  this.toggleMenuVisibility = () => {\r\n    this.menuHasBeenToggled(true);\r\n\r\n    this.playMouseClick();\r\n\r\n    if (!this.menuVisible()) {\r\n      this.menuVisible(true);\r\n      map.globalView ? audio.slideRight.volume(0.55) : audio.slideRight.volume(1.0);\r\n      audio.slideRight.play();\r\n      this.numberOfTimesUserHasOpenedMenu(this.numberOfTimesUserHasOpenedMenu() + 1);\r\n      if (this.numberOfTimesUserHasOpenedMenu() === 1) {\r\n        this.userHasSeenMenuButton(true);\r\n      }\r\n    } else {\r\n      map.globalView ? audio.slideLeft.volume(0.55) : audio.slideLeft.volume(1.0);\r\n      this.menuVisible(false);\r\n      setTimeout(() => {\r\n        audio.slideLeft.play();\r\n      }, 40);\r\n    }\r\n  };\r\n\r\n  // This value of this observable determines what background color the menu arrow button has.\r\n  // The colour varies depending on whether the menu is currently visible or not, and if the current\r\n  // event is a mouseover or mouseout event. See the menu arrow button's data binding in the HTML\r\n  // for more information.\r\n  this.arrowButtonEventType = ko.observable();\r\n\r\n  this.trackArrowButtonEventType = (data, event) => {\r\n    this.arrowButtonEventType(event.type);\r\n    if (event.type === 'mouseenter') {\r\n      map.globalView\r\n        ? audio.mouseEnterArrowButtonOrMarkerOrHomeLink.volume(0.35)\r\n        : audio.mouseEnterArrowButtonOrMarkerOrHomeLink.volume(0.7);\r\n      audio.mouseEnterArrowButtonOrMarkerOrHomeLink.play();\r\n    }\r\n  };\r\n\r\n  // The colour scheme for the page is pretty, but because of it I think some first-time users\r\n  // might not notice the menu button on the left of the screen. So if 15 seconds after page load\r\n  // the user still hasn't clicked on the menu button then we'll flash its background color 5\r\n  // times to get their attention.\r\n  window.onload = () => {\r\n    setTimeout(() => {\r\n      if (this.userHasSeenMenuButton() === false) {\r\n        this.timeToGetUsersAttention(true);\r\n      }\r\n    }, 15000);\r\n  };\r\n\r\n  this.timeToGetUsersAttention = ko.observable(false);\r\n\r\n  this.flash = ko.observable(false);\r\n\r\n  this.numberOfFlashes = ko.observable(0);\r\n\r\n  this.timeToGetUsersAttention.subscribe(() => {\r\n    const flashArrowButton = setInterval(() => {\r\n      this.flash(true);\r\n      setTimeout(() => {\r\n        this.flash(false);\r\n        this.numberOfFlashes(this.numberOfFlashes() + 1);\r\n        if (this.numberOfFlashes() === 5) {\r\n          clearInterval(flashArrowButton);\r\n        }\r\n      }, 255);\r\n    }, 510);\r\n  });\r\n\r\n  this.cloudImgSrcPaths = ko.observableArray();\r\n\r\n  // Using Webpack's code splitting feature, we'll only download the cloud .png files if the user is\r\n  // viewing the site on a desktop, in which case they'll likely have a faster internet connection.\r\n  // By not downloading the cloud .png files on mobile we'll improve the page load speed.\r\n  if (window.innerWidth >= 1366) {\r\n    System.import('./clouds').then(cloudsArray => {\r\n      cloudsArray.default.forEach(cloudImgSrcPath => {\r\n        this.cloudImgSrcPaths.push(cloudImgSrcPath);\r\n      });\r\n    });\r\n  }\r\n\r\n  this.showAllIslandsOnLoad = (() => {\r\n    islands.forEach(island => this.islandsToList.push(new IslandConstructor(island)));\r\n\r\n    // Caches all the islands on initial page load. This is useful later for when a filter is\r\n    // unselected and all island names need to be displayed again in the menu. We can just pass this\r\n    // 'islandsCached' array to 'islandsToList' without having to loop through the Model again.\r\n    this.islandsCached = this.islandsToList();\r\n  })();\r\n\r\n  // Loops through the model to find out how many unique oceans there are. With this new returned\r\n  // array we can then create a 'foreach' binding in our View to construct a filter icon for each\r\n  // unique ocean.\r\n  this.uniqueOceans = islands\r\n    .map(island => island.ocean)\r\n    .filter((ocean, index, array) => array.indexOf(ocean) === index);\r\n\r\n  // Filters the island list and markers depending on which ocean is selected.\r\n  this.selectOcean = selectedOcean => {\r\n    this.menuHasBeenToggled(false);\r\n    if (this.currentlySelectedOcean() === selectedOcean) {\r\n      this.currentlySelectedOcean(null);\r\n      this.islandsToList(this.islandsCached);\r\n      map.markers.forEach(marker => marker.setMap(map));\r\n    } else {\r\n      const filteredIslands = this.islandsCached.filter(island => island.ocean === selectedOcean);\r\n      this.islandsToList(filteredIslands);\r\n      this.currentlySelectedOcean(selectedOcean);\r\n      map.markers.forEach(marker => {\r\n        marker.ocean === selectedOcean ? marker.setMap(map) : marker.setMap(null);\r\n      });\r\n    }\r\n  };\r\n\r\n  this.seagullSFXArePlaying = false;\r\n\r\n  this.whiteCloudFlashWhenIslandSelected = ko.observable(false);\r\n\r\n  this.islandSelectedFromMenu = selectedIsland => {\r\n    if (selectedIsland !== this.currentlySelectedIsland()) {\r\n      // Sets the map background color to the same colour as the ocean, so that each selected island\r\n      // from the menu fades into view nicely, instead of a flash of the original blue/white\r\n      // gradient background being briefly shown while each island loads.\r\n      if (map.background.style.background !== 'rgb(81, 175, 188)') {\r\n        map.background.style.background = 'rgb(81, 175, 188)';\r\n      }\r\n\r\n      this.toggleMenuVisibility();\r\n\r\n      // Now we're gonna increase the volume of the ocean and lift the frequency of the lowpass\r\n      // filter from 2khz to 22khz - the limit of human hearing - so that the ocean sounds a lot\r\n      // closer when we zoom down to the selected island. On a related note, here's Father Ted\r\n      // helping us better understand physics... https://www.youtube.com/watch?v=OXypyrutq_M\r\n      if (map.globalView) {\r\n        audio.gainNode.gain.exponentialRampToValueAtTime(1, audio.audioCtx.currentTime + 1);\r\n        audio.biquadFilter.frequency.exponentialRampToValueAtTime(\r\n          22000,\r\n          audio.audioCtx.currentTime + 1\r\n        );\r\n      }\r\n\r\n      if (!this.seagullSFXArePlaying) {\r\n        audio.playOrStopSeagullSFX();\r\n        this.seagullSFXArePlaying = true;\r\n      }\r\n\r\n      // We will now zoom in on an island, so we're no longer in 'global view'. This boolean will\r\n      // determine if the viewport pans to a marker when it is selected. In global view the viewport\r\n      // will pan, but when zoomed in on an island the viewport will not pan to the marker when\r\n      // clicked.\r\n      map.globalView = false;\r\n\r\n      setTimeout(() => {\r\n        this.currentlySelectedIsland(selectedIsland);\r\n        map.goToSelectedIsland(this.currentlySelectedIsland());\r\n        setTimeout(() => {\r\n          map.bounceMarker(selectedIsland, 3);\r\n        }, 480);\r\n      }, 100);\r\n\r\n      // Flashes a 100% width/height white div briefly while map loads the selected island. It's\r\n      // meant to give a 'passing through clouds' type of effect! :)\r\n      this.whiteCloudFlashWhenIslandSelected(true);\r\n      setTimeout(() => this.whiteCloudFlashWhenIslandSelected(false), 700);\r\n    } else {\r\n      this.toggleMenuVisibility();\r\n    }\r\n\r\n    this.activateHomeScreenLinkWhenNotInGlobalView(true);\r\n  };\r\n\r\n  // This binding makes the appropriate marker bounce once when an island name is hovered over in\r\n  // the menu in global view. It also plays the appropriate sound effect.\r\n  this.islandNameHover = island => {\r\n    if (map.globalView) {\r\n      audio.mouseEnterIslandNameOrHomeLink.volume(0.3);\r\n      map.bounceMarker(island);\r\n    } else {\r\n      audio.mouseEnterIslandNameOrHomeLink.volume(0.7);\r\n    }\r\n    audio.mouseEnterIslandNameOrHomeLink.play();\r\n  };\r\n\r\n  // Used to throttle window resize events in the subsequent 'resize' event listener.\r\n  this.currentlyZoomingOrPanning = false;\r\n\r\n  window.addEventListener('resize', () => {\r\n    // This 'map' conditional prevents the rest of the callback from being executed if the map has\r\n    // not finished loading yet on initial page load.\r\n    if (map) {\r\n      // This next conditional prevents the clouds from rendering again if the user loads\r\n      // the application initially in desktop view, then switches to mobile view, and then\r\n      // switches back to desktop view. We don't want the clouds reappearing and animating again\r\n      // in that case. We only want the clouds to be seen after the initial page load.\r\n      if (this.initialHomeScreenLoad() && window.innerWidth <= 1366) {\r\n        this.initialHomeScreenLoad(false);\r\n      }\r\n      if (this.currentlySelectedIsland() !== null) {\r\n        if (!this.currentlyZoomingOrPanning) {\r\n          window.requestAnimationFrame(() => {\r\n            map.goToSelectedIsland(this.currentlySelectedIsland());\r\n            this.currentlyZoomingOrPanning = false;\r\n          });\r\n        }\r\n        this.currentlyZoomingOrPanning = true;\r\n      } else if (!this.currentlyZoomingOrPanning) {\r\n        window.requestAnimationFrame(() => {\r\n          const zoomLevel = calculateInitZoomLevel();\r\n          map.setZoom(zoomLevel);\r\n          const { lat, lng } = calculateResponsiveLatLng();\r\n          map.setCenter({\r\n            lat,\r\n            lng\r\n          });\r\n          this.currentlyZoomingOrPanning = false;\r\n        });\r\n        this.currentlyZoomingOrPanning = true;\r\n      }\r\n    }\r\n    map.setOptions({\r\n      scrollwheel: window.innerWidth <= 768\r\n    });\r\n    this.getWindowWidth();\r\n  }, { passive: true }); // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n\r\n  this.viewedOnDesktop = ko.observable();\r\n\r\n  this.getWindowWidth = () => {\r\n    window.innerWidth >= 1366 ? this.viewedOnDesktop(true) : this.viewedOnDesktop(false);\r\n  };\r\n\r\n  this.getWindowWidth();\r\n\r\n  this.homeLinkEventType = ko.observable();\r\n\r\n  this.trackHomeLinkEventType = (data, event) => {\r\n    this.homeLinkEventType(event.type);\r\n    if (event.type === 'mouseenter' && !map.globalView) {\r\n      audio.mouseEnterArrowButtonOrMarkerOrHomeLink.volume(0.7);\r\n      audio.mouseEnterArrowButtonOrMarkerOrHomeLink.play();\r\n    }\r\n  };\r\n\r\n  // This observable ensures the clouds are only seen the first time the user loads the page, and\r\n  // not again if the user clicks the home screen link in the menu later on.\r\n  this.initialHomeScreenLoad = ko.observable(true);\r\n\r\n  // This observable is 'false' by default for the initial page load and only set to 'true' whenever\r\n  // an island is selected from the menu. When 'true' the image of the world map at the bottom of\r\n  // the world map turns from a black and white image to a color image. Clicking on this image will\r\n  // then take the user back to the home screen and set this observable to 'false' again.\r\n  this.activateHomeScreenLinkWhenNotInGlobalView = ko.observable(false).extend({\r\n    rateLimit: 350\r\n  });\r\n\r\n  this.getHomeScreenLink = () => {\r\n    if (this.activateHomeScreenLinkWhenNotInGlobalView()) {\r\n      return homeScreenLinkActive;\r\n    }\r\n    return homeScreenLinkInactive;\r\n  };\r\n\r\n  this.backToHomeScreen = () => {\r\n    if (!map.globalView) {\r\n      if (this.initialHomeScreenLoad()) {\r\n        this.initialHomeScreenLoad(false);\r\n      }\r\n\r\n      setTimeout(() => {\r\n        map.background.style.background =\r\n          'linear-gradient(rgb(81, 175, 188) 41%, rgb(233, 240, 244) 59%)';\r\n        map.setOptions({\r\n          scrollwheel: window.innerWidth <= 768\r\n        });\r\n      }, 700);\r\n\r\n      audio.mouseClick.volume(0.35);\r\n      audio.mouseClick.play();\r\n      this.menuVisible(false);\r\n      this.whiteCloudFlashWhenIslandSelected(true);\r\n      setTimeout(() => this.whiteCloudFlashWhenIslandSelected(false), 700);\r\n\r\n      setTimeout(() => {\r\n        const { lat, lng } = calculateResponsiveLatLng();\r\n        map.setCenter({\r\n          lat,\r\n          lng\r\n        });\r\n\r\n        map.setZoom(calculateInitZoomLevel());\r\n      }, 350);\r\n\r\n      setTimeout(() => {\r\n        this.currentlySelectedIsland(null);\r\n      }, 100);\r\n\r\n      this.activateHomeScreenLinkWhenNotInGlobalView(false);\r\n\r\n      audio.gainNode.gain.exponentialRampToValueAtTime(0.2, audio.audioCtx.currentTime + 1);\r\n      audio.biquadFilter.frequency.exponentialRampToValueAtTime(\r\n        2500,\r\n        audio.audioCtx.currentTime + 1.25\r\n      );\r\n\r\n      if (this.seagullSFXArePlaying) {\r\n        audio.playOrStopSeagullSFX();\r\n        this.seagullSFXArePlaying = false;\r\n      }\r\n\r\n      map.globalView = true;\r\n    }\r\n  };\r\n} // End of ViewModel().\r\n\r\nexport default ViewModel;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/ViewModel.js","function IslandConstructor(island) {\r\n  this.name = island.name;\r\n  this.ocean = island.ocean;\r\n  this.latLngBounds = island.latLngBounds;\r\n  this.markerPosition = island.markerPosition;\r\n  this.bookExcerpt = island.bookExcerpt;\r\n}\r\n\r\nexport default IslandConstructor;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/IslandConstructor.js","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABCBAMAAABTOW5MAAAAHlBMVEVMaXG3wrrR4NXT4drZ4tkZhZTi5d8fiZcZhZQlkqNtb6GWAAAACHRSTlMACitYmabt+t2aZU8AAAJTSURBVEjHpVdLbt0wDBwFeQCXatoD5CEPWb/XXCAIgq5zhW56DhYokMkN0tt2IdkmKTqxUS1ljfiZISkDw6Ji5yK587SQO8wISeEeiHBZ82b5zC1qhBwLIKtmOVopl4cLymoOo1/l+VivLne362kX9X6V5x/n+jFTpPR8dcivs3FA14xMSwHg9GTukzQQqI/ldNc+KQpEU12Ri2MK4MbEkbHbj0qkBaSWrqHTU7UQJYXUKdVe1h3y5+HsHZN2NEBk3hIGBc0ORYjK5K32HLx4iCIoWXQWhbZ9vkzZ6MyrsdKcsjqiQunEKL3CmhUh1RiZUcXpVzs9TqavAeMl35nB7yOGDwYT7ZKK+58NolsgChL4dvbl406I/YSW5bFGA8RaEEqHaA4R6gGYstR7mCmfzDU91FYpmGwaiIyQqaI790uGl7Iew+ChAtDQXYZu4yCoSUNqV+QYsd3TSmY1x5J3SjUbr+98d8JIIWKNvP11EEkhGjoO32zwmkHSKTDZD41JGNtE0B/Heej9QirHdOhlgyOG6ecw1404Usrc5JQJkUiMlDp3X+FQXwqhClWYD74kekAIGXhc+ButtA5IpiOm5ylkDACbIQOpHqOzwSlqaW02h1iO7QgQCjUfyzafEkuhc1OwLk6rKqFSzRVfcnE6AqVJWVbeJE4B9rmwHoyBiGfXaCVhpnd+DZdVl+ENEAZSJkimuSGy/4Vo/qJaElO3vpHZ77iqmyEdhuvbgZcPX8WK8n3fc5+K68ch+s/e4V/rBkhUSHyeU+ruH5Hdvy4rbSSsfzTjsPzeAMkUAAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/misc/home-screen-link-active.png\n// module id = 15\n// module chunks = 2","module.exports = \"data:image/png;base64,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\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/misc/home-screen-link-inactive.png\n// module id = 16\n// module chunks = 2","/*!\n *  howler.js v2.0.4\n *  howlerjs.com\n *\n *  (c) 2013-2017, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto iOS enabler.\n      self.mobileAutoEnable = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.value = vol;\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.value = muted ? 0 : self._volume;\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'running' : 'running';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Mobile browsers will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _enableMobileAudio: function() {\n      var self = this || Howler;\n\n      // Only run this on mobile devices if audio isn't already eanbled.\n      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);\n      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));\n      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {\n        return;\n      }\n\n      self._mobileEnabled = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function() {\n        // Fix Android can not play in suspend state.\n        Howler._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._mobileEnabled = true;\n          self.mobileAutoEnable = false;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchend', unlock, true);\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchend', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n        self.ctx.suspend().then(function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        });\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio on iOS.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {\n        Howler._enableMobileAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload) {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        var num = 0;\n        for (var i=0; i<self._sounds.length; i++) {\n          if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n            num++;\n            id = self._sounds[i]._id;\n          }\n        }\n\n        if (num === 1) {\n          sprite = null;\n        } else {\n          id = null;\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Makr this sounded as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          setTimeout(function() {\n            self._emit('play', sound._id);\n          }, 0);\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n      // Update the parameters of the sound\n      sound._paused = false;\n      sound._ended = false;\n      sound._sprite = sprite;\n      sound._seek = seek;\n      sound._start = self._sprite[sprite][0] / 1000;\n      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n            }, 0);\n          }\n        };\n\n        var isRunning = (Howler.state === 'running');\n        if (self._state === 'loaded' && isRunning) {\n          playWebAudio();\n        } else {\n          // Wait for the audio to load and then begin playback.\n          var event = !isRunning && self._state === 'loaded' ? 'resume' : 'load';\n          self.once(event, playWebAudio, isRunning ? sound._id : null);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n          node.play();\n\n          // Setup the new end timer.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            self._emit('play', sound._id);\n          }\n        };\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));\n        if (node.readyState === 4 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          var listener = function() {\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n      var diff = Math.abs(from - to);\n      var dir = from > to ? 'out' : 'in';\n      var steps = diff / 0.01;\n      var stepLen = (steps > 0) ? len / steps : len;\n\n      // Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.\n      if (stepLen < 4) {\n        steps = Math.ceil(steps / (4 / stepLen));\n        stepLen = 4;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          var vol = from;\n          sound._interval = setInterval(function(soundId, sound) {\n            // Update the volume amount, but only if the volume should change.\n            if (steps > 0) {\n              vol += (dir === 'in' ? 0.01 : -0.01);\n            }\n\n            // Make sure the volume is in the right bounds.\n            vol = Math.max(0, vol);\n            vol = Math.min(1, vol);\n\n            // Round to within 2 decimal points.\n            vol = Math.round(vol * 100) / 100;\n\n            // Change the volume.\n            if (self._webAudio) {\n              if (typeof id === 'undefined') {\n                self._volume = vol;\n              }\n\n              sound._volume = vol;\n            } else {\n              self.volume(vol, soundId, true);\n            }\n\n            // When the fade is complete, stop it and fire event.\n            if ((to < from && vol <= to) || (to > from && vol >= to)) {\n              clearInterval(sound._interval);\n              sound._interval = null;\n              self.volume(to, soundId);\n              self._emit('fade', soundId);\n            }\n          }.bind(self, ids[i], sound), stepLen);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded') {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            sound._rateSeek = self.seek(id[i]);\n            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.value = rate;\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return self;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (self._state !== 'loaded') {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Restart the playback if the sound was playing.\n          if (playing) {\n            self.play(id, true);\n          }\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node) {\n            sound._node.currentTime = seek;\n          }\n\n          self._emit('seek', id);\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n          if (!checkIE) {\n            sounds[i]._node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n          }\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n\n        // Remove the references in the global Howler object.\n        var index = Howler._howls.indexOf(self);\n        if (index >= 0) {\n          Howler._howls.splice(index, 1);\n        }\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function() {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // don't move onto the next task until this one is done\n        self.once(task.event, function() {\n          self._queue.shift();\n          self._loadQueue();\n        });\n\n        task.action();\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && self._node && !self._node.ended) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        clearTimeout(self._endTimers[id]);\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop;\n      }\n      sound._node.bufferSource.playbackRate.value = sound._rate;\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n\n      if (self._scratchBuffer) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}\n      }\n      node.bufferSource = null;\n\n      return self;\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else {\n        self._node = new Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = 'auto';\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Decode the buffer into an audio source.\n    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      }\n    }, function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    });\n  };\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.value = Howler._muted ? 0 : 1;\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    });\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (typeof exports !== 'undefined') {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Define globally in case AMD is not available or unused.\n  if (typeof window !== 'undefined') {\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.0.4\n *  howlerjs.com\n *\n *  (c) 2013-2017, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n  \n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              sound._panner.setPosition(pan, 0, 0);\n            } else {\n              sound._panner.pan.value = pan;\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or\n   * all in the group. The most common usage is to set the 'x' position for\n   * left/right panning. Setting any value higher than 1.0 will begin to\n   * decrease the volume of the sound as it moves further away.\n   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setPosition(x, y, z);\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            sound._panner.setOrientation(x, y, z);\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.\n   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of\n   *                      `coneOuterGain` outside this angle.\n   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.\n   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves\n   *                      away from listener. Can be `linear`, `inverse` or `exponential`.\n   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *     refDistance - (1 by default) A reference distance for reducing volume as the source\n   *                    moves away from the listener.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.\n   * \n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,\n            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,\n            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,\n            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,\n            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.panningModel = pa.panningModel;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.value = sound._stereo;\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id);\n    }\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/howler/dist/howler.js\n// module id = 17\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ocean.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ocean.ogg\n// module id = 18\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ocean.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ocean.mp3\n// module id = 19\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/slide-left.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/slide-left.ogg\n// module id = 20\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/slide-left.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/slide-left.mp3\n// module id = 21\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/slide-right.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/slide-right.ogg\n// module id = 22\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/slide-right.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/slide-right.mp3\n// module id = 23\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/filter-change.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/filter-change.ogg\n// module id = 24\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/filter-change.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/filter-change.mp3\n// module id = 25\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-enter-island-name-or-home-link.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-enter-island-name-or-home-link.ogg\n// module id = 26\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-enter-island-name-or-home-link.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-enter-island-name-or-home-link.mp3\n// module id = 27\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-enter-arrow-button-or-marker-or-home-link.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-enter-arrow-button-or-marker-or-home-link.ogg\n// module id = 28\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-enter-arrow-button-or-marker-or-home-link.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-enter-arrow-button-or-marker-or-home-link.mp3\n// module id = 29\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-click.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-click.ogg\n// module id = 30\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/mouse-click.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/mouse-click.mp3\n// module id = 31\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ajax-success.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ajax-success.ogg\n// module id = 32\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ajax-success.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ajax-success.mp3\n// module id = 33\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ajax-error.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ajax-error.ogg\n// module id = 34\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/ajax-error.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/ajax-error.mp3\n// module id = 35\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-1.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-1.ogg\n// module id = 36\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-1.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-1.mp3\n// module id = 37\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-2.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-2.ogg\n// module id = 38\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-2.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-2.mp3\n// module id = 39\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-3.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-3.ogg\n// module id = 40\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-3.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-3.mp3\n// module id = 41\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-4.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-4.ogg\n// module id = 42\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-4.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-4.mp3\n// module id = 43\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-5.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-5.ogg\n// module id = 44\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-5.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-5.mp3\n// module id = 45\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-6.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-6.ogg\n// module id = 46\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-6.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-6.mp3\n// module id = 47\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-7.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-7.ogg\n// module id = 48\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-7.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-7.mp3\n// module id = 49\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-8.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-8.ogg\n// module id = 50\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-8.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-8.mp3\n// module id = 51\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-9.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-9.ogg\n// module id = 52\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-9.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-9.mp3\n// module id = 53\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-10.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-10.ogg\n// module id = 54\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-10.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-10.mp3\n// module id = 55\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-11.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-11.ogg\n// module id = 56\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-11.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-11.mp3\n// module id = 57\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-12.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-12.ogg\n// module id = 58\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-12.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-12.mp3\n// module id = 59\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-13.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-13.ogg\n// module id = 60\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-13.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-13.mp3\n// module id = 61\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-14.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-14.ogg\n// module id = 62\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-14.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-14.mp3\n// module id = 63\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-15.ogg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-15.ogg\n// module id = 64\n// module chunks = 2","module.exports = __webpack_public_path__ + \"sounds/seagull-15.mp3\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sounds/seagull-15.mp3\n// module id = 65\n// module chunks = 2","function getNumberToDivideTextboxHeightBy(currentIsland) {\r\n  let number;\r\n  switch (currentIsland) {\r\n    case 'Amsterdam Island':\r\n      number = 1.85;\r\n      break;\r\n    case 'Christmas Island':\r\n      number = 1.7;\r\n      break;\r\n    case 'St Kilda':\r\n      number = 1.875;\r\n      break;\r\n    case 'Ascension Island':\r\n      number = 1.74;\r\n      break;\r\n    case 'Brava':\r\n      number = 1.75;\r\n      break;\r\n    case 'Tristan da Cunha':\r\n      number = 1.7;\r\n      break;\r\n    case 'Antipodes Island':\r\n      number = 1.55;\r\n      break;\r\n    case 'Banaba Island':\r\n      number = 1.61;\r\n      break;\r\n    case 'Pingelap':\r\n      number = 1.55;\r\n      break;\r\n    case 'Easter Island':\r\n      number = 1.5;\r\n      break;\r\n    case 'Pukapuka':\r\n      number = 1.8;\r\n      break;\r\n    case 'Peter I Island':\r\n      number = 1.9;\r\n      break;\r\n    case 'Deception Island':\r\n      number = 1.85;\r\n      break;\r\n    case 'Rudolph Island':\r\n      number = 1.4;\r\n      break;\r\n    default:\r\n      throw new Error('Error adjusting pan position in desktop view.');\r\n  }\r\n  return number;\r\n} // End of getNumberToDivideTextboxHeightBy().\r\n\r\nexport default getNumberToDivideTextboxHeightBy;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/getNumberToDivideTextboxHeightBy.js","import islands from './islands';\r\nimport populateInfoWindow from './populateInfoWindow';\r\nimport makeCustomMarkerIcon from './makeCustomMarkerIcon';\r\nimport tinygif from '../../img/misc/tinygif.gif';\r\nimport * as audio from './audio';\r\n\r\nfunction makeMarker(position, timeout, map, mapObject, infoWindow) {\r\n  // We'll make two custom marker icons, each a different colour, so that the default brown\r\n  // marker turns green when it is hovered over, or when the relevant island name is hovered\r\n  // over in the menu. The markerSrcPathPosition variable is passed into makeCustomMarkerIcon()\r\n  // so a different angled pin image is selected each time we make a marker.\r\n  const markerSrcPathPosition = Math.floor(Math.random() * 3);\r\n  const defaultIcon = makeCustomMarkerIcon('brown', markerSrcPathPosition, mapObject);\r\n  const highlightedIcon = makeCustomMarkerIcon('green', markerSrcPathPosition, mapObject);\r\n\r\n  setTimeout(() => {\r\n    const markerPosition = islands[position].markerPosition;\r\n    const islandName = islands[position].name;\r\n    const ocean = islands[position].ocean;\r\n    const marker = new mapObject.Marker({\r\n      icon: tinygif,\r\n      map,\r\n      position: markerPosition,\r\n      title: islandName,\r\n      ocean,\r\n      class: `marker${position}`,\r\n      optimized: false,\r\n      flat: true,\r\n      draggable: true,\r\n      animation: mapObject.Animation.DROP\r\n    });\r\n\r\n    // Setting 'marker.icon' to the 'tinygif.gif' image above and then switching it to the\r\n    // actual desired icon 20ms later fixes a marker flicker bug that Google have yet to\r\n    // address. For more info on this bug see... https://issuetracker.google.com/issues/35820791\r\n    // For more info on the tinygif graphic (which comes in handy for all sorts of things!)\r\n    // see... http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever\r\n    setTimeout(() => {\r\n      marker.setIcon(defaultIcon);\r\n    }, 20);\r\n\r\n    map.markers.push(marker);\r\n\r\n    // Setting each 'marker.draggable' to 'true' above prevents the markers from\r\n    // appearing in multiple places at once when the map is zoomed out as wide as possible. If a\r\n    // user actually does then try to drag a marker the marker's position is reset to it's\r\n    // original position on 'mouseup'.\r\n    marker.addListener('mouseup', function() {\r\n      this.setPosition(markerPosition);\r\n    });\r\n\r\n    // Changes the colour of a marker when a user hovers over it.\r\n    marker.addListener('mouseover', function() {\r\n      map.globalView\r\n        ? audio.mouseEnterArrowButtonOrMarkerOrHomeLink.volume(0.35)\r\n        : audio.mouseEnterArrowButtonOrMarkerOrHomeLink.volume(0.7);\r\n      audio.mouseEnterArrowButtonOrMarkerOrHomeLink.play();\r\n      this.setIcon(highlightedIcon);\r\n    });\r\n\r\n    marker.addListener('mouseout', function() {\r\n      this.setIcon(defaultIcon);\r\n    });\r\n\r\n    marker.addListener('click', function() {\r\n      map.globalView ? audio.mouseClick.volume(0.25) : audio.mouseClick.volume(0.35);\r\n      audio.mouseClick.play();\r\n      populateInfoWindow(this, infoWindow, map, mapObject);\r\n    });\r\n  }, timeout);\r\n} // End of makeMarker().\r\n\r\nexport default makeMarker;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/makeMarker.js","import loading from '../../img/misc/loading.gif';\r\nimport closeButtonTransparentBackground from '../../img/misc/close-button-transparent-background.gif';\r\nimport styleInfoWindow from './styleInfoWindow';\r\nimport * as audio from './audio';\r\n\r\n// Populates a marker's info window, first with a spinner loading graphic, then with the ajax\r\n// response from the World Tides API. See https://www.worldtides.info/apidocs for more information.\r\nfunction populateInfoWindow(marker, infoWindow, map, mapObject) {\r\n  // This function isn't called until we get an AJAX response/error.\r\n  function showCloseButton() {\r\n    // See the following link for more info on reasons for using setTimeout with a 0ms delay...\r\n    // https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful\r\n    // ...in our case, we need to do it or else the 'img.src' switch is done too early\r\n    // then overwritten again.\r\n    setTimeout(() => {\r\n      // This unhides the 'x' close button in the info window, which is set to 'display: none'\r\n      // while the loading spinner is shown. We then replace the close button image itself with\r\n      // one that has a transparent background, so that it blends nicely with the background\r\n      // color of the info window.\r\n      const nearestRetrievableClass = document.getElementsByClassName('gm-style-iw')[0];\r\n      const closeButton = nearestRetrievableClass.nextSibling;\r\n      closeButton.style.display = 'block';\r\n      const img = closeButton.firstChild;\r\n      img.setAttribute('src', closeButtonTransparentBackground);\r\n    }, 0);\r\n\r\n    mapObject.event.addListenerOnce(infoWindow, 'closeclick', () => {\r\n      map.globalView ? audio.mouseClick.volume(0.25) : audio.mouseClick.volume(0.35);\r\n      audio.mouseClick.play();\r\n      infoWindow.setContent(null);\r\n      infoWindow.marker = null;\r\n      infoWindow.close();\r\n    });\r\n  }\r\n\r\n  infoWindow.marker = marker;\r\n\r\n  // Ensures the marker only bounces three times.\r\n  setTimeout(() => {\r\n    marker.setAnimation(null);\r\n  }, 2150);\r\n\r\n  if (map.globalView) {\r\n    map.panTo(marker.position);\r\n  }\r\n\r\n  infoWindow.setContent(`<img class='infowindow__loading-spinner' src='${loading}'/>`);\r\n\r\n  infoWindow.open(map, marker);\r\n  styleInfoWindow();\r\n\r\n  const lat = marker.position.lat();\r\n  const lng = marker.position.lng();\r\n  const timestamp = Math.floor(Date.now() / 1000);\r\n\r\n  // The target url for the ajax request queries the World Tides API for predicted tide heights in\r\n  // the ocean surrounding the island. If the ajax request is successful the API responds with a\r\n  // JSON object, which contains a 'heights' array property. This array contains the predicted\r\n  // average tide height for each 30 minute period over the next week. By finding the time/date\r\n  // of the maximum tide height, the user can then be told when it's safest to approach the\r\n  // island, as obviously the higher the tide is then the less chance there is of hitting rocks\r\n  // and getting shipwrecked. Sail safe folks! :)\r\n  const targetUrl = `https://www.worldtides.info/api?heights&lat=${lat}&lon=${lng}&start=${timestamp}&length=604800&key=bf1c3079-2eee-4c95-8e55-ebc8fc0b33cc`;\r\n\r\n  fetch(targetUrl).then(response => {\r\n    if (!response.ok) {\r\n      throw Error(response.statusText);\r\n    }\r\n    return response.json();\r\n  }).then(data => {\r\n    const parsedHeights = [];\r\n\r\n    // Each object in the data.heights array contains the tide height and the date/time of\r\n    // that tide height. We just want the height for now, so we push each value to the\r\n    // 'parsedHeights' array.\r\n    data.heights.forEach(item => parsedHeights.push(item.height));\r\n\r\n    const highestTide = Math.max(...parsedHeights);\r\n    const indexOfHighestTide = parsedHeights.indexOf(highestTide);\r\n\r\n    // With the index number of the highest tide, we can now go to that same index number in\r\n    // the original 'data.heights' array and retrieve the date and time of the highest tide.\r\n    const dateAndTime = data.heights[indexOfHighestTide].date;\r\n\r\n    // Lets parse that retrieved date and time into a format we can read.\r\n    const parsedDateAndTime = new Date(dateAndTime);\r\n    const string = parsedDateAndTime.toString();\r\n    const splitString = string.split(' ');\r\n\r\n    // Removes the time zone from the time shown eventually to the user.\r\n    splitString.splice(5, 4);\r\n\r\n    // Removes the seconds unit from the time eventually shown to the user,\r\n    // i.e. turns '21:42:00' into '21:42'.\r\n    splitString[4] = splitString[4].slice(0, -3);\r\n\r\n    // We'll now format the date so that its contents are unabbreviated and properly suffixed,\r\n    // i.e. 'Mon' will become 'Monday', 'Aug' will become 'August', '04' will become '4th', etc.\r\n    // Here we also enable Webpack's code splitting feature. This allows us to withhold loading\r\n    // certain scripts until the time they're actually needed - in our case, when a user clicks\r\n    // a marker. The '_unabbreviateDate' script is small - only 2kb - so it hardly makes a\r\n    // difference for this website, but that's besides the point. You could imagine how handy\r\n    // code splitting could be when scaled up to much larger projects. Projects I'd like to work\r\n    // on! Hire me, for god's sake! :)\r\n    System.import('./unabbreviateDate').then(unabbreviateDate => {\r\n      const dayMonthDateAndTime = unabbreviateDate.default(splitString);\r\n      return dayMonthDateAndTime;\r\n    }).then(([day, month, date, time]) => {\r\n      const safestDateAndTimeToDock = `<p class=\"infowindow__text\">According to\r\n      <a class=\"infowindow__text__world-tides-link\"\r\n      target=\"_blank\" href=\"https://www.worldtides.info\">World Tides</a>,\r\n      the safest date and time to travel to ${marker.title} over the next week is\r\n      ${day}, ${month} ${date}, at ${time}.`;\r\n\r\n      infoWindow.setContent(safestDateAndTimeToDock);\r\n\r\n      // Even though the info window is already open, we're going to call its open method\r\n      // again so the map auto pans to fit the newly populated info window on screen. If we\r\n      // don't do this the info window text may not be fully readable. We'll also have to call\r\n      // the styleInfoWindow function again, otherwise the info window will lose its custom\r\n      // styling that we set first time around.\r\n      infoWindow.open(map, marker);\r\n      styleInfoWindow();\r\n\r\n      showCloseButton();\r\n\r\n      map.globalView ? audio.ajaxSuccess.volume(0.4) : audio.ajaxSuccess.volume(1.0);\r\n      audio.ajaxSuccess.play();\r\n    });\r\n  }).catch(err => {\r\n    map.globalView ? audio.ajaxError.volume(0.4) : audio.ajaxError.volume(1.0);\r\n    audio.ajaxError.play();\r\n    infoWindow.setContent(`<div class=\"infowindow__text infowindow__text--error\">Can't retrieve information right now,\r\n    please try again later.</div>`);\r\n    showCloseButton();\r\n    throw new Error(err);\r\n  });\r\n} // End of populateInfoWindow().\r\n\r\nexport default populateInfoWindow;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/populateInfoWindow.js","module.exports = \"data:image/gif;base64,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\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/misc/close-button-transparent-background.gif\n// module id = 69\n// module chunks = 2","// Dynamically style the border and background of the Info Window. We have to do some pretty nasty\r\n// traversing of the DOM here, but I think the end result is far nicer than Google's default.\r\nfunction styleInfoWindow() {\r\n  const nearestRetrievableClass = document.getElementsByClassName('gm-style-iw')[0];\r\n  const infoWindowStylingDiv = nearestRetrievableClass.previousElementSibling;\r\n  infoWindowStylingDiv.children[1].style.borderRadius = '.75vh';\r\n\r\n  const infoWindowUnderlayerParent = infoWindowStylingDiv.children[3];\r\n  infoWindowUnderlayerParent.style.border = '.6vh solid rgb(172, 226, 234)';\r\n  infoWindowUnderlayerParent.style.borderRadius = '.75vh';\r\n\r\n  // Give the Info Window a glazed, glass-like background in desktop view, so the map can be seen\r\n  // passing beneath. The combination of the two divs - with different background colours and\r\n  // opacity settings layered on top of each other - is a subtle but nice effect I think. The same\r\n  // effect can also be seen on '.textbox' and '.menu__icon-arrow' in desktop view.\r\n  if (window.innerWidth >= 1366) {\r\n    const infowindowUnderlayer = document.createElement('div');\r\n    infowindowUnderlayer.style.backgroundColor = 'rgba(255, 255, 255, 0)';\r\n    infowindowUnderlayer.style.width = '100%';\r\n    infowindowUnderlayer.style.height = '100%';\r\n    infoWindowUnderlayerParent.style.backgroundColor = 'rgba(232, 244, 248, 0.875)';\r\n    infoWindowUnderlayerParent.appendChild(infowindowUnderlayer);\r\n  } else {\r\n    infoWindowUnderlayerParent.style.backgroundColor = 'rgb(232, 244, 248)';\r\n  }\r\n\r\n  // Styles the point of the infowindow.\r\n  const infoWindowPoint = infoWindowStylingDiv.children[2];\r\n  const [leftSideOfPoint, rightSideOfPoint] = infoWindowPoint.children;\r\n  leftSideOfPoint.firstChild.style.backgroundColor = 'rgb(172, 226, 234)';\r\n  rightSideOfPoint.firstChild.style.backgroundColor = 'rgb(172, 226, 234)';\r\n}\r\n\r\nexport default styleInfoWindow;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/styleInfoWindow.js","import leftLeaningBrownPin from '../../img/pins/left-leaning-brown-pin.png';\r\nimport straightBrownPin from '../../img/pins/straight-brown-pin.png';\r\nimport rightLeaningBrownPin from '../../img/pins/right-leaning-brown-pin.png';\r\nimport leftLeaningGreenPin from '../../img/pins/left-leaning-green-pin.png';\r\nimport straightGreenPin from '../../img/pins/straight-green-pin.png';\r\nimport rightLeaningGreenPin from '../../img/pins/right-leaning-green-pin.png';\r\n\r\nfunction makeCustomMarkerIcon(color, markerSrcPathPosition, mapObject) {\r\n  let customMarkerIcon;\r\n\r\n  // These two arrays contains src paths for pin images leaning at different angles. In the\r\n  // makeCustomeMarkerIcon() we will randomly select one of them for each colour, just to add a bit\r\n  // of variety to our pin icons.\r\n  const brownMarkerSrcPaths = [leftLeaningBrownPin, straightBrownPin, rightLeaningBrownPin];\r\n  const greenMarkerSrcPaths = [leftLeaningGreenPin, straightGreenPin, rightLeaningGreenPin];\r\n\r\n  if (color === 'brown') {\r\n    const randomlySelectedBrownPin = brownMarkerSrcPaths[markerSrcPathPosition];\r\n    customMarkerIcon = new mapObject.MarkerImage(\r\n      randomlySelectedBrownPin,\r\n      new mapObject.Size(34, 40),\r\n      new mapObject.Point(0, 0),\r\n      new mapObject.Point(10, 34),\r\n      new mapObject.Size(34, 40)\r\n    );\r\n  } else if (color === 'green') {\r\n    const randomlySelectedGreenPin = greenMarkerSrcPaths[markerSrcPathPosition];\r\n    customMarkerIcon = new mapObject.MarkerImage(\r\n      randomlySelectedGreenPin,\r\n      new mapObject.Size(34, 40),\r\n      new mapObject.Point(0, 0),\r\n      new mapObject.Point(10, 34),\r\n      new mapObject.Size(34, 40)\r\n    );\r\n  }\r\n  return customMarkerIcon;\r\n} // End of makeCustomMarkerIcon().\r\n\r\nexport default makeCustomMarkerIcon;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/makeCustomMarkerIcon.js","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAANlBMVEVMaXE0JiQHBwemenWab2tvUU0EBQSQZ2RkSUZ4WFRzV1F6W1eEYFx+gH+IYl+BXlrOzs+poJ9aShZfAAAAEXRSTlMAFj3+/v4o/v7+hL9L8////nTCTVsAAAGhSURBVEjH5ZbLtsMgCEVD1CSC0fb/f/YCmldXxc4vg3bQsxeHV9Jp+u8BCZGIEOEnNVLOpZTIEQjG8nVV/UEM9Og96+8Emnpq+htBI/36SVh6p/oHUULq6pNX4Ehx5ECz4BYnEYNRxAVUVyXnuAWjTclL3FOEbdtCf3SwXp6EiUGAZHbVnUky2xfAnBtm7zi8yLk9AtirAVlSaAE6M05gzo3LXpU4OiolRxjsakvR9AwMr4JWKfsgQhGMkmlLyj5T1E+zWdJcMfUANsMWthR1biFugxR8og9PPAv5JmsDH55CC+guIO8q9zY3TzpwiU6j6iKdnqKG6At2E8g51EmcTw5GCpk39PEc4MIzGRmeRNHGxu81wPPkWJ2rvttWcv5+1rmd3RYWY8zOHXmynpEAC0Dvhnhsb1evopQGEOt7BG+3u85O7y7gAn0iZe+fAC4cFkEVqERQeYueq4TEenlj7e9Il7wLcOnLrIGvfZ+X+WJGwPx67yjfFepnmA5gf+0k8pF+gpZDPY3lDeFQT6r+4Y0tjQf2tC8Av/8nEPvff/kD5DsfUH16u2cAAAAASUVORK5CYII=\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/left-leaning-brown-pin.png\n// module id = 72\n// module chunks = 2","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAASFBMVEVMaXGecW4EBQIFBQSUa2c8SxxnS0h9W1daQz+MZmKeu0xmXEimrGNTXyKinHhubjhwcXOXemavr7GFYF1yVFCpeXZ1dnjX2NmyiyVZAAAAE3RSTlMA/jYj/hT+/v7+Ps10b6Ooydv+B5ahDAAAAZVJREFUSMfV1tGSgyAMBVCBICgqteLu///pJpC2agX0celMX3rPBIRgm+Z/DN3Hoa+Fh2kG6LplMcb5oYb0JIQATFMeRzC+SPoY7yJgEVxfyEPKJ5AIijyYQAC8hTFcQxcAMNhNqga+RH4RUxenBDsQ2iJYVwGbdWO8bfNT6gmsgldOaWtt6wv7MIhV8C7jYlvK28rOzWmfKZ/AWDkbw8IVEigtgEssOKuOQJxPCM0VADeAPgBX7YfuLphhB/xdUOqG2HB4knbA2hIZqH+OAPe6mD8BOdFzf25B/LK2zxYgITaADI7zAzUAt0L3OhoYjUcqBwR8XQEhgpABNHuA4xVAIwOW2KCHK8DkK/QLUIdyz2GePnEpQWocZ6dCpIbm2/L1pFqntD4j2J8IUjb1dAKv/EmNiYHZgjGfp7fDvK/gR6WUVpk4v34G7+nZ+HGUUsVRyifkfqyTNJRkUc4r9wwJsKgAJR/Pn4eUG1Kr8Pj9gFSiDPQHXFkCbUgC/ITqeQb62qv9Da7Hm8YhUHf+bSjc5fNf/gBLMiNOeFSilgAAAABJRU5ErkJggg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/straight-brown-pin.png\n// module id = 73\n// module chunks = 2","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAARVBMVEVMaXFeRkKHY2BQQjsdFhQODwmEYV6IYl9uUE0xJCN6fH2PameRaWXNzc6jpKWBXVmQZ2R3V1NjSUWZb2tbQz+jeHGyi4HKvLD/AAAAD3RSTlMAvrWEKUBZ/v0W+ZHm+vldvLSeAAABwklEQVRIx+1VWXbDIAy0ARthu2Ezvv9RKwkvpC2QA1Qv+crM00iaIcPwX281rwJrndWH8C0dKcXonNNi7uPXeCQEayyrrd26lBiTy3iEW+v9aNqCWMvZITN8s4k48a4gQIuhiw76IkB9X8ryCIUkZoz1ETQu6dcQAFWCcTGlIxYEz4T6pla62X2IvqRh2BCtT00XwcsGweCaCKr10wNarsKxM9D7LB9CY2YawqV4EhDLBbJ9ahoi46GHN5gEnQmMB4ZXBzAi0sC4V0eDhh2rdQGzpUSuOxUxIVjREJ/PFQtCAK8a+8/BiZciInjoJUdrdEahKNTzJlL2gytGAMBvjWHTkQ3kiAA8gidWxXizdUe8g3YqAtrsPtcslI7H1dwg8CkqLYiAD9iPoLE3Kpo2JODHvQWtRZgTecLlMLx1kNVwcnSu3NwEUMbUXtU7lrypbFgYDVXl3X6ydpob3STrBDT4o4Z3GtBNU4OAL5+wV9h2Pp2XqgGnJlPRYA/jpFQbr+QLFilHLolwrHaD12sZp1zqrFYLM30ti7wIUxePx0BCAe7ih68XNSAcY00HPszUgBfJQNP90xVIUGb4vAzK+fuXbzpcLcrEe256AAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/right-leaning-brown-pin.png\n// module id = 74\n// module chunks = 2","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAASFBMVEVMaXEHBwdadlVqi2BWdlF3mWspOCZyk2dfgFgEBQNjhVl5lWxylGdBYDx9f4FtjmJMbUlniF5+oHCEqXWHu4DOzs9TpDKio6Tl3rzCAAAAGHRSTlMAPb1J/f4W/v4ocdKWi/v+///////+//4HGXCpAAAB0UlEQVRIx+WWyXbDMAhFG1lCowdZTvL/f1pAchz3RDj7ski64J4HPFD68/PfA4aQlFIpwFfZIc5zztlRqEsEkjGW8iuh1UV+MCvmzyxRiSDmxxXzGXgRokQslN+IvQ8hP7X8AyBm6OYPazEYZ8K5sS9QgUMk59lpoYmEHZuzhlu0MKawngk762VZdN86MO+AtVkTMIgulLKr2Ow0AaNkQ7Jr2bZSyGscDwHyasBMEmw1e4YCom/ohClI2EZwyw4udjXuEpyPgBovriIZQl4KmTAljWqw1MdLAj/pO4jD3VjiAGi8INW0YeO4Frp2zQqCRDCnmnRTUMIGWqrpmFML6N0E2oA11SbYOVeBodcxbR65x4Plp4aJx9gToF2ltZ3f3hpEHp+bCGX9e6RMLD1gqMt93CiLUO+Pzz3Afg07QcNaeDuEl+ntHcDWaVRYku/ZZvGE0OnaSj0jssID9G7IMNE2tgKLwvweEfFMjyPiu9Ojhz4xVKA+yQyMnoKRz0RsQL3Tmr4jnX1KMRqr8DbjUyt/BHSPAvyNY7xP083fDuIKuN2f00jfFRKubgfifVL8h1wRSjQNruk6vSEYXBNnf/GLTVbBhDV5gO//J8DKOmv3C+FiJ5n3tNWzAAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/left-leaning-green-pin.png\n// module id = 75\n// module chunks = 2","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAUVBMVEVMaXFPa0kEBQQEBgJHYUIAAABefFZqi2FylGh9oHGe0VKNxFCPwmlSbEiPsn1wcXNNeC15oGteikY0USGvr7Fkg1xXdFFBWT2HrHp1dnjX2NkX8WKHAAAAFXRSTlMA/ic4/hT+/v7+Gj5vx6LJbtupfP7WzvN8AAABn0lEQVRIx9WW2YKDIAxFDSKLiHWpaOf/P3QIS0etgH2cvHqPCSE3WlX/I1rlor0n7vpRCMH5six86kpQ20spUY76ZWGMTVmki/JAWMCwDKHkZvWBiCmMTgO9dPodwZBIp+iFB/iRyAAhwa4mSxiVy/CJMMgAXG67YyNiACBdkkJgC1msmgGlFKbsPaDc1cKMfbnVU529OTUGgEVgKMxGx8VfBlsPlIYJjyEF6oGuKzWmugXw+0B7AnTRD0eAlYHxCEzFkk6AVgXD2Uk9nMFenMoa7gNYKZ2y/rkAqE4ZVIozACsCVCULwpA7AOV2pIYc4H3A/CSBwRmEFLBz23tnIGASgNgulobBSADBoPy4lxgASwECHbrJ/QrAvgKrGxsXYyTQodJ3l8dOWUA3Pi7nSIZNbKsHp1+pJgnAjtIZwLuYm5TefR1GD/iGUjoPhCTV8fPTTRO+fp7nuiYucnoXjX6tmtRRXwQaop9G1z7uEKR+PF+PoA9EIcPjJwI+R7GmN3Dz0FXvAKss9fQAkKa6HQh8o680At/8bZBhrq+f/AJRfCapkrmKmwAAAABJRU5ErkJggg==\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/straight-green-pin.png\n// module id = 76\n// module chunks = 2","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAUVBMVEVMaXF6n20lMyEBBgFdflRXdlEpNiVqjGBniF10l2hri2EMFwtylWdJYkODhIZzk2g4XSZZcllPbEnHyMhXhmBvkWRQbkpigllKZkWAp3KBvnwzYopdAAAAFXRSTlMA/iQw/v4T/v7+WUa8tvmTd6fb+9miVutwAAAB0UlEQVRIx+2UbZaDIAxFDQKKWqutoLD/hU4SalvbIc4CJsd/fbd5+aKq/uMQ3XXAuHbqj3JIKUVwzvlm7s71V5cSan3D0S6niIuR9Ey0bbuui+yscxTvwKo72ZGDTLwAkWjgLUXLhNam7Eo1ED89ITCXS/CQ4hegTRGwDmJM8FG1NrZcdIwAET6qXoSqB1Y/RrdXPQmAAshjfsthpNlh2dxRLpbqNUHf5MlF8A07QS2H6KgaEHAHQJiCxUtogAHqJQO3uViAHRxghyJbWk3YMIwwAUszxoZSW3cg+Fkwnwe8OyIgGK+EBPlwIDvKgNfSKQMDR0fhZssrkZfUcVM5wWb0thWJNqZ8aP7lSBN1KThqXNp39OlIU2e3rgTgHexngBlQH3gUhRS4c3g58XiZeTcKq4dnE/Fz30CpiBjpfaSmvk6Zgal4nHw6XMYzBS2rsoXOXsE9HiN29TClb5ai8Ez6p3T3g/esigAu+O6G1DSJsJpaAPAJmJvdPY0gmHVSStBjkr7VBOShhQvqlaiv52SWabpwTH2tTgBVj+N66THqR5xl6O/jODHQvwDxWULg+P+yvrrfx7nPQtLKHaLZUYKaXefvLGYElK3+Hgrt//7LD/2QLY0II50UAAAAAElFTkSuQmCC\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/img/pins/right-leaning-green-pin.png\n// module id = 77\n// module chunks = 2","// Sets the min and max zoom levels allowed so that each island is always seen at its most\r\n// appropriate zoom level without overflowing the browser window. Also determines the min and max\r\n// zoom levels to display overlay tiles at.\r\nfunction setMinAndMaxZoomLevels(currentIsland) {\r\n  let minZoomLevel;\r\n  let maxZoomLevel;\r\n  switch (currentIsland) {\r\n    case 'Rudolph Island':\r\n      minZoomLevel = 8;\r\n      maxZoomLevel = 9;\r\n      break;\r\n    case 'Peter I Island':\r\n      minZoomLevel = 9;\r\n      maxZoomLevel = 10;\r\n      break;\r\n    case 'Deception Island':\r\n      minZoomLevel = 9;\r\n      maxZoomLevel = 11;\r\n      break;\r\n    case 'Easter Island':\r\n      minZoomLevel = 10;\r\n      maxZoomLevel = 12;\r\n      break;\r\n    case 'Tristan da Cunha':\r\n      minZoomLevel = 10;\r\n      maxZoomLevel = 12;\r\n      break;\r\n    case 'Christmas Island':\r\n      minZoomLevel = 10;\r\n      maxZoomLevel = 12;\r\n      break;\r\n    case 'Amsterdam Island':\r\n      minZoomLevel = 9;\r\n      maxZoomLevel = 12;\r\n      break;\r\n    case 'Brava':\r\n      minZoomLevel = 11;\r\n      maxZoomLevel = 13;\r\n      break;\r\n    case 'Antipodes Island':\r\n      minZoomLevel = 11;\r\n      maxZoomLevel = 13;\r\n      break;\r\n    case 'Ascension Island':\r\n      minZoomLevel = 10;\r\n      maxZoomLevel = 13;\r\n      break;\r\n    case 'St Kilda':\r\n      minZoomLevel = 10;\r\n      maxZoomLevel = 13;\r\n      break;\r\n    case 'Pukapuka':\r\n      minZoomLevel = 11;\r\n      maxZoomLevel = 13;\r\n      break;\r\n    case 'Banaba Island':\r\n      minZoomLevel = 12;\r\n      maxZoomLevel = 14;\r\n      break;\r\n    case 'Pingelap':\r\n      minZoomLevel = 13;\r\n      maxZoomLevel = 14;\r\n      break;\r\n    default:\r\n      throw new Error('Error setting minimum and maximum zoom levels.');\r\n  }\r\n\r\n  return [minZoomLevel, maxZoomLevel];\r\n} // End of setMinAndMaxZoomLevels().\r\n\r\nexport default setMinAndMaxZoomLevels;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/setMinAndMaxZoomLevels.js","import tinygif from '../../img/misc/tinygif.gif';\r\n// This code is modified from examples provided by the Google Developers site and Maptiler,\r\n// and to be honest I'm not entirely sure what some of it is doing! What's 'z2 = Math.pow()'?!\r\n// Seems like witchcraft to me! But it's still working after feeding it my own variables and\r\n// making a few adjustments, and that's the most important thing! #juniordevforlife\r\n//\r\n// https://developers.google.com/maps/documentation/javascript/examples/maptype-image\r\n// https://www.maptiler.com/how-to/map-processing/\r\nfunction getOverlayTileURL(map, mapObject, islandName, islandBounds, currentZoomLevel,\r\n  overlayMinZoom, overlayMaxZoom) {\r\n  const tileURL = new mapObject.ImageMapType({\r\n    getTileUrl(coord, currentZoomLevel) {\r\n      const proj = map.getProjection();\r\n      const z2 = Math.pow(2, currentZoomLevel); // eslint-disable-line no-restricted-properties\r\n      const tileXSize = 256 / z2;\r\n      const tileYSize = 256 / z2;\r\n      const mapTilesBaseURL = PRODUCTION\r\n        ? `./img/overlays/${islandName}/`\r\n        : `./src/img/overlays/${islandName}/`;\r\n      const tileBounds = new mapObject.LatLngBounds(\r\n        proj.fromPointToLatLng(new mapObject.Point(coord.x * tileXSize, (coord.y + 1) * tileYSize)),\r\n        proj.fromPointToLatLng(new mapObject.Point((coord.x + 1) * tileXSize, coord.y * tileYSize))\r\n      );\r\n      const y = coord.y;\r\n      const x = coord.x >= 0 ? coord.x : z2 + coord.x;\r\n      if (\r\n        islandBounds.intersects(tileBounds) &&\r\n        overlayMinZoom <= currentZoomLevel &&\r\n        currentZoomLevel <= overlayMaxZoom\r\n      ) {\r\n        const url = `${mapTilesBaseURL}${currentZoomLevel}/${x}/${y}.png`;\r\n        return url;\r\n      }\r\n      return tinygif;\r\n    },\r\n    tileSize: new mapObject.Size(256, 256),\r\n    isPng: true,\r\n    opacity: 1.0\r\n  });\r\n\r\n  return tileURL;\r\n}\r\n\r\nexport default getOverlayTileURL;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/getOverlayTileURL.js","const mapStyles = [\r\n  {\r\n    featureType: 'landscape',\r\n    elementType: 'all',\r\n    stylers: [\r\n      {\r\n        lightness: -5\r\n      },\r\n      {\r\n        saturation: -24\r\n      },\r\n      {\r\n        gamma: 0.95\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    featureType: 'road',\r\n    elementType: 'all',\r\n    stylers: [\r\n      {\r\n        visibility: 'on'\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    featureType: 'road.local',\r\n    elementType: 'all',\r\n    stylers: [\r\n      {\r\n        lightness: 0\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    featureType: 'road.local',\r\n    elementType: 'geometry.fill',\r\n    stylers: [\r\n      {\r\n        lightness: -3\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    featureType: 'water',\r\n    elementType: 'all',\r\n    stylers: [\r\n      {\r\n        color: '#51AFBC'\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    elementType: 'labels',\r\n    stylers: [\r\n      {\r\n        visibility: 'off'\r\n      }\r\n    ]\r\n  }\r\n]; // End of mapStyles.\r\n\r\nexport default mapStyles;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/mapStyles.js","/** @module google-maps-api */\n\nvar script = require( 'scriptjs' ),\n  promise = require( 'promise' );\n\nvar maps = null,\n  callBacks = [],\n  key;\n\nwindow.$$mapsCB = function() {\n\n  maps = google.maps;\n\n  for( var i = 0, len = callBacks.length; i < len; i++ ) {\n\n    resolve.apply( undefined, callBacks[ i ] );\n  }\n};\n\nfunction resolve( onOk, onErr, onComplete, err ) {\n\n  if( !err ) {\n\n    onOk( maps );\n\n    if( onComplete )\n      onComplete( undefined, maps );\n  } else {\n\n    onErr( err );\n\n    if( onComplete )\n      onComplete( err );\n  }\n}\n\n\n/**\n * Load a Google Maps API Object asynchronously. This module will return a Promise.\n * Which will on resolved will return the \"google.maps\" object.\n *\n * Or if you prefer you can simply use the callback instead.\n *\n * @param  {String} apikey Your Google Maps API Key\n * @param  {Function} [onComplete] A callback which will return the google.maps object\n * @return {Promise} When this promise resolves it will return the google.maps object\n *\n * @example using via promise\n *\n * ```javascript\n * var mapsapi = require( 'google-maps-api' )( 'your api key' );\n *\n * mapsapi().then( function( maps ) {\n *\n *  //use the google.maps object as you please\n * });\n * ```\n *\n * @example using via callback\n * ```javascript\n * require( 'google-maps-api' )( 'your api key', function( maps ) {\n *\n *  //use the google.maps object as you please\n * })\n * ```\n */\nmodule.exports = function( apikey, libraries, onComplete ) {\n\n  key = apikey || key;\n  if (typeof libraries == 'function') {\n    onComplete = libraries;\n    libraries = [];\n  }\n\n  return function() {\n\n    return new promise( function( onOk, onErr ) {\n\n      if( !key ) {\n\n        resolve( onOk, onErr, onComplete, new Error( 'No API key passed to require(\\'google-maps-api\\')' ) );\n      } else {\n\n        if( maps ) {\n\n          resolve( onOk, onErr, onComplete );\n        } else {\n\n          callBacks.push( [ onOk, onErr, onComplete ] );\n\n          if (callBacks.length == 1) {\n            var auth = '';\n            if (typeof key == 'string') {\n\n              auth = '&key=' + key;\n            } else if (typeof key == 'object') {\n\n              auth = '&' + Object.keys(key).map(function (k) {\n                return k + '=' + encodeURIComponent(key[k]);\n              }).join('&');\n            }\n\n            var url = 'https://maps.googleapis.com/maps/api/js?v=3&callback=$$mapsCB' + auth;\n            if (Array.isArray(libraries) && libraries.length > 0) {\n              url+='&libraries='+libraries.join(',');\n            }\n            script( url );\n          }\n        }\n      }\n    });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/google-maps-api/index.js\n// module id = 81\n// module chunks = 2","/*!\n  * $script.js JS loader & dependency manager\n  * https://github.com/ded/script.js\n  * (c) Dustin Diaz 2014 | License MIT\n  */\n\n(function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(definition)\n  else this[name] = definition()\n})('$script', function () {\n  var doc = document\n    , head = doc.getElementsByTagName('head')[0]\n    , s = 'string'\n    , f = false\n    , push = 'push'\n    , readyState = 'readyState'\n    , onreadystatechange = 'onreadystatechange'\n    , list = {}\n    , ids = {}\n    , delay = {}\n    , scripts = {}\n    , scriptpath\n    , urlArgs\n\n  function every(ar, fn) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f\n    return 1\n  }\n  function each(ar, fn) {\n    every(ar, function (el) {\n      return !fn(el)\n    })\n  }\n\n  function $script(paths, idOrDone, optDone) {\n    paths = paths[push] ? paths : [paths]\n    var idOrDoneIsDone = idOrDone && idOrDone.call\n      , done = idOrDoneIsDone ? idOrDone : optDone\n      , id = idOrDoneIsDone ? paths.join('') : idOrDone\n      , queue = paths.length\n    function loopFn(item) {\n      return item.call ? item() : list[item]\n    }\n    function callback() {\n      if (!--queue) {\n        list[id] = 1\n        done && done()\n        for (var dset in delay) {\n          every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])\n        }\n      }\n    }\n    setTimeout(function () {\n      each(paths, function loading(path, force) {\n        if (path === null) return callback()\n        \n        if (!force && !/^https?:\\/\\//.test(path) && scriptpath) {\n          path = (path.indexOf('.js') === -1) ? scriptpath + path + '.js' : scriptpath + path;\n        }\n        \n        if (scripts[path]) {\n          if (id) ids[id] = 1\n          return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)\n        }\n\n        scripts[path] = 1\n        if (id) ids[id] = 1\n        create(path, callback)\n      })\n    }, 0)\n    return $script\n  }\n\n  function create(path, fn) {\n    var el = doc.createElement('script'), loaded\n    el.onload = el.onerror = el[onreadystatechange] = function () {\n      if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;\n      el.onload = el[onreadystatechange] = null\n      loaded = 1\n      scripts[path] = 2\n      fn()\n    }\n    el.async = 1\n    el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;\n    head.insertBefore(el, head.lastChild)\n  }\n\n  $script.get = create\n\n  $script.order = function (scripts, id, done) {\n    (function callback(s) {\n      s = scripts.shift()\n      !scripts.length ? $script(s, id, done) : $script(s, callback)\n    }())\n  }\n\n  $script.path = function (p) {\n    scriptpath = p\n  }\n  $script.urlArgs = function (str) {\n    urlArgs = str;\n  }\n  $script.ready = function (deps, ready, req) {\n    deps = deps[push] ? deps : [deps]\n    var missing = [];\n    !each(deps, function (dep) {\n      list[dep] || missing[push](dep);\n    }) && every(deps, function (dep) {return list[dep]}) ?\n      ready() : !function (key) {\n      delay[key] = delay[key] || []\n      delay[key][push](ready)\n      req && req(missing)\n    }(deps.join('|'))\n    return $script\n  }\n\n  $script.done = function (idOrDone) {\n    $script([null], idOrDone)\n  }\n\n  return $script\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/scriptjs/dist/script.js\n// module id = 82\n// module chunks = 2","'use strict';\n\nmodule.exports = require('./lib/core.js')\nrequire('./lib/done.js')\nrequire('./lib/es6-extensions.js')\nrequire('./lib/node-extensions.js')\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise/index.js\n// module id = 83\n// module chunks = 2","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/timers-browserify/main.js\n// module id = 84\n// module chunks = 2","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/setimmediate/setImmediate.js\n// module id = 85\n// module chunks = 2","'use strict';\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this\n  self.then(null, function (err) {\n    asap(function () {\n      throw err\n    })\n  })\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise/lib/done.js\n// module id = 86\n// module chunks = 2","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nfunction ValuePromise(value) {\n  this.then = function (onFulfilled) {\n    if (typeof onFulfilled !== 'function') return this\n    return new Promise(function (resolve, reject) {\n      asap(function () {\n        try {\n          resolve(onFulfilled(value))\n        } catch (ex) {\n          reject(ex);\n        }\n      })\n    })\n  }\n}\nValuePromise.prototype = Promise.prototype\n\nvar TRUE = new ValuePromise(true)\nvar FALSE = new ValuePromise(false)\nvar NULL = new ValuePromise(null)\nvar UNDEFINED = new ValuePromise(undefined)\nvar ZERO = new ValuePromise(0)\nvar EMPTYSTRING = new ValuePromise('')\n\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value\n\n  if (value === null) return NULL\n  if (value === undefined) return UNDEFINED\n  if (value === true) return TRUE\n  if (value === false) return FALSE\n  if (value === 0) return ZERO\n  if (value === '') return EMPTYSTRING\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value))\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex)\n      })\n    }\n  }\n\n  return new ValuePromise(value)\n}\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr)\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    var remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { res(i, val) }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) { \n    reject(value);\n  });\n}\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) { \n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    })\n  });\n}\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise/lib/es6-extensions.js\n// module id = 87\n// module chunks = 2","'use strict';\n\n//This file contains then/promise specific extensions that are only useful for node.js interop\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity\n  return function () {\n    var self = this\n    var args = Array.prototype.slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop()\n      }\n      args.push(function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      })\n      var res = fn.apply(self, args)\n      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {\n        resolve(res)\n      }\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null\n    var ctx = this\n    try {\n      return fn.apply(this, arguments).nodeify(callback, ctx)\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) { reject(ex) })\n      } else {\n        asap(function () {\n          callback.call(ctx, ex)\n        })\n      }\n    }\n  }\n}\n\nPromise.prototype.nodeify = function (callback, ctx) {\n  if (typeof callback != 'function') return this\n\n  this.then(function (value) {\n    asap(function () {\n      callback.call(ctx, null, value)\n    })\n  }, function (err) {\n    asap(function () {\n      callback.call(ctx, err)\n    })\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/promise/lib/node-extensions.js\n// module id = 88\n// module chunks = 2","import loadingSpinnerGIF from '../../img/misc/loading.gif';\r\n\r\nexport default function initLoadingScreen() {\r\n  return new Promise(resolve => {\r\n    // The loading screen UI has to be generated without using Knockout because the Knockout\r\n    // bindings are not applied until after the map is loaded.\r\n\r\n    // Create and append loading spinner...\r\n    const loadingSpinner = document.createElement('img');\r\n    loadingSpinner.setAttribute('src', loadingSpinnerGIF);\r\n    loadingSpinner.setAttribute('class', 'loading-spinner');\r\n    const initMapContainerLoadingScreen = document.getElementsByClassName('init-map-container-loading-screen')[0];\r\n    initMapContainerLoadingScreen.appendChild(loadingSpinner);\r\n\r\n    // This conditional compensates the position of the loading spinner if the user is viewing\r\n    // the application in desktop mode. We want to move the loading spinner up a bit because the\r\n    // 'textbox' element is absolutely positioned over the map in desktop view, so it would look\r\n    // better if we move the loading spinner to be roughly halfway between the top border of the\r\n    // textbox and the top border of the viewport.\r\n    if (document.body.clientWidth >= 1366) {\r\n      const windowHeight = window.innerHeight;\r\n      const compensation = windowHeight / 1.775;\r\n      loadingSpinner.style.bottom = `${compensation}px`;\r\n    }\r\n\r\n    // Waits till all initial DOM content is loaded, then fades the loading spinner out and resolves\r\n    // the promise, which in turn triggers the application to fade in to view.\r\n    window.addEventListener('load', () => {\r\n      loadingSpinner.style.opacity = 1;\r\n      // Fade out the loading spinner before fading in the map area...\r\n      setTimeout(function fadeOutLoadingSpinner() {\r\n        loadingSpinner.style.opacity -= 0.05;\r\n        if (loadingSpinner.style.opacity <= 0) {\r\n          loadingSpinner.style.display = 'none';\r\n          resolve();\r\n        } else {\r\n          requestAnimationFrame(fadeOutLoadingSpinner);\r\n        }\r\n      }, 1000);\r\n    }, { passive: true }); // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n  });\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/modules/initLoadingScreen.js"],"sourceRoot":""}